<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fengzhen8023</title>
  
  <subtitle>fengzhen8023</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-15T05:25:44.810Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack入门学习笔记14 —— Webpack的源码映射</title>
    <link href="http://yoursite.com/2019/12/15/webpack%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014%20%E2%80%94%E2%80%94%20Webpack%E7%9A%84%E6%BA%90%E7%A0%81%E6%98%A0%E5%B0%84/"/>
    <id>http://yoursite.com/2019/12/15/webpack入门学习笔记14 —— Webpack的源码映射/</id>
    <published>2019-12-15T05:25:44.809Z</published>
    <updated>2019-12-15T05:25:44.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><p>Webpack作为一个功能强大的构建工具，能够对我们书写的代码进行打包编译，从而生成一系列新的代码文件，使得项目能够够在浏览器中正常渲染。</p><p>Webpack在工作的过程中，会对代码进行打包编译，这就会带来一个问题：如果项目中代码错误，浏览器中的报错提示，定位到的是打包编译后的代码，而不是我们在项目中实际书写的代码，比如以下报错：</p><p><img src="http://q1d2135zd.bkt.clouddn.com//webpack-14-01.png" alt></p><p>对于这种报错，如果是简单的项目还好。但是如果项目稍微复杂一点，开发人员进行调试程序，会变得非常困难。开发人员所期望看到的报错信息是这样的：</p><p><img src="http://q1d2135zd.bkt.clouddn.com//webpack-14-02.png" alt></p><p>如果是这样的报错信息，那么我们就可以快速定位到错误代码的位置，从而快速修复。想要达到这个目的，我们需要这么做呢？这篇博客就和大家分享一下这方面的知识，即webpack中的 <strong>源码映射</strong>。</p><h2 id="2-配置devtool属性，进行源码映射"><a href="#2-配置devtool属性，进行源码映射" class="headerlink" title="2. 配置devtool属性，进行源码映射"></a>2. 配置devtool属性，进行源码映射</h2><p>配置webpack的源码映射非常简单，直接在 <strong>webpack.config.js</strong> 文件中指定 <strong>devtool</strong> 属性即可，下面给出配置的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">/* 节省篇幅，其余配置已省略 */</span></span><br><span class="line">    devtool: <span class="string">"eval-source-map"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 <strong><a href="https://github.com/Fengzhen8023/webpack-learning" target="_blank" rel="noopener">GitHub仓库 - webpack-learning</a></strong> ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。</p><p>这里简单介绍下这个属性：</p><ul><li>devtool是开发工具，它的作用是生成源代码映射(Source Map)，方便调试</li><li>源代码映射记录了打包编译后的代码和源代码之间的位置对应关系。它可以让你在控制台查找日志（或错误）来源时，直接跳转到源代码中，而不是打包编译后的代码 </li></ul><p>该属性常使用的值有以下几个：</p><ul><li><strong>source-map： </strong>会产生单独的映射文件，控制台中的错误信息会定位到代码错误的文件，并且会定位到这文件的第几行第几列。帮助我们调试源代码。</li><li><strong>eval-source-map： </strong>不会产生单独的映射文件，但是控制台中的错误信息会定位到代码错误的文件，并且会定位到这文件的第几行第几列。</li><li><strong>cheap-module-source-map： </strong> 会产生单独的映射文件，控制台中国的错误信息会定位到代码出错的文件，但是只能定位到第几行出错，不能定位到第几列。</li><li><strong>cheap-module-eval-source-map： </strong>不会产生单独的映射文件，控制台中国的错误信息会定位到代码出错的文件，但是只能定位到第几行出错，不能定位到第几列。这个模式构件速度适中，而且会生成较好的源代码映射，适合在开发环境中使用 。</li></ul><h2 id="3-写在最后"><a href="#3-写在最后" class="headerlink" title="3. 写在最后"></a>3. 写在最后</h2><p>以上就是这篇博客的全部内容，希望对刚刚接触Webpack的同学有所帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-写在前面&quot;&gt;&lt;a href=&quot;#1-写在前面&quot; class=&quot;headerlink&quot; title=&quot;1. 写在前面&quot;&gt;&lt;/a&gt;1. 写在前面&lt;/h2&gt;&lt;p&gt;Webpack作为一个功能强大的构建工具，能够对我们书写的代码进行打包编译，从而生成一系列新的代码文件，
      
    
    </summary>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>React Router V5 翻译文档1：快速开始</title>
    <link href="http://yoursite.com/2019/12/15/React%20Router%20V5%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A31%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/"/>
    <id>http://yoursite.com/2019/12/15/React Router V5 翻译文档1：快速开始/</id>
    <published>2019-12-14T16:10:00.000Z</published>
    <updated>2019-12-15T06:33:47.801Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h5 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h5><p>原翻译作者：<a href="https://www.jianshu.com/u/5d660a479013" target="_blank" rel="noopener">https://www.jianshu.com/u/5d660a479013</a><br>原官网文档：<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">https://reacttraining.com/react-router/web/guides/quick-start</a></p></blockquote><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>你需要一个React web app 来添加react-router。  </p><p>如果你需要创建一个新的React Web App,最容易的方式是通过一个叫做<a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a>的官方脚手架来创建。    </p><p>第一步是先来安装<a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a>,如果你以及安装过这个工具，那么可以直接使用她来创建一个新的项目。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br><span class="line">create-react-app demo-app</span><br><span class="line">cd demo-app</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>React Router Dom 已经被发布到来npm上, 所以你可以用npm或yarn来安装她。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-router-dom</span><br></pre></td></tr></table></figure></p><h3 id="示例：基础路由"><a href="#示例：基础路由" class="headerlink" title="示例：基础路由"></a>示例：基础路由</h3><p>在这个例子中，我们会使用<router>来构建一个拥有3个页面的示例。<br>注意: 我们用 &lt; Link to=”/“&gt; 来代替 &lt; a href=”/“&gt;</router></p><p>把下方的代码复制到demo-app里面的src目录下的App.js文件中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Link &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">About</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>About<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Users</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Users<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppRouter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;nav&gt;</span><br><span class="line">          &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">              &lt;Link to=<span class="string">"/"</span>&gt;Home&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>li&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">              &lt;Link to=<span class="string">"/about/"</span>&gt;About&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>li&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">              &lt;Link to=<span class="string">"/users/"</span>&gt;Users&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>li&gt;</span><br><span class="line">          &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>nav&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Route path=<span class="string">"/"</span> exact component=&#123;Index&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/about/"</span> component=&#123;About&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/users/"</span> component=&#123;Users&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> AppRouter;</span><br></pre></td></tr></table></figure></p><h3 id="示例：嵌套路由"><a href="#示例：嵌套路由" class="headerlink" title="示例：嵌套路由"></a>示例：嵌套路由</h3><p>这个示例向我们展示来嵌套路由如何工作，路由 ‘/topics’会加载Topics组件，这个组件会通过’:id’的路由来渲染出更多的内容。  </p><p>把下方的代码复制到demo-app里面的src目录下的App.js文件中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Link &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Header /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/topics"</span> component=&#123;Topics&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">About</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>About<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Topic</span>(<span class="params">&#123; match &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Requested Param: &#123;match.params.id&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Topics</span>(<span class="params">&#123; match &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;Topics&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Link to=&#123;`$&#123;match.url&#125;/</span>components<span class="string">`&#125;&gt;Components&lt;/Link&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;</span></span><br><span class="line"><span class="string">          &lt;Link to=&#123;`</span>$&#123;match.url&#125;/props-v-state<span class="string">`&#125;&gt;Props v. State&lt;/Link&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      &lt;Route path=&#123;`</span>$&#123;match.path&#125;/:id<span class="string">`&#125; component=&#123;Topic&#125; /&gt;</span></span><br><span class="line"><span class="string">      &lt;Route</span></span><br><span class="line"><span class="string">        exact</span></span><br><span class="line"><span class="string">        path=&#123;match.path&#125;</span></span><br><span class="line"><span class="string">        render=&#123;() =&gt; &lt;h3&gt;Please select a topic.&lt;/h3&gt;&#125;</span></span><br><span class="line"><span class="string">      /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function Header() &#123;</span></span><br><span class="line"><span class="string">  return (</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">      &lt;li&gt;</span></span><br><span class="line"><span class="string">        &lt;Link to="/"&gt;Home&lt;/Link&gt;</span></span><br><span class="line"><span class="string">      &lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;li&gt;</span></span><br><span class="line"><span class="string">        &lt;Link to="/about"&gt;About&lt;/Link&gt;</span></span><br><span class="line"><span class="string">      &lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;li&gt;</span></span><br><span class="line"><span class="string">        &lt;Link to="/topics"&gt;Topics&lt;/Link&gt;</span></span><br><span class="line"><span class="string">      &lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default App;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h5 id=&quot;转载说明&quot;&gt;&lt;a href=&quot;#转载说明&quot; class=&quot;headerlink&quot; title=&quot;转载说明&quot;&gt;&lt;/a&gt;转载说明&lt;/h5&gt;&lt;p&gt;原翻译作者：&lt;a href=&quot;https://www.jianshu.com/u/5d660a47
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="React Router" scheme="http://yoursite.com/tags/React-Router/"/>
    
  </entry>
  
  <entry>
    <title>React Router V5 翻译文档2：基础组件</title>
    <link href="http://yoursite.com/2019/12/15/React%20Router%20V5%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A32%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/12/15/React Router V5 翻译文档2：基础组件/</id>
    <published>2019-12-14T16:09:00.000Z</published>
    <updated>2019-12-15T06:33:47.801Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h5 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h5><p>原翻译作者：<a href="https://www.jianshu.com/u/5d660a479013" target="_blank" rel="noopener">https://www.jianshu.com/u/5d660a479013</a><br>原官网文档：<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">https://reacttraining.com/react-router/web/guides/quick-start</a></p></blockquote><h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><p>React Router包含三种类型的组件： 路由组件，路由匹配组件，导航组件。  </p><p>在你使用这些组件前，都必须从react-router-dom导入她们。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Route, Link &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br></pre></td></tr></table></figure></p><h3 id="路由组件"><a href="#路由组件" class="headerlink" title="路由组件"></a>路由组件</h3><p>任何一个拥有路由跳转功能都React应用都核心都必须是一个路由组件。对于Web项目来说，react-router-dom提供了&lt; BrowserRouter &gt;和&lt; HashRouter &gt;这两种路由。她们会为你创建一个专业的history对象。通常来说，如果你有一个服务器来响应请求，那就使用&lt; BrowserRouter &gt;。如果你是用静态文件来提供服务，那么就使用 &lt; HashRouter &gt;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;BrowserRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/BrowserRouter&gt;,</span></span><br><span class="line"><span class="regexp">  holder</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><h3 id="路由匹配组件"><a href="#路由匹配组件" class="headerlink" title="路由匹配组件"></a>路由匹配组件</h3><p>路由匹配组件有两种：&lt; Route &gt;和&lt; Switch &gt;<br>路由匹配组件通过比较&lt; Route &gt;的path属性和当前页面地址栏的路径来工作。当一个&lt; Route &gt;匹配成功的时候，她会渲染出对应的内容，当匹配不成功的时候，任何内容都不会被渲染出来。当一个&lt; Route &gt;没有path属性时她对任何路径都会匹配成功。<br>你可以在你想要根据浏览器地址来渲染内容的任何地方使用&lt; Route &gt;,但是我们通常会把一组&lt; Route &gt;放在一起。&lt; Switch &gt;就是用来把多个&lt; Route &gt;组合在一起的。<br>我们不是必须要用&lt; Switch &gt;把多个&lt; Route &gt;组合在一起，但是这种做法通常是有用的。 &lt; Switch &gt;将迭代其所有子&lt; Route &gt;元素，并仅渲染与当前路径匹配的第一个子元素。 她对于多个path匹配相同的路径、动画路由之间的转换、没有路径匹配时的识别（这样你就可以渲染“404”组件）是有很大帮助的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Route, Switch &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"><span class="comment">// when location = &#123; pathname: '/about' &#125;</span></span><br><span class="line">&lt;Route path=<span class="string">'/about'</span> component=&#123;About&#125;/&gt; <span class="comment">// renders &lt;About/&gt;</span></span><br><span class="line">&lt;Route path=<span class="string">'/contact'</span> component=&#123;Contact&#125;/&gt; <span class="comment">// renders null</span></span><br><span class="line">&lt;Route component=&#123;Always&#125;/&gt; <span class="comment">// renders &lt;Always/&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125; /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/contact"</span> component=&#123;Contact&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">  &lt;Route exact path="/</span><span class="string">" component=&#123;Home&#125; /&gt;</span></span><br><span class="line"><span class="string">  &lt;Route path="</span>/about<span class="string">" component=&#123;About&#125; /&gt;</span></span><br><span class="line"><span class="string">  &lt;Route path="</span>/contact<span class="string">" component=&#123;Contact&#125; /&gt;</span></span><br><span class="line"><span class="string">  &#123;/* when none of the above match, &lt;NoMatch&gt; will be rendered */&#125;</span></span><br><span class="line"><span class="string">  &lt;Route component=&#123;NoMatch&#125; /&gt;</span></span><br><span class="line"><span class="string">&lt;/Switch&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="路由渲染属性"><a href="#路由渲染属性" class="headerlink" title="路由渲染属性"></a>路由渲染属性</h3><p>对于一个&lt; Route &gt;组件，你可以设置三种属性：component, render, children 来渲染出相应的内容。在这里我们只关注component和render,因为她们是经常会用到的，更多的内容可以查看&lt; Route &gt;的API文档。  </p><p>当你有一个已存在的组件（无论是一个React组件还是一个无状态的函数组件）想要渲染时应该使用component。当你必须传递一些参数变量给组件时应该用render属性，她采用内联函数的形式。你不应该使用component属性来渲染一个带有参数变量的内联函数组件，这会导致不必要的组件的挂载和卸载。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> someVariable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &#123;<span class="comment">/* these are good */</span>&#125;</span><br><span class="line">      &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        path=<span class="string">"/about"</span></span><br><span class="line">        render=&#123;props =&gt; <span class="xml"><span class="tag">&lt;<span class="name">About</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">extra</span>=<span class="string">&#123;someVariable&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">      /&gt;</span></span><br><span class="line"><span class="xml">      &#123;/* do not do this */&#125;</span></span><br><span class="line">      &lt;Route</span><br><span class="line">        path="/contact"</span><br><span class="line">        component=&#123;props =&gt; &lt;Contact &#123;...props&#125; extra=&#123;someVariable&#125; /&gt;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="导航组件"><a href="#导航组件" class="headerlink" title="导航组件"></a>导航组件</h3><p>React Router 提供了&lt; Link &gt;组件用来在你的应用中创建超链接。&lt; Link &gt;会在页面的任何地方被渲染成&lt; a &gt;标签  </p><p>&lt; NavLink &gt;是一种特殊的&lt; Link &gt;组件，当她的to属性匹配地址栏的路径时，她渲染成的&lt; a &gt;标签会带有’active’的样式。  </p><p>如果你想要强制跳转，你可以使用&lt; Redirect &gt;。当一个&lt; Redirect &gt;组件被渲染时，她会导航到其to属性匹配的路径。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">"/"</span>&gt;Home&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ &lt;a href='/</span><span class="string">'&gt;Home&lt;/a&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// location = &#123; pathname: '</span>/react<span class="string">' &#125;</span></span><br><span class="line"><span class="string">&lt;NavLink to="/react" activeClassName="hurray"&gt;</span></span><br><span class="line"><span class="string">  React</span></span><br><span class="line"><span class="string">&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">// &lt;a href='</span>/react<span class="string">' className='</span>hurray<span class="string">'&gt;React&lt;/a&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;Redirect to="/login" /&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h5 id=&quot;转载说明&quot;&gt;&lt;a href=&quot;#转载说明&quot; class=&quot;headerlink&quot; title=&quot;转载说明&quot;&gt;&lt;/a&gt;转载说明&lt;/h5&gt;&lt;p&gt;原翻译作者：&lt;a href=&quot;https://www.jianshu.com/u/5d660a47
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="React Router" scheme="http://yoursite.com/tags/React-Router/"/>
    
  </entry>
  
  <entry>
    <title>React Router V5 翻译文档3：服务端渲染</title>
    <link href="http://yoursite.com/2019/12/15/React%20Router%20V5%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A33%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    <id>http://yoursite.com/2019/12/15/React Router V5 翻译文档3：服务端渲染/</id>
    <published>2019-12-14T16:08:00.000Z</published>
    <updated>2019-12-15T06:33:47.801Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h5 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h5><p>原翻译作者：<a href="https://www.jianshu.com/u/5d660a479013" target="_blank" rel="noopener">https://www.jianshu.com/u/5d660a479013</a><br>原官网文档：<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">https://reacttraining.com/react-router/web/guides/quick-start</a></p></blockquote><h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><p>由于服务端是无状态的，所以服务端渲染和客户端渲染并不相同. 最基本的就是我们封装app时, 使用无状态的 &lt; StaticRouter &gt;来代替&lt; BrowserRouter &gt;, 使用来自于服务端的请求url来匹配路由。接下来我们会讨论 context 属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ server (not the complete story)</span></span><br><span class="line"><span class="regexp">&lt;StaticRouter</span></span><br><span class="line"><span class="regexp">  location=&#123;req.url&#125;</span></span><br><span class="line"><span class="regexp">  context=&#123;context&#125;</span></span><br><span class="line"><span class="regexp">&gt;</span></span><br><span class="line"><span class="regexp">  &lt;App/</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/StaticRouter&gt;</span></span><br></pre></td></tr></table></figure></p><p>当你在客户端渲染 &lt; Redirect &gt;, 浏览器地址栏会改变状态使我们能看到新的页面,然而在一个静态的服务环境下, 我们不能够改变app的状态。代替的是, 我们将渲染的结果赋给context属性. 如果我们找到了 context.url, 那么我们知道这个app重定向了. 这允许我们向服务端发送一个重定向请求<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> context = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> markup = ReactDOMServer.renderToString(</span><br><span class="line">  &lt;StaticRouter</span><br><span class="line">    location=&#123;req.url&#125;</span><br><span class="line">    context=&#123;context&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;App/&gt;</span><br><span class="line">  &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">if (context.url) &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ Somewhere a `&lt;Redirect&gt;` was rendered</span></span><br><span class="line"><span class="regexp">  redirect(301, context.url)</span></span><br><span class="line"><span class="regexp">&#125; else &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ we're good, send the response</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="添加明确的应用内容信息"><a href="#添加明确的应用内容信息" class="headerlink" title="添加明确的应用内容信息"></a>添加明确的应用内容信息</h3><p>路由只能添加 context.url. 但是你可能想要发送重定向的301或302的响应。或许你在某些特殊的UI渲染后需要发送一个404响应, 又或者在客户端没有认证的情况下发送401。 context属性是属于你的, 所以你可以任意改变她. 下面是分辨301与302重定向的方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RedirectWithStatus = <span class="function">(<span class="params">&#123; <span class="keyword">from</span>, to, status &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;Route render=&#123;(&#123; staticContext &#125;) =&gt; &#123;</span><br><span class="line">    <span class="comment">// there is no `staticContext` on the client, so</span></span><br><span class="line">    <span class="comment">// we need to guard against that here</span></span><br><span class="line">    <span class="keyword">if</span> (staticContext)</span><br><span class="line">      staticContext.status = status</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&#123;from&#125;</span> <span class="attr">to</span>=<span class="string">&#123;to&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;&#125;/&gt;</span></span><br><span class="line"><span class="xml">)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">// somewhere in your app</span></span><br><span class="line"><span class="xml">const App = () =&gt; (</span></span><br><span class="line">  &lt;Switch&gt;</span><br><span class="line">    &#123;/* some other routes */&#125;</span><br><span class="line">    &lt;RedirectWithStatus</span><br><span class="line">      status=&#123;301&#125;</span><br><span class="line">      from="/users"</span><br><span class="line">      to="/profiles"</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;RedirectWithStatus</span><br><span class="line">      status=&#123;302&#125;</span><br><span class="line">      from="/courses"</span><br><span class="line">      to="/dashboard"</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/Switch&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// on the server</span><br><span class="line">const context = &#123;&#125;</span><br><span class="line"></span><br><span class="line">const markup = ReactDOMServer.renderToString(</span><br><span class="line">  &lt;StaticRouter context=&#123;context&#125;&gt;</span><br><span class="line">    &lt;App/&gt;</span><br><span class="line">  &lt;/StaticRouter&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">if (context.url) &#123;</span><br><span class="line">  // can use the `context.status` that</span><br><span class="line">  // we added in RedirectWithStatus</span><br><span class="line">  redirect(context.status, context.url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="404-401-或其他状态"><a href="#404-401-或其他状态" class="headerlink" title="404, 401, 或其他状态"></a>404, 401, 或其他状态</h3><p>我们现在可以做到和上面一样的事，创建一个包含想要内容的组件，当收到不同的的状态码时可以在应用的任何地方渲染该组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Status</span>(<span class="params">&#123; code, children &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Route</span><br><span class="line">      render=&#123;(&#123; staticContext &#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (staticContext) staticContext.status = code;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，当你想要给静态内容添加一个状态码时，你可以在应用的任何地方渲染一种状态。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NotFound</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Status code=&#123;<span class="number">404</span>&#125;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Sorry, can’t find that.&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/Status&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ somewhere else</span></span><br><span class="line"><span class="regexp">&lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">  &lt;Route path="/</span>about<span class="string">" component=&#123;About&#125; /&gt;</span></span><br><span class="line"><span class="string">  &lt;Route path="</span>/dashboard<span class="string">" component=&#123;Dashboard&#125; /&gt;</span></span><br><span class="line"><span class="string">  &lt;Route component=&#123;NotFound&#125; /&gt;</span></span><br><span class="line"><span class="string">&lt;/Switch&gt;;</span></span><br></pre></td></tr></table></figure></p><h3 id="组合所有内容"><a href="#组合所有内容" class="headerlink" title="组合所有内容"></a>组合所有内容</h3><p>虽然这不是一个真正的应用，但是她展现了将所有内容组合在一起所需的常规部分<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">'react-dom/server'</span></span><br><span class="line"><span class="keyword">import</span> &#123; StaticRouter &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line">createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> context = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString(</span><br><span class="line">    &lt;StaticRouter</span><br><span class="line">      location=&#123;req.url&#125;</span><br><span class="line">      context=&#123;context&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;App/&gt;</span><br><span class="line">    &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  if (context.url) &#123;</span></span><br><span class="line"><span class="regexp">    res.writeHead(301, &#123;</span></span><br><span class="line"><span class="regexp">      Location: context.url</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">    res.end()</span></span><br><span class="line"><span class="regexp">  &#125; else &#123;</span></span><br><span class="line"><span class="regexp">    res.write(`</span></span><br><span class="line"><span class="regexp">      &lt;!doctype html&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div id="app"&gt;$&#123;html&#125;&lt;/</span>div&gt;</span><br><span class="line">    <span class="string">`)</span></span><br><span class="line"><span class="string">    res.end()</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;).listen(3000)</span></span><br></pre></td></tr></table></figure></p><p>然后是客户端<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render((</span><br><span class="line">  &lt;BrowserRouter&gt;</span><br><span class="line">    &lt;App/&gt;</span><br><span class="line">  &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">), document.getElementById('app'))</span></span><br></pre></td></tr></table></figure></p><h3 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h3><p>要做到这一点有很多不同的方法，对此并没有最佳的实践。所以我们寻求多种方法的不同组合方式，而不是规定或倾向某一种。我们相信React Router可以在你的应用的规则限制下找到一种合理的方式。  </p><p>最主要的约束是你希望在页面渲染前加载完数据。React Router暴露了一个matchPath静态函数，你可以用她来进行路由匹配。你可以在服务端用这个函数来确定哪些依赖的数据是要在渲染前完成的。   </p><p>这种方法的特点是在进行实际跳转前设定好静态匹配规则，在实际跳转前就已经知道要使用哪些数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/'</span>,</span><br><span class="line">    component: Root,</span><br><span class="line">    loadData: <span class="function"><span class="params">()</span> =&gt;</span> getSomeData(),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// etc.</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>然后使用这些规则在应用中渲染你的路由<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; routes &#125; <span class="keyword">from</span> <span class="string">'./routes'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;Switch&gt;</span><br><span class="line">    &#123;routes.map(<span class="function"><span class="params">route</span> =&gt;</span> (</span><br><span class="line">      &lt;Route &#123;...route&#125;/&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">  &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure></p><p>在服务端你可能会做这些；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; matchPath &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// inside a request</span></span><br><span class="line"><span class="keyword">const</span> promises = []</span><br><span class="line"><span class="comment">// use `some` to imitate `&lt;Switch&gt;` behavior of selecting only</span></span><br><span class="line"><span class="comment">// the first to match</span></span><br><span class="line">routes.some(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// use `matchPath` here</span></span><br><span class="line">  <span class="keyword">const</span> match = matchPath(req.url, route)</span><br><span class="line">  <span class="keyword">if</span> (match)</span><br><span class="line">    promises.push(route.loadData(match))</span><br><span class="line">  <span class="keyword">return</span> match</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something w/ the data so the client</span></span><br><span class="line">  <span class="comment">// can access it then render the app</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>最后，客户端需要获取数据。我们并不是给你的应用规定数据加载的模式，但这些是在开发中常用的形式。  </p><p>你可能会对我们的进行数据加载和静态路由配置的<a href="https://github.com/ReactTraining/react-router/tree/master/packages/react-router-config" target="_blank" rel="noopener">React Router Config</a>包感兴趣。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h5 id=&quot;转载说明&quot;&gt;&lt;a href=&quot;#转载说明&quot; class=&quot;headerlink&quot; title=&quot;转载说明&quot;&gt;&lt;/a&gt;转载说明&lt;/h5&gt;&lt;p&gt;原翻译作者：&lt;a href=&quot;https://www.jianshu.com/u/5d660a47
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="React Router" scheme="http://yoursite.com/tags/React-Router/"/>
    
  </entry>
  
  <entry>
    <title>React Router V5 翻译文档4：代码拆分</title>
    <link href="http://yoursite.com/2019/12/15/React%20Router%20V5%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A34%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86/"/>
    <id>http://yoursite.com/2019/12/15/React Router V5 翻译文档4：代码拆分/</id>
    <published>2019-12-14T16:07:00.000Z</published>
    <updated>2019-12-15T06:33:47.802Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h5 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h5><p>原翻译作者：<a href="https://www.jianshu.com/u/5d660a479013" target="_blank" rel="noopener">https://www.jianshu.com/u/5d660a479013</a><br>原官网文档：<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">https://reacttraining.com/react-router/web/guides/quick-start</a></p></blockquote><h2 id="代码拆分"><a href="#代码拆分" class="headerlink" title="代码拆分"></a>代码拆分</h2><p>Web应用一个非常出色的特性就是我们不必下载整个应用就可以使用。你可以认为代码拆分是逐渐递增的加载我们的应用。在这里，我们使用webpack, @babel/plugin-syntax-dynamic-import,和loadable-components来实现。  </p><p>webpack内置了对动态导入的支持; 但是，如果你使用Babel（例如，将JSX编译为JavaScript），那么你将需要同时使用@ babel / plugin-syntax-dynamic-import插件。 这是一个仅只进行语法解析的插件，这意味着Babel不会进行任何其他转换。 该插件只允许Babel解析动态导入，因此webpack可以将它们打包成不同的代码模块。 你的.babelrc应该是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"@babel/preset-react"</span>],</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"@babel/plugin-syntax-dynamic-import"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>loadable-components是一个用于加载具有动态导入功能的组件的库。 她会自动处理各种边缘情况，使代码拆分变得简单，以下是如何使用loadable-components的示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> loadable <span class="keyword">from</span> <span class="string">'@loadable/component'</span></span><br><span class="line"><span class="keyword">import</span> Loading <span class="keyword">from</span> <span class="string">"./Loading"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LoadableComponent = loadable(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Dashboard'</span>), &#123;</span><br><span class="line">  fallback: Loading,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadableDashboard</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LoadableComponent</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><p>只需使用LoadableDashboard（或任何你自定义的组件），当你在应用程序中使用它时，它将自动加载和渲染。在实际组件加载时，fallback是一种占位的组件。<a href="https://www.smooth-code.com/open-source/loadable-components/docs/getting-started/" target="_blank" rel="noopener">此处</a>提供了完整的文档  </p><h3 id="代码拆分和Server-Side渲染"><a href="#代码拆分和Server-Side渲染" class="headerlink" title="代码拆分和Server-Side渲染"></a>代码拆分和Server-Side渲染</h3><p>loadable-components包含了server-side渲染的引导。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h5 id=&quot;转载说明&quot;&gt;&lt;a href=&quot;#转载说明&quot; class=&quot;headerlink&quot; title=&quot;转载说明&quot;&gt;&lt;/a&gt;转载说明&lt;/h5&gt;&lt;p&gt;原翻译作者：&lt;a href=&quot;https://www.jianshu.com/u/5d660a47
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="React Router" scheme="http://yoursite.com/tags/React-Router/"/>
    
  </entry>
  
  <entry>
    <title>React Router V5 翻译文档5：滚动恢复</title>
    <link href="http://yoursite.com/2019/12/15/React%20Router%20V5%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A35%EF%BC%9A%E6%BB%9A%E5%8A%A8%E6%81%A2%E5%A4%8D/"/>
    <id>http://yoursite.com/2019/12/15/React Router V5 翻译文档5：滚动恢复/</id>
    <published>2019-12-14T16:06:00.000Z</published>
    <updated>2019-12-15T06:33:47.801Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h5 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h5><p>原翻译作者：<a href="https://www.jianshu.com/u/5d660a479013" target="_blank" rel="noopener">https://www.jianshu.com/u/5d660a479013</a><br>原官网文档：<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">https://reacttraining.com/react-router/web/guides/quick-start</a></p></blockquote><h2 id="滚动恢复"><a href="#滚动恢复" class="headerlink" title="滚动恢复"></a>滚动恢复</h2><p>在早期的React Router版本中，我们为滚动恢复提供了开箱即用的支持，从那时起开发者就一直在使用。希望本文档可以帮助你获取你需要的滚动条和路由的内容。  </p><p>浏览器已经开始使用history.pushState自己处理滚动恢复，这就像她们以前使用普通浏览器导航一样处理滚动恢复。现在这个很酷的特性已经在Chrome中被支持了。  </p><p>因为浏览器开始处理“默认情况”，并且不同的应用程序具有不同的滚动需求（就像本站这样），所以我们不提供默认的滚动管理。但是本指南应该可以帮助你实现任何滚动需求。  </p><h3 id="滚动到顶部"><a href="#滚动到顶部" class="headerlink" title="滚动到顶部"></a>滚动到顶部</h3><p>大多数情况下，你需要的是“滚动到顶部”这个功能，因为大部分情况是有一个包含了大量内容的长页面。使用<scrolltotop>组件可以直接处理这中情况，该组件将会实现在每个导航上滚动窗口到顶部，你需要确保使用withRouter封装该组件以使其能够访问路由器的props。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollToTop</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidUpdate(prevProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.location.pathname !== prevProps.location.pathname) &#123;</span><br><span class="line">      <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(ScrollToTop);</span><br></pre></td></tr></table></figure></scrolltotop></p><p>然后将其渲染在应用的顶部<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">      &lt;ScrollToTop&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ScrollToTop&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or just render it bare anywhere you want, but just one :)</span></span><br><span class="line">&lt;ScrollToTop /&gt;;</span><br></pre></td></tr></table></figure></p><p>如果你有一个连接到路由的tab选项卡，那么你可能不希望在切换标签时滚动到顶部。此时可以使用<scrolltotoponmount>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollToTopOnMount</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongContent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ScrollToTopOnMount /&gt;</span><br><span class="line">      &lt;h1&gt;Here is my long content page&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// somewhere else</span></span><br><span class="line">&lt;Route path=<span class="string">"/long-content"</span> component=&#123;LongContent&#125; /&gt;;</span><br></pre></td></tr></table></figure></scrolltotoponmount></p><h3 id="通用解决方案"><a href="#通用解决方案" class="headerlink" title="通用解决方案"></a>通用解决方案</h3><p>对于通用解决方案（以及浏览器开始本地实现）我们谈论两件事：</p><ol><li>导航跳转时自动滚动到页面顶部，这样不会出现创建一个新的页面滚动条在底部。</li><li>在前进或后退时保留原来滚动条的位置（不包含点击跳转链接）    </li></ol><p>对于第一点我们想要发布一个通用的api，这是我们想要的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;ScrollRestoration&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;App&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      &lt;RestoredScroll id="bunny"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div style=&#123;&#123; height: "200px", overflow: "auto" &#125;&#125;&gt;I will overflow&lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/RestoredScroll&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/ScrollRestoration&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Router&gt;</span><br></pre></td></tr></table></figure></p><p>首先，ScrollRestoration将在导航时向上滚动窗口。 其次，它将使用location.key将窗口滚动位置和RestoredScroll组件的滚动位置保存到sessionStorage。 然后，当ScrollRestoration或RestoredScroll组件挂载时，他们可以从sessionsStorage中查找它们的位置。  </p><p>对我来说棘手的是当我不希望管理窗口滚动时,如何实现一个“选择退出”API，。 例如，当你有一些浮动在页面上的选项卡导航时，你可能不希望滚动到顶部（选项卡可能会滚动到视图之外）。  </p><p>当我了解到chrome现在已经在为我们管理滚动位置，并且意识到不同的应用将有不同的滚动需求时，我有点失去了做这件事的信念 - 特别是当人们只想滚动到顶部时（ 你看到的是很容易直接添加到你的应用的内容）。  </p><p>基于此，我们觉得我们已经没有足够的力量来完成这项工作（就像你的时间是有限的一样）。但是，我们很乐意帮助任何愿意使用通用解决方案的人。如果你一开始就使用她，你的项目会有一个可靠的解决方案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h5 id=&quot;转载说明&quot;&gt;&lt;a href=&quot;#转载说明&quot; class=&quot;headerlink&quot; title=&quot;转载说明&quot;&gt;&lt;/a&gt;转载说明&lt;/h5&gt;&lt;p&gt;原翻译作者：&lt;a href=&quot;https://www.jianshu.com/u/5d660a47
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="React Router" scheme="http://yoursite.com/tags/React-Router/"/>
    
  </entry>
  
  <entry>
    <title>React Router V5 翻译文档6：设计思想</title>
    <link href="http://yoursite.com/2019/12/15/React%20Router%20V5%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A36%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2019/12/15/React Router V5 翻译文档6：设计思想/</id>
    <published>2019-12-14T16:05:00.000Z</published>
    <updated>2019-12-15T06:32:31.526Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h5 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h5><p>原翻译作者：<a href="https://www.jianshu.com/u/5d660a479013" target="_blank" rel="noopener">https://www.jianshu.com/u/5d660a479013</a><br>原官网文档：<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">https://reacttraining.com/react-router/web/guides/quick-start</a></p></blockquote><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>这篇指南是是用来解释React Router使用时的心智模型。我们将其称为“动态路由”，这与你可能更熟悉的“静态路由”完全不同。  </p><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>如果你使用过Rails，Express，Ember，Angular等框架，那么你已经使用过了静态路由。 在这些框架中，当你在进行任何渲染之前，会将路由声明为应用初始化的一部分。React Router pre-v4在大多数情况下也是静态的。下面我们来看看如何在express中配置路由：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Express Style routing:</span></span><br><span class="line">app.get(<span class="string">"/"</span>, handleIndex);</span><br><span class="line">app.get(<span class="string">"/invoices"</span>, handleInvoices);</span><br><span class="line">app.get(<span class="string">"/invoices/:id"</span>, handleInvoice);</span><br><span class="line">app.get(<span class="string">"/invoices/:id/edit"</span>, handleInvoiceEdit);</span><br><span class="line"></span><br><span class="line">app.listen();</span><br></pre></td></tr></table></figure></p><p>请注意在应用监听请求之前是如何声明路由的。我们使用的客户端路由与其是相似当。在Angular中，你可以预先声明路由，然后在渲染之前将它们导入顶级AppModule中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Angular Style routing:</span></span><br><span class="line"><span class="keyword">const</span> appRoutes: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"crisis-center"</span>,</span><br><span class="line">    component: CrisisListComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"hero/:id"</span>,</span><br><span class="line">    component: HeroDetailComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"heroes"</span>,</span><br><span class="line">    component: HeroListComponent,</span><br><span class="line">    data: &#123; <span class="attr">title</span>: <span class="string">"Heroes List"</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">""</span>,</span><br><span class="line">    redirectTo: <span class="string">"/heroes"</span>,</span><br><span class="line">    pathMatch: <span class="string">"full"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"**"</span>,</span><br><span class="line">    component: PageNotFoundComponent</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [RouterModule.forRoot(appRoutes)]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>Ember有一个常规的routes.js文件，在构建时会读取这个文件当内容并导入到应用中。这会在应用渲染前进行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ember Style Router:</span></span><br><span class="line">Router.map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.route(<span class="string">"about"</span>);</span><br><span class="line">  <span class="keyword">this</span>.route(<span class="string">"contact"</span>);</span><br><span class="line">  <span class="keyword">this</span>.route(<span class="string">"rentals"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.route(<span class="string">"show"</span>, &#123; <span class="attr">path</span>: <span class="string">"/:rental_id"</span> &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Router;</span><br></pre></td></tr></table></figure></p><p>尽管API不同，但她们都遵循“静态路由”模型。React Router遵循这个模型直到v4。但是要成功使用React Router，你需要忘记这一切。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>坦率地说，我们React Router直到v2版本所采取的开发方向感到非常沮丧。 我们（Michael和Ryan）感觉现在采用的这种路由方式受限于API，我们正在重新实现React（生命周期等）的部分，并且它与React给我们创造UI的心智模型不匹配。当我们在研讨会之前在一家酒店的走廊互相讨论时。我们互相问道：“如果我们使用我们在之前讨论的模式构建路由会是什么样子？”开发只需要几个小时，我们就有了一个验证的概念，我们知道她是未来我们想要路由。 我们最终意识到API并不应该在React的“外部”，这是一个由React的其余部分组成并自然落实到位的API。我们认为你会喜欢她。</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>动态路由指的是在应用渲染时发生的路由，而不是在正在运行的应用之外配置或规定好的路由。这意味着几乎所有东西都是React Router中的一个组件。接下来看一下这个API是如何工作的：  </p><p>首先，创建一个路由组件，将其渲染在应用的顶部。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// react-native</span></span><br><span class="line"><span class="keyword">import</span> &#123; NativeRouter &#125; <span class="keyword">from</span> <span class="string">"react-router-native"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// react-dom (what we'll use here)</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;BrowserRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/BrowserRouter&gt;,</span></span><br><span class="line"><span class="regexp">  el</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><p>接下来，创建一个链接组件将其链接到一个新的地址。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;nav&gt;</span><br><span class="line">      &lt;Link to=<span class="string">"/dashboard"</span>&gt;Dashboard&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>nav&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><p>最后，当用户查看‘/dashboard’路径时，渲染该路由并展示对应UI<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;nav&gt;</span><br><span class="line">      &lt;Link to=<span class="string">"/dashboard"</span>&gt;Dashboard&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>nav&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/dashboard"</span> component=&#123;Dashboard&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>Route将渲染<dashboard {... props}>，props是一些看起来像{match，location，history}这样的特定的路由的属性。如果用户不在‘/dashboard’路径下，那么Route将不渲染任何东西。这就是它的全部内容。</dashboard></p><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>很多路由库都有一些“嵌套路由”的概念。如果你使用过React Router V4以前的版本，那么你就会知道我们也是这样做的。然而当你从静态路由配置移动到动态渲染路由时，该如何“嵌套路由”呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;BrowserRouter&gt;</span><br><span class="line">    &#123;<span class="comment">/* here's a div */</span>&#125;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="comment">/* here's a Route */</span>&#125;</span><br><span class="line">      &lt;Route path=<span class="string">"/tacos"</span> component=&#123;Tacos&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>BrowserRouter&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// when the url matches `/tacos` this component renders</span></span><br><span class="line"><span class="keyword">const</span> Tacos = <span class="function">(<span class="params">&#123; match &#125;</span>) =&gt;</span> (</span><br><span class="line">  <span class="comment">// here's a nested div</span></span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;<span class="comment">/* here's a nested Route,</span></span><br><span class="line"><span class="comment">        match.url helps us make a relative path */</span>&#125;</span><br><span class="line">    &lt;Route path=&#123;match.url + <span class="string">"/carnitas"</span>&#125; component=&#123;Carnitas&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><p>如上代码，React Router并没有嵌套的API，Router仅仅是一个组件，就想一个普通的div一样。</p><h3 id="响应路由"><a href="#响应路由" class="headerlink" title="响应路由"></a>响应路由</h3><p>设想一下用户导航到’/invoice’。你的应用需要适用于不同的尺寸的屏幕，当她们具有较窄的视口时，你只需向其显示发票列表和到发票详情的链接。她们可以导航到更深入的层级。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Small Screen</span><br><span class="line">url: <span class="regexp">/invoices</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">+----------------------+</span></span><br><span class="line"><span class="regexp">|                      |</span></span><br><span class="line"><span class="regexp">|      Dashboard       |</span></span><br><span class="line"><span class="regexp">|                      |</span></span><br><span class="line"><span class="regexp">+----------------------+</span></span><br><span class="line"><span class="regexp">|                      |</span></span><br><span class="line"><span class="regexp">|      Invoice 01      |</span></span><br><span class="line"><span class="regexp">|                      |</span></span><br><span class="line"><span class="regexp">+----------------------+</span></span><br><span class="line"><span class="regexp">|                      |</span></span><br><span class="line"><span class="regexp">|      Invoice 02      |</span></span><br><span class="line"><span class="regexp">|                      |</span></span><br><span class="line"><span class="regexp">+----------------------+</span></span><br><span class="line"><span class="regexp">|                      |</span></span><br><span class="line"><span class="regexp">|      Invoice 03      |</span></span><br><span class="line"><span class="regexp">|                      |</span></span><br><span class="line"><span class="regexp">+----------------------+</span></span><br><span class="line"><span class="regexp">|                      |</span></span><br><span class="line"><span class="regexp">|      Invoice 04      |</span></span><br><span class="line"><span class="regexp">|                      |</span></span><br><span class="line"><span class="regexp">+----------------------+</span></span><br></pre></td></tr></table></figure></p><p>在更大的屏幕上，我们会想要显示一个类别-详细内容的视图，其中导航位于左侧，详情或特定发票显示在右侧。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Large Screen</span><br><span class="line">url: <span class="regexp">/invoices/</span>dashboard</span><br><span class="line"></span><br><span class="line">+----------------------+---------------------------+</span><br><span class="line">|                      |                           |</span><br><span class="line">|      Dashboard       |                           |</span><br><span class="line">|                      |   Unpaid:             <span class="number">5</span>   |</span><br><span class="line">+----------------------+                           |</span><br><span class="line">|                      |   Balance:   $<span class="number">53</span>,<span class="number">543.00</span>   |</span><br><span class="line">|      Invoice <span class="number">01</span>      |                           |</span><br><span class="line">|                      |   Past Due:           <span class="number">2</span>   |</span><br><span class="line">+----------------------+                           |</span><br><span class="line">|                      |                           |</span><br><span class="line">|      Invoice <span class="number">02</span>      |                           |</span><br><span class="line">|                      |   +-------------------+   |</span><br><span class="line">+----------------------+   |                   |   |</span><br><span class="line">|                      |   |  +    +     +     |   |</span><br><span class="line">|      Invoice <span class="number">03</span>      |   |  | +  |     |     |   |</span><br><span class="line">|                      |   |  | |  |  +  |  +  |   |</span><br><span class="line">+----------------------+   |  | |  |  |  |  |  |   |</span><br><span class="line">|                      |   +--+-+--+--+--+--+--+   |</span><br><span class="line">|      Invoice <span class="number">04</span>      |                           |</span><br><span class="line">|                      |                           |</span><br><span class="line">+----------------------+---------------------------+</span><br></pre></td></tr></table></figure></p><p>现在暂停考虑一下两种屏幕尺寸的/invoice URL,她是大尺寸屏幕的有效路由吗？我们应该把右边的东西放在什么位置？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Large Screen</span><br><span class="line">url: <span class="regexp">/invoices</span></span><br><span class="line"><span class="regexp">+----------------------+---------------------------+</span></span><br><span class="line"><span class="regexp">|                      |                           |</span></span><br><span class="line"><span class="regexp">|      Dashboard       |                           |</span></span><br><span class="line"><span class="regexp">|                      |                           |</span></span><br><span class="line"><span class="regexp">+----------------------+                           |</span></span><br><span class="line"><span class="regexp">|                      |                           |</span></span><br><span class="line"><span class="regexp">|      Invoice 01      |                           |</span></span><br><span class="line"><span class="regexp">|                      |                           |</span></span><br><span class="line"><span class="regexp">+----------------------+                           |</span></span><br><span class="line"><span class="regexp">|                      |                           |</span></span><br><span class="line"><span class="regexp">|      Invoice 02      |             ???           |</span></span><br><span class="line"><span class="regexp">|                      |                           |</span></span><br><span class="line"><span class="regexp">+----------------------+                           |</span></span><br><span class="line"><span class="regexp">|                      |                           |</span></span><br><span class="line"><span class="regexp">|      Invoice 03      |                           |</span></span><br><span class="line"><span class="regexp">|                      |                           |</span></span><br><span class="line"><span class="regexp">+----------------------+                           |</span></span><br><span class="line"><span class="regexp">|                      |                           |</span></span><br><span class="line"><span class="regexp">|      Invoice 04      |                           |</span></span><br><span class="line"><span class="regexp">|                      |                           |</span></span><br><span class="line"><span class="regexp">+----------------------+---------------------------+</span></span><br></pre></td></tr></table></figure></p><p>在大屏幕上，’/invoice’不是有效的路线，但在小屏幕上她是有效的，更有趣的是，请考虑一个拥尺寸手机的人。她/他可以用横屏和竖屏两种方式来查看手机页面。突然间，我们有足够的空间来显示类别-详情这种UI，所以你应该立即重定向！  </p><p>React Router在先前版本的静态路由并没有真正成功的答案。但是，当路由是动态的时，你可以声明性地重组这些功能。如果你开始考虑将路由作为UI而不是静态配置，那么你会写出以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;AppLayout&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/invoices"</span> component=&#123;Invoices&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/AppLayout&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Invoices = () =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;Layout&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* always show the nav *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &lt;InvoicesNav /</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Media query=&#123;PRETTY_SMALL&#125;&gt;</span><br><span class="line">      &#123;screenIsSmall =&gt;</span><br><span class="line">        screenIsSmall ? (</span><br><span class="line">          <span class="comment">// small screen has no redirect</span></span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route exact path=<span class="string">"/invoices/dashboard"</span> component=&#123;Dashboard&#125; /&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/invoices/:id"</span> component=&#123;Invoice&#125; /&gt;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        ) : (</span></span><br><span class="line"><span class="regexp">          /</span><span class="regexp">/ large screen does!</span></span><br><span class="line"><span class="regexp">          &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Route exact path="/i</span>nvoices/dashboard<span class="string">" component=&#123;Dashboard&#125; /&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="</span>/invoices/:id<span class="string">" component=&#123;Invoice&#125; /&gt;</span></span><br><span class="line"><span class="string">            &lt;Redirect from="</span>/invoices<span class="string">" to="</span>/invoices/dashboard<span class="string">" /&gt;</span></span><br><span class="line"><span class="string">          &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &lt;/Media&gt;</span></span><br><span class="line"><span class="string">  &lt;/Layout&gt;</span></span><br><span class="line"><span class="string">);</span></span><br></pre></td></tr></table></figure></p><p>当用户将手机从纵向旋转到横向时，此代码会自动将其重定向到详情页。该组有效路由将根据用户手中的移动设备的动态特性而改变。  </p><p>这只是一个例子。我们还有许多其他问题可以讨论，我们总结一下规律：我们应该考虑组件，而不是静态路由。考虑如何使用React的声明可组合性来解决问题，因为几乎每个“React Router问题”都可能是“React问题”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h5 id=&quot;转载说明&quot;&gt;&lt;a href=&quot;#转载说明&quot; class=&quot;headerlink&quot; title=&quot;转载说明&quot;&gt;&lt;/a&gt;转载说明&lt;/h5&gt;&lt;p&gt;原翻译作者：&lt;a href=&quot;https://www.jianshu.com/u/5d660a47
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="React Router" scheme="http://yoursite.com/tags/React-Router/"/>
    
  </entry>
  
  <entry>
    <title>React Router V5 翻译文档7：测试</title>
    <link href="http://yoursite.com/2019/12/15/React%20Router%20V5%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A37%EF%BC%9A%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2019/12/15/React Router V5 翻译文档7：测试/</id>
    <published>2019-12-14T16:04:00.000Z</published>
    <updated>2019-12-15T06:33:47.802Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h5 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h5><p>原翻译作者：<a href="https://www.jianshu.com/u/5d660a479013" target="_blank" rel="noopener">https://www.jianshu.com/u/5d660a479013</a><br>原官网文档：<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">https://reacttraining.com/react-router/web/guides/quick-start</a></p></blockquote><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>React Router依赖React上下文来工作。 这会影响您如何测试使用我们组件的组件。  </p><p>如果你对应用渲染的<link>或者<router>组件进行单元测试，那么你会得到一些有关上下文的错误和警告信息。虽然你可能会找出自己的路由上下文的内容，我们推荐你将你的单元测试包裹在<staticrouter>或者<memoryrouter>中。代码如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sidebar</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.toggleExpand&#125;&gt;</span><br><span class="line">          expand</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &#123;users.map(user =&gt; (</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;</span></span><br><span class="line"><span class="regexp">               &lt;Link to=&#123;user.path&#125;&gt;</span></span><br><span class="line"><span class="regexp">                 &#123;user.name&#125;</span></span><br><span class="line"><span class="regexp">               &lt;/</span>Link&gt;</span><br><span class="line">            &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ broken</span></span><br><span class="line"><span class="regexp">test('it expands when the button is clicked', () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  render(</span></span><br><span class="line"><span class="regexp">    &lt;Sidebar/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">  click(theButton)</span><br><span class="line">  expect(theThingToBeOpen)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fixed!</span></span><br><span class="line">test(<span class="string">'it expands when the button is clicked'</span>, () =&gt; &#123;</span><br><span class="line">  render(</span><br><span class="line">    &lt;MemoryRouter&gt;</span><br><span class="line">      &lt;Sidebar/&gt;</span><br><span class="line">    &lt;<span class="regexp">/MemoryRouter&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">  click(theButton)</span></span><br><span class="line"><span class="regexp">  expect(theThingToBeOpen)</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure></memoryrouter></staticrouter></router></p><h3 id="从特定路由开始"><a href="#从特定路由开始" class="headerlink" title="从特定路由开始"></a>从特定路由开始</h3><p>&lt; MemoryRouter &gt;支持initialEntries和initialIndex 属性。因此你可以从一个特定的路径来启动你的应用（或者是从应用的一小部分)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"current user is active in sidebar"</span>, () =&gt; &#123;</span><br><span class="line">  render(</span><br><span class="line">    &lt;MemoryRouter initialEntries=&#123;[<span class="string">"/users/2"</span>]&#125;&gt;</span><br><span class="line">      &lt;Sidebar /&gt;</span><br><span class="line">    &lt;<span class="regexp">/MemoryRouter&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  expectUserToBeActive(2);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure></p><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><p>当路径改变时我们有许多路由测试的任务，因此你可能不需要再测试这个。但是如果你必须这样做的话，既然这发生在渲染时，那么我们可以这样做：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render, unmountComponentAtNode &#125; <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, Link, MemoryRouter &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Simulate &#125; <span class="keyword">from</span> <span class="string">"react-addons-test-utils"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a way to render any part of your app inside a MemoryRouter</span></span><br><span class="line"><span class="comment">// you pass it a list of steps to execute when the location</span></span><br><span class="line"><span class="comment">// changes, it will call back to you with stuff like</span></span><br><span class="line"><span class="comment">// `match` and `location`, and `history` so you can control</span></span><br><span class="line"><span class="comment">// the flow and make assertions.</span></span><br><span class="line"><span class="keyword">const</span> renderTestSequence = (&#123;</span><br><span class="line">  initialEntries,</span><br><span class="line">  initialIndex,</span><br><span class="line">  subject: Subject,</span><br><span class="line">  steps</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Assert</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">this</span>.assert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidUpdate() &#123;</span><br><span class="line">      <span class="keyword">this</span>.assert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert() &#123;</span><br><span class="line">      <span class="keyword">const</span> nextStep = steps.shift();</span><br><span class="line">      <span class="keyword">if</span> (nextStep) &#123;</span><br><span class="line">        nextStep(&#123; ...this.props, div &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        unmountComponentAtNode(div);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;MemoryRouter</span><br><span class="line">          initialIndex=&#123;initialIndex&#125;</span><br><span class="line">          initialEntries=&#123;initialEntries&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;Route</span><br><span class="line">            render=&#123;props =&gt; (</span><br><span class="line">              &lt;Assert &#123;...props&#125;&gt;</span><br><span class="line">                &lt;Subject /&gt;</span><br><span class="line">              &lt;<span class="regexp">/Assert&gt;</span></span><br><span class="line"><span class="regexp">            )&#125;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/MemoryRouter&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render(&lt;Test /</span>&gt;, div);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// our Subject, the App, but you can test any sub</span></span><br><span class="line"><span class="comment">// section of your app too</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Route</span><br><span class="line">      exact</span><br><span class="line">      path=<span class="string">"/"</span></span><br><span class="line">      render=&#123;() =&gt; (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h1&gt;Welcome&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;Route</span><br><span class="line">      path=<span class="string">"/dashboard"</span></span><br><span class="line">      render=&#123;() =&gt; (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h1&gt;Dashboard&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Link to="/</span><span class="string">" id="</span>click-me<span class="string">"&gt;</span></span><br><span class="line"><span class="string">            Home</span></span><br><span class="line"><span class="string">          &lt;/Link&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      )&#125;</span></span><br><span class="line"><span class="string">    /&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// the actual test!</span></span><br><span class="line"><span class="string">it("</span>navigates around<span class="string">", done =&gt; &#123;</span></span><br><span class="line"><span class="string">  renderTestSequence(&#123;</span></span><br><span class="line"><span class="string">    // tell it the subject you're testing</span></span><br><span class="line"><span class="string">    subject: App,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // and the steps to execute each time the location changes</span></span><br><span class="line"><span class="string">    steps: [</span></span><br><span class="line"><span class="string">      // initial render</span></span><br><span class="line"><span class="string">      (&#123; history, div &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="string">        // assert the screen says what we think it should</span></span><br><span class="line"><span class="string">        console.assert(div.innerHTML.match(/Welcome/));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // now we can imperatively navigate as the test</span></span><br><span class="line"><span class="string">        history.push("</span>/dashboard<span class="string">");</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      // second render from new location</span></span><br><span class="line"><span class="string">      (&#123; div &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="string">        console.assert(div.innerHTML.match(/Dashboard/));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // or we can simulate clicks on Links instead of</span></span><br><span class="line"><span class="string">        // using history.push</span></span><br><span class="line">        Simulate.click(div.querySelector("#click-me"), &#123;</span><br><span class="line">          button: <span class="number">0</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// final render</span></span><br><span class="line">      (&#123; location &#125;) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.assert(location.pathname === <span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">// you'll want something like `done()` so your test</span></span><br><span class="line">        <span class="comment">// fails if you never make it here.</span></span><br><span class="line">        done();</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h5 id=&quot;转载说明&quot;&gt;&lt;a href=&quot;#转载说明&quot; class=&quot;headerlink&quot; title=&quot;转载说明&quot;&gt;&lt;/a&gt;转载说明&lt;/h5&gt;&lt;p&gt;原翻译作者：&lt;a href=&quot;https://www.jianshu.com/u/5d660a47
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="React Router" scheme="http://yoursite.com/tags/React-Router/"/>
    
  </entry>
  
  <entry>
    <title>React Router V5 翻译文档8：Redux集成</title>
    <link href="http://yoursite.com/2019/12/15/React%20Router%20V5%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A38%EF%BC%9ARedux%E9%9B%86%E6%88%90/"/>
    <id>http://yoursite.com/2019/12/15/React Router V5 翻译文档8：Redux集成/</id>
    <published>2019-12-14T16:03:00.000Z</published>
    <updated>2019-12-15T06:33:47.802Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h5 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h5><p>原翻译作者：<a href="https://www.jianshu.com/u/5d660a479013" target="_blank" rel="noopener">https://www.jianshu.com/u/5d660a479013</a><br>原官网文档：<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">https://reacttraining.com/react-router/web/guides/quick-start</a></p></blockquote><h2 id="Redux集成"><a href="#Redux集成" class="headerlink" title="Redux集成"></a>Redux集成</h2><p>Redux是React生态系统的重要组成部分。我们希望将React Router和Redux尽可能地无缝集成以满足人们想要同时使用她们的需求。</p><h3 id="阻塞更新"><a href="#阻塞更新" class="headerlink" title="阻塞更新"></a>阻塞更新</h3><p>通常，React Router和Redux可以很好地协同工作。但有时，应用可能会发生有一个组件在位置更改时不会更新（子路由或点击导航链接不会更新）的情况。  </p><p>如果这种情况发生在以下场景：  </p><ol><li>该组件通过connect()(comp)连接到redux。</li><li>该组件不是“路由组件”，这意味着它不会像这样渲染：&lt; Route component = {SomeConnectedThing} /&gt;</li></ol><p>问题通常是Redux实现了本来应该由组件自动更新的部分，如果她没有从路由接收属性，则没有任何迹象表明组件应该发生改变。这很容易解决，找到连接组件的位置并将其封装在withRouter方法中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(Something)</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(connect(mapStateToProps)(Something))</span><br></pre></td></tr></table></figure></p><h3 id="深度集成"><a href="#深度集成" class="headerlink" title="深度集成"></a>深度集成</h3><p>一些人想要做到：</p><ol><li>从store中访问并同步数据。</li><li>能够通过调用actions进行导航跳转。</li><li>支持在Redux devtools中调试路由改变。  </li></ol><p>所有这些需要深度集成。  </p><p>我们的建议是更不不要将路由放在Redux store中。  </p><p>原因：  </p><ol><li>路由数据已经成为你的大部分组件所在意的属性。无论她是来自store还是router，你的组件代码都大致相同。</li><li>在大多数情况下，你可以使用Link，NavLink和Redirect来执行导航操作。有时你可能还需要在初始化操作启动某个异步任务之后以编程方式导航。<br>例如，你可以在用户提交登录表单时调度action。你的thunk，saga或其他异步操作需要验证身份，如果成功，她需要某种方式导航的新页面。解决方案是在action的payload中包含历史对象（提供给所有路由组件），并且在适当的时候你的异步操作可以使用这来进行导航跳转。</li><li>路由改变对于时间旅行式的调试不太重要。唯一需要关注的情况是调试route/store同步的问题，但如果你根本不同步这个问题就会消失。  </li></ol><p>但是如果你强烈想要将你的route与store同步，你可能想尝试 Connected React Router，一个绑定React Router v4和Redux的第三方类库。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h5 id=&quot;转载说明&quot;&gt;&lt;a href=&quot;#转载说明&quot; class=&quot;headerlink&quot; title=&quot;转载说明&quot;&gt;&lt;/a&gt;转载说明&lt;/h5&gt;&lt;p&gt;原翻译作者：&lt;a href=&quot;https://www.jianshu.com/u/5d660a47
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="React Router" scheme="http://yoursite.com/tags/React-Router/"/>
    
  </entry>
  
  <entry>
    <title>React Router V5 翻译文档9：静态路由</title>
    <link href="http://yoursite.com/2019/12/15/React%20Router%20V5%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A39%EF%BC%9A%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/"/>
    <id>http://yoursite.com/2019/12/15/React Router V5 翻译文档9：静态路由/</id>
    <published>2019-12-14T16:02:00.000Z</published>
    <updated>2019-12-15T06:33:47.802Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h5 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h5><p>原翻译作者：<a href="https://www.jianshu.com/u/5d660a479013" target="_blank" rel="noopener">https://www.jianshu.com/u/5d660a479013</a><br>原官网文档：<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">https://reacttraining.com/react-router/web/guides/quick-start</a></p></blockquote><h2 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h2><p>以前版本的React Router使用静态路由来配置应用的路由跳转。这允许在渲染之前检查和匹配路由。由于v4版本我们转移到动态路由组件而不是静态路由配置，一些以前的用例变得不那么明显和棘手。<br>我们现在正在开发一个包来处理静态路由配置和React路由，以继续满足这些用例。她现在正在开发中，但我们很乐意为你尝试并提供帮助。</p><p><a href="https://github.com/reacttraining/react-router/tree/master/packages/react-router-config" target="_blank" rel="noopener">React Router Config</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h5 id=&quot;转载说明&quot;&gt;&lt;a href=&quot;#转载说明&quot; class=&quot;headerlink&quot; title=&quot;转载说明&quot;&gt;&lt;/a&gt;转载说明&lt;/h5&gt;&lt;p&gt;原翻译作者：&lt;a href=&quot;https://www.jianshu.com/u/5d660a47
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="React Router" scheme="http://yoursite.com/tags/React-Router/"/>
    
  </entry>
  
  <entry>
    <title>React Router V5 翻译文档10：API</title>
    <link href="http://yoursite.com/2019/12/15/React%20Router%20V5%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A310%EF%BC%9AAPI/"/>
    <id>http://yoursite.com/2019/12/15/React Router V5 翻译文档10：API/</id>
    <published>2019-12-14T16:01:00.000Z</published>
    <updated>2019-12-15T06:33:47.802Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h5 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h5><p>原翻译作者：<a href="https://www.jianshu.com/u/5d660a479013" target="_blank" rel="noopener">https://www.jianshu.com/u/5d660a479013</a><br>原官网文档：<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">https://reacttraining.com/react-router/web/guides/quick-start</a></p></blockquote><p>这部分API文档翻译参考了项目<a href="https://github.com/react-translate-team/react-router-CN" target="_blank" rel="noopener">react-router-CN</a></p><h2 id="lt-BrowserRouter-gt"><a href="#lt-BrowserRouter-gt" class="headerlink" title="&lt; BrowserRouter &gt;"></a>&lt; BrowserRouter &gt;</h2><p><router> 使用HTML5提供的history API(pushState, replaceState和popstate事件)来同步UI和URL。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line">&lt;BrowserRouter</span><br><span class="line">  basename=&#123;optionalString&#125;</span><br><span class="line">  forceRefresh=&#123;optionalBool&#125;</span><br><span class="line">  getUserConfirmation=&#123;optionalFunc&#125;</span><br><span class="line">  keyLength=&#123;optionalNumber&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/BrowserRouter&gt;</span></span><br></pre></td></tr></table></figure></router></p><h3 id="basename-String"><a href="#basename-String" class="headerlink" title="basename: String"></a>basename: String</h3><p>当前位置的基准URL。如果你的页面部署在服务器的二级子目录，你需要将basename设置到此子目录。 正确的URL格式是前面有一个前导斜杠，但不能有尾部斜杠。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter basename=<span class="string">"/calendar"</span>/&gt;</span><br><span class="line">&lt;Link to=<span class="string">"/today"</span>/&gt; <span class="comment">// 渲染为 &lt;a href="/calendar/today"&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="getUserConfirmation-func"><a href="#getUserConfirmation-func" class="headerlink" title="getUserConfirmation: func"></a>getUserConfirmation: func</h3><p>当导航需要确认时执行的函数。默认使用window.confirm。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认的确认函数</span></span><br><span class="line"><span class="keyword">const</span> getConfirmation = <span class="function">(<span class="params">message, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> allowTransition = <span class="built_in">window</span>.confirm(message)</span><br><span class="line">  callback(allowTransition)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;BrowserRouter getUserConfirmation=&#123;getConfirmation&#125;/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="forceRefresh-bool"><a href="#forceRefresh-bool" class="headerlink" title="forceRefresh: bool"></a>forceRefresh: bool</h3><p>当设置为true时，在导航的过程中整个页面将会刷新。只有当浏览器不支持HTML5的 history API 时，才设置为true。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> supportsHistory = <span class="string">'pushState'</span> <span class="keyword">in</span> <span class="built_in">window</span>.history</span><br><span class="line">&lt;BrowserRouter forceRefresh=&#123;!supportsHistory&#125;/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="keyLength-number"><a href="#keyLength-number" class="headerlink" title="keyLength: number"></a>keyLength: number</h3><p>location.key的长度。默认是6。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter keyLength=&#123;<span class="number">12</span>&#125;/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="children-node"><a href="#children-node" class="headerlink" title="children: node"></a>children: node</h3><p>渲染单一子组件（元素）。</p><h2 id="lt-HashRouter-gt"><a href="#lt-HashRouter-gt" class="headerlink" title="&lt; HashRouter &gt;"></a>&lt; HashRouter &gt;</h2><p>HashRouter 是一种特定的 <router>， HashRouter 使用 URL 的 hash (例如：window.location.hash) 来同步UI和URL。  </router></p><p>注意：使用 hash 的方式记录导航历史不支持 location.key 和 location.state。在以前的版本中，我们为这种行为提供了 shim，但是仍有一些问题我们无法解决。任何依赖此行为的代码或插件都将无法正常使用。 由于该技术仅用于支持传统的浏览器，因此在用于浏览器时可以使用 <browserhistory> 代替。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; HashRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line">&lt;HashRouter&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/HashRouter&gt;</span></span><br></pre></td></tr></table></figure></browserhistory></p><h3 id="basename-string"><a href="#basename-string" class="headerlink" title="basename: string"></a>basename: string</h3><p>当前位置的基准 URL。正确的 URL 格式是前面有一个前导斜杠，但不能有尾部斜杠。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;HashRouter basename=<span class="string">"/calendar"</span>/&gt;</span><br><span class="line">&lt;Link to=<span class="string">"/today"</span>/&gt; <span class="comment">// renders &lt;a href="#/calendar/today"&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="getUserConfirmation-func-1"><a href="#getUserConfirmation-func-1" class="headerlink" title="getUserConfirmation: func"></a>getUserConfirmation: func</h3><p>当导航需要确认时执行的函数。默认使用 window.confirm。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认的确认函数</span></span><br><span class="line"><span class="keyword">const</span> getConfirmation = <span class="function">(<span class="params">message, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> allowTransition = <span class="built_in">window</span>.confirm(message)</span><br><span class="line">  callback(allowTransition)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;HashRouter getUserConfirmation=&#123;getConfirmation&#125;/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="hashType-string"><a href="#hashType-string" class="headerlink" title="hashType: string"></a>hashType: string</h3><p>window.location.hash 使用的 hash 类型。有如下几种：</p><ul><li>“slash” - 后面跟一个斜杠，例如 #/ 和 #/sunshine/lollipops</li><li>“noslash” - 后面没有斜杠，例如 # 和 #sunshine/lollipops</li><li>“hashbang” - Google 风格的 “ajax crawlable”，例如 #!/ 和 #!/sunshine/lollipops  </li></ul><p>默认为 “slash”。</p><h3 id="children-node-1"><a href="#children-node-1" class="headerlink" title="children: node"></a>children: node</h3><p>渲染单一子组件（元素）。</p><h2 id="lt-Link-gt"><a href="#lt-Link-gt" class="headerlink" title="&lt; Link &gt;"></a>&lt; Link &gt;</h2><p>为您的应用提供声明式的、无障碍导航。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line">&lt;Link to=<span class="string">"/about"</span>&gt;关于&lt;<span class="regexp">/Link&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="to-string"><a href="#to-string" class="headerlink" title="to: string"></a>to: string</h3><p>需要跳转到的路径(pathname)或地址（location）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">"/courses"</span>/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="to-object"><a href="#to-object" class="headerlink" title="to: object"></a>to: object</h3><p>需要跳转到的地址（location）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123;</span><br><span class="line">  pathname: <span class="string">'/courses'</span>,</span><br><span class="line">  search: <span class="string">'?sort=name'</span>,</span><br><span class="line">  hash: <span class="string">'#the-hash'</span>,</span><br><span class="line">  state: &#123; <span class="attr">fromDashboard</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="replace-bool"><a href="#replace-bool" class="headerlink" title="replace: bool"></a>replace: bool</h3><p>当设置为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址。<br>当设置为 false 时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。<br>默认为 false。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">"/courses"</span> replace /&gt;</span><br></pre></td></tr></table></figure></p><h2 id="lt-NavLink-gt"><a href="#lt-NavLink-gt" class="headerlink" title="&lt; NavLink &gt;"></a>&lt; NavLink &gt;</h2><p>&lt; NavLink &gt;是 &lt; Link &gt; 的一个特定版本, 会在匹配上当前 URL 的时候会给已经渲染的元素添加样式参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line">&lt;NavLink to=<span class="string">"/about"</span>&gt;About&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="activeClassName-string"><a href="#activeClassName-string" class="headerlink" title="activeClassName: string"></a>activeClassName: string</h3><p>当元素匹配上当前 URL 的时候, 这个类会被赋予给这个元素. 其默认值为 active, 这个值会被添加到 className 属性的后面(追加)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/faq"</span></span><br><span class="line">  activeClassName=<span class="string">"selected"</span></span><br><span class="line">&gt;FAQs&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="activeStyle-object"><a href="#activeStyle-object" class="headerlink" title="activeStyle: object"></a>activeStyle: object</h3><p>当元素被选中时, 为此元素添加样式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/faq"</span></span><br><span class="line">  activeStyle=&#123;&#123;</span><br><span class="line">    fontWeight: <span class="string">'bold'</span>,</span><br><span class="line">    color: <span class="string">'red'</span></span><br><span class="line">   &#125;&#125;</span><br><span class="line">&gt;FAQs&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="exact-bool"><a href="#exact-bool" class="headerlink" title="exact: bool"></a>exact: bool</h3><p>当值为 true 时, 只有当地址完全匹配 class 和 style 才会应用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  exact</span><br><span class="line">  to=<span class="string">"/profile"</span></span><br><span class="line">&gt;Profile&lt;<span class="regexp">/NavLink</span></span><br></pre></td></tr></table></figure></p><h3 id="strict-bool"><a href="#strict-bool" class="headerlink" title="strict: bool"></a>strict: bool</h3><p>当值为 true 时，在确定位置是否与当前 URL 匹配时，将考虑位置 pathname 后的斜线 有关详细信息，请参阅<a href="https://reacttraining.com/react-router/core/api/Route/strict-bool" target="_blank" rel="noopener">&lt; Route strict &gt;</a>文档。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  strict</span><br><span class="line">  to=<span class="string">"/events/"</span></span><br><span class="line">&gt;Events&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="isActive-func"><a href="#isActive-func" class="headerlink" title="isActive: func"></a>isActive: func</h3><p>添加用于确定链接是否活动的额外逻辑的功能。 如果您想要做的更多，请验证链接的路径名是否与当前URL的 pathname 匹配。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// only consider an event active if its event id is an odd number</span></span><br><span class="line"><span class="keyword">const</span> oddEvent = <span class="function">(<span class="params">match, location</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> eventID = <span class="built_in">parseInt</span>(match.params.eventID)</span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">isNaN</span>(eventID) &amp;&amp; eventID % <span class="number">2</span> === <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/events/123"</span></span><br><span class="line">  isActive=&#123;oddEvent&#125;</span><br><span class="line">&gt;Event <span class="number">123</span>&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="lt-Prompt-gt"><a href="#lt-Prompt-gt" class="headerlink" title="&lt; Prompt &gt;"></a>&lt; Prompt &gt;</h2><p>当用户离开当前页的时候做出提示. 当你的应用处在特定状态, 此状态不希望用户离开时(例如填写表格到一半), 你应该使用<prompt>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Prompt &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line">&lt;Prompt</span><br><span class="line">  when=&#123;formIsHalfFilledOut&#125;</span><br><span class="line">  message=<span class="string">"Are you sure you want to leave?"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></prompt></p><h3 id="message-string"><a href="#message-string" class="headerlink" title="message: string"></a>message: string</h3><p>当用户尝试导航离开时，提示用户的消息。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Prompt message=<span class="string">"Are you sure you want to leave?"</span> /&gt;</span><br></pre></td></tr></table></figure></p><h3 id="message-func"><a href="#message-func" class="headerlink" title="message: func"></a>message: func</h3><p>会与用户试图前往下一个地址（location） 和 action 一起被调用。<br>函返回一个字符串用作向用户提示，或者返回true用作允许过渡。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Prompt</span><br><span class="line">  message=&#123;location =&gt;</span><br><span class="line">    location.pathname.startsWith(<span class="string">"/app"</span>)</span><br><span class="line">      ? <span class="literal">true</span></span><br><span class="line">      : <span class="string">`Are you sure you want to go to <span class="subst">$&#123;location.pathname&#125;</span>?`</span></span><br><span class="line">  &#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="when-bool"><a href="#when-bool" class="headerlink" title="when: bool"></a>when: bool</h3><p>你可以随时渲染<prompt>，而不是有条件地在警戒后面渲染它。</prompt></p><ul><li>当when={true} 时，禁止导航</li><li>当when={false} 时，允许导航<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Prompt when=&#123;formIsHalfFilledOut&#125; message=<span class="string">"Are you sure?"</span> /&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="lt-MemoryRouter-gt"><a href="#lt-MemoryRouter-gt" class="headerlink" title="&lt; MemoryRouter &gt;"></a>&lt; MemoryRouter &gt;</h3><p>&lt; Router &gt; 能在内存保存你 “URL” 的历史纪录(并没有对地址栏读写). 在非浏览器或者测试环境比如React Native下很有用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; MemoryRouter &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line">&lt;MemoryRouter&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/MemoryRouter&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="initialEntries-array"><a href="#initialEntries-array" class="headerlink" title="initialEntries: array"></a>initialEntries: array</h3><p>在历史栈中的一个 location 数组. 这些可能会成为含有 { pathname, search, hash, state } 或一些简单的 URL 字符串的完整的地址对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;MemoryRouter</span><br><span class="line">  initialEntries=&#123;[ <span class="string">'/one'</span>, <span class="string">'/two'</span>, &#123; <span class="attr">pathname</span>: <span class="string">'/three'</span> &#125; ]&#125;</span><br><span class="line">  initialIndex=&#123;<span class="number">1</span>&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/MemoryRouter&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="initialIndex-number"><a href="#initialIndex-number" class="headerlink" title="initialIndex: number"></a>initialIndex: number</h3><p>initialEntries 数组中的初始化地址索引</p><h3 id="getUserConfirmation-func-2"><a href="#getUserConfirmation-func-2" class="headerlink" title="getUserConfirmation: func"></a>getUserConfirmation: func</h3><p>用于确认导航的函数. 当使用<memoryrouter>直接使用<prompt>时，你必须使用这个选项</prompt></memoryrouter></p><h3 id="keyLength-number-1"><a href="#keyLength-number-1" class="headerlink" title="keyLength: number"></a>keyLength: number</h3><p>location.key 的长度, 默认为 6<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MemoryRouter keyLength=&#123;<span class="number">12</span>&#125;/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="children-node-2"><a href="#children-node-2" class="headerlink" title="children: node"></a>children: node</h3><p>要呈现的 单个子元素。</p><h2 id="lt-Redirect-gt"><a href="#lt-Redirect-gt" class="headerlink" title="&lt; Redirect &gt;"></a>&lt; Redirect &gt;</h2><p>渲染<redirect> 的时候将会导航到一个新的地址（location）。这个新的地址（location）将会覆盖在访问历史记录里面的原地址，就像服务端的重定向（HTTP 3XX）一样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Route, Redirect &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line">&lt;Route exact path=<span class="string">"/"</span> render=&#123;() =&gt; (</span><br><span class="line">  loggedIn ? (</span><br><span class="line">    &lt;Redirect to=<span class="string">"/dashboard"</span>/&gt;</span><br><span class="line">  ) : (</span><br><span class="line">    &lt;PublicHomePage/&gt;</span><br><span class="line">  )</span><br><span class="line">)&#125;/&gt;</span><br></pre></td></tr></table></figure></redirect></p><h3 id="to-string-1"><a href="#to-string-1" class="headerlink" title="to: string"></a>to: string</h3><p>重定向目标URL。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=<span class="string">"/somewhere/else"</span>/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="to-object-1"><a href="#to-object-1" class="headerlink" title="to: object"></a>to: object</h3><p>重定向目标地址(location)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=&#123;&#123;</span><br><span class="line">  pathname: <span class="string">'/login'</span>,</span><br><span class="line">  search: <span class="string">'?utm=your+face'</span>,</span><br><span class="line">  state: &#123; <span class="attr">referrer</span>: currentLocation &#125;</span><br><span class="line">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="push-bool"><a href="#push-bool" class="headerlink" title="push: bool"></a>push: bool</h3><p>当设置为 true 时，重定向（redirecting）将会把新地址加入访问历史记录里面，而不是替换掉目前的地址<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect push to=<span class="string">"/somewhere/else"</span>/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="from-string"><a href="#from-string" class="headerlink" title="from: string"></a>from: string</h3><p>需要被重定向的路径（pathname）。当渲染一个包含在<switch>里面的<redirect>的时候，这可以用作匹配一个地址（location）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Redirect <span class="keyword">from</span>=<span class="string">'/old-path'</span> to=<span class="string">'/new-path'</span>/&gt;</span><br><span class="line">  &lt;Route path=<span class="string">'/new-path'</span> component=&#123;Place&#125;/&gt;</span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br></pre></td></tr></table></figure></redirect></switch></p><h2 id="lt-Route-gt"><a href="#lt-Route-gt" class="headerlink" title="&lt; Route &gt;"></a>&lt; Route &gt;</h2><p>想要理解并使用好React Router，最重要的可能就是Route组件了。Route组件主要的作用就是当一个location匹配路由的path时，渲染某些UI。<br>考虑这样的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/news"</span> component=&#123;NewsFeed&#125;/&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Router&gt;</span><br></pre></td></tr></table></figure></p><p>如果应用的地址是/,那么相应的UI会类似这个样子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Home/&gt;</span><br><span class="line">  &lt;!-- react-empty: <span class="number">2</span> --&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果应用的地址是/news,那么相应的UI就会成为这个样子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;!-- react-empty: <span class="number">1</span> --&gt;</span><br><span class="line">  &lt;NewsFeed/&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里的react-empty注释只是演示了React渲染null的细节，但对我们具有启发性。其实Route就算是null也会被渲染，只要地址与路由的路径匹配，组件就会渲染。</p><h3 id="Route渲染方法"><a href="#Route渲染方法" class="headerlink" title="Route渲染方法"></a>Route渲染方法</h3><p>这三种渲染方法都会获得相同的三个的属性：</p><ul><li>match</li><li>location</li><li>history</li></ul><h3 id="component"><a href="#component" class="headerlink" title="component"></a>component</h3><p>只有在地址匹配的时候React的组件才会被渲染，route props也会随着一起被渲染。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"/user/:username"</span> component=&#123;User&#125;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = <span class="function">(<span class="params">&#123; match &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;match.params.username&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你使用component(而不是像下面这样使用render),路由会根据指定的组件使用React.createElement来创建一个新的React element。这就意味着如果你提供的是一个内联的函数的话会带来很多意料之外的重新挂载。所以，对于内联渲染，要使用render属性(如下所示)。</p><h3 id="render-func"><a href="#render-func" class="headerlink" title="render: func"></a>render: func</h3><p>这种方式对于内联渲染和包装组件却不引起意料之外的重新挂载特别方便。<br>使用render属性，你可以选择传一个在地址匹配时被调用的函数，而不是像使用component属性那样得到一个新创建的React element。使用render属性会获得跟使用component属性一样的route props。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 便捷的行内渲染</span></span><br><span class="line">&lt;Route path=<span class="string">"/home"</span> render=&#123;() =&gt; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装/合成</span></span><br><span class="line"><span class="keyword">const</span> FadingRoute = <span class="function">(<span class="params">&#123; component: Component, ...rest &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;Route &#123;...rest&#125; render=&#123;props =&gt; (</span><br><span class="line">    &lt;FadeIn&gt;</span><br><span class="line">      &lt;Component &#123;...props&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/FadeIn&gt;</span></span><br><span class="line"><span class="regexp">  )&#125;/</span>&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&lt;FadingRoute path=<span class="string">"/cool"</span> component=&#123;Something&#125;/&gt;</span><br></pre></td></tr></table></figure></p><p>警告: &lt; Route component &gt;的优先级要比&lt; Route render &gt;高，所以不要在同一个 <route>中同时使用这两个属性。</route></p><h3 id="children-func"><a href="#children-func" class="headerlink" title="children: func"></a>children: func</h3><p>有时候你可能想不管地址是否匹配都渲染一些内容，这种情况你可以使用children属性。它与render属性的工作方式基本一样，除了它是不管地址匹配与否都会被调用。<br>除了在路径不匹配URL时match的值为null之外，children渲染属性会获得与component和render一样的route props。这就允许你根据是否匹配路由来动态地调整UI了，来看这个例子，如果理由匹配的话就添加一个active类：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;ListItemLink to=<span class="string">"/somewhere"</span>/&gt;</span><br><span class="line">  &lt;ListItemLink to=<span class="string">"/somewhere-else"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const ListItemLink = (&#123; to, ...rest &#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;Route path=&#123;to&#125; children=&#123;(&#123; match &#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">    &lt;li className=&#123;match ? 'active' : ''&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Link to=&#123;to&#125; &#123;...rest&#125;/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  )&#125;/</span>&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>这种属性对于动画也特别有用:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route children=&#123;(&#123; match, ...rest &#125;) =&gt; (</span><br><span class="line">  &#123;<span class="comment">/* Animate总会被渲染, 所以你可以使用生命周期来使它的子组件出现</span></span><br><span class="line"><span class="comment">    或者隐藏</span></span><br><span class="line"><span class="comment">  */</span>&#125;</span><br><span class="line">  &lt;Animate&gt;</span><br><span class="line">    &#123;match &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Something</span> &#123;<span class="attr">...rest</span>&#125;/&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Animate</span>&gt;</span></span></span><br><span class="line">)&#125;/&gt;</span><br></pre></td></tr></table></figure></p><p>警告: &lt; Route component &gt;和&lt; Route render &gt; 的优先级都比&lt; Route children &gt; 高，所以在同一个<route>中不要同时使用一个以上的属性.</route></p><h3 id="path-string"><a href="#path-string" class="headerlink" title="path: string"></a>path: string</h3><p>可以是任何path-to-regexp能理解的有效URL。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"/users/:id"</span> component=&#123;User&#125;/&gt;</span><br></pre></td></tr></table></figure></p><p>没有path属性的Route 总是会 匹配。</p><h3 id="exact-bool-1"><a href="#exact-bool-1" class="headerlink" title="exact: bool"></a>exact: bool</h3><p>当值为true时，则要求路径与location.pathname必须 完全 匹配。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route exact path=<span class="string">"/one"</span> component=&#123;About&#125;/&gt;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:center">路径</th><th style="text-align:center">location.pathname</th><th style="text-align:center">exact</th><th style="text-align:center">是否匹配?</th></tr></thead><tbody><tr><td style="text-align:center">/one</td><td style="text-align:center">/one/two</td><td style="text-align:center">true</td><td style="text-align:center">否</td><td></td></tr><tr><td style="text-align:center">/one</td><td style="text-align:center">/one/two</td><td style="text-align:center">false</td><td style="text-align:center">是</td><td></td></tr></tbody></table><h3 id="strict-bool-1"><a href="#strict-bool-1" class="headerlink" title="strict: bool"></a>strict: bool</h3><p>当设为true的时候，有结尾斜线的路径只能匹配有斜线的location.pathname，这个值并不会对location.pathname中有其他的片段有影响。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route strict path=<span class="string">"/one/"</span> component=&#123;About&#125;/&gt;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:center">路径</th><th style="text-align:center">location.pathname</th><th style="text-align:center">是否匹配?</th></tr></thead><tbody><tr><td style="text-align:center">/one/</td><td style="text-align:center">/one</td><td style="text-align:center">否</td><td></td></tr><tr><td style="text-align:center">/one/</td><td style="text-align:center">/one/</td><td style="text-align:center">是</td><td></td></tr><tr><td style="text-align:center">/one/</td><td style="text-align:center">/one/two</td><td style="text-align:center">是</td><td></td></tr></tbody></table><p>警告: stict可以强制location.pathname不包含结尾的斜线，但是要做到这点必须把strict和exect都设置为true。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route exact strict path=<span class="string">"/one"</span> component=&#123;About&#125;/&gt;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:center">路径</th><th style="text-align:center">location.pathname</th><th style="text-align:center">是否匹配?</th></tr></thead><tbody><tr><td style="text-align:center">/one</td><td style="text-align:center">/one</td><td style="text-align:center">是</td><td></td></tr><tr><td style="text-align:center">/one</td><td style="text-align:center">/one/</td><td style="text-align:center">否</td><td></td></tr><tr><td style="text-align:center">/one</td><td style="text-align:center">/one/two</td><td style="text-align:center">否</td><td></td></tr></tbody></table><h3 id="location-object"><a href="#location-object" class="headerlink" title="location: object"></a>location: object</h3><p>&lt; Route &gt;元素尝试将路径path当前history location（通常是当前浏览器URL）进行匹配。 除此之外，具有不同pathname的location也可以被传统用来匹配。  </p><p>当你需要将&lt; Route &gt;匹配到当前history location以外的location时，这非常有用，如动画过渡示例中所示。  </p><p>如果&lt; Route &gt;包含在&lt; Switch &gt;中并匹配了传递给<switch>的location（或当前history location），那么传递给&lt; Route &gt;的location属性将会被&lt; Switch &gt;使用的所覆盖。</switch></p><h3 id="sensitive-bool"><a href="#sensitive-bool" class="headerlink" title="sensitive: bool"></a>sensitive: bool</h3><p>如果该属性为true,则在匹配时区分大小写<br>path|    location.pathname|    sensitive|    是否匹配?|<br>:-:|:-:|:-:|:-:|<br>/one|/one|    true|    yes|<br>/One|    /one|    true|    no|<br>/One|    /one| false| yes|</p><h2 id="lt-Router-gt"><a href="#lt-Router-gt" class="headerlink" title="&lt; Router &gt;"></a>&lt; Router &gt;</h2><p>Router是所有路由组件共用的底层接口，一般我们的应用并不会使用这个接口，而是使用高级的路由：</p><ul><li>&lt; BrowserRouter &gt;</li><li>&lt; HashRouter &gt;</li><li>&lt; MemoryRouter &gt;</li><li>&lt; NativeRouter &gt;</li><li>&lt; StaticRouter &gt;</li></ul><p>最常见的使用底层的&lt; Router &gt;的情形就是用来与Redux或者Mobx之类的状态管理库的定制的history保持同步。注意不是说使用状态管理库就必须使用&lt; Router &gt;，它仅用作于深度集成。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"><span class="keyword">import</span> createBrowserHistory <span class="keyword">from</span> <span class="string">'history/createBrowserHistory'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> history = createBrowserHistory()</span><br><span class="line"></span><br><span class="line">&lt;Router history=&#123;history&#125;&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/Router&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="history-object"><a href="#history-object" class="headerlink" title="history: object"></a>history: object</h3><p>用来导航的history对象.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> createBrowserHistory <span class="keyword">from</span> <span class="string">'history/createBrowserHistory'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> customHistory = createBrowserHistory()</span><br><span class="line">&lt;Router history=&#123;customHistory&#125;/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="children-node-3"><a href="#children-node-3" class="headerlink" title="children: node"></a>children: node</h3><p>需要渲染的单一组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/Router&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="lt-StaticRouter-gt"><a href="#lt-StaticRouter-gt" class="headerlink" title="&lt; StaticRouter &gt;"></a>&lt; StaticRouter &gt;</h2><p>&lt; Router &gt; 从不会改变地址<br>当用户实际上没有点击时, 这在服务端的渲染场景中可能会非常有用, 所以这个地址从来没有改变. 因此, 称为: static (静态). 当您只需要插入一个位置并在渲染输出上作出断言时，它也可用于简单的测试 这里有一个简单 nodejs 服务 : 为&lt; Redirect &gt;和其他请求的常规HTML发送302状态代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">'react-dom/server'</span></span><br><span class="line"><span class="keyword">import</span> &#123; StaticRouter &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line">createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This context object contains the results of the render</span></span><br><span class="line">  <span class="keyword">const</span> context = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString(</span><br><span class="line">    &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt;</span><br><span class="line">      &lt;App/&gt;</span><br><span class="line">    &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ context.url will contain the URL to redirect to if a &lt;Redirect&gt; was used</span></span><br><span class="line"><span class="regexp">  if (context.url) &#123;</span></span><br><span class="line"><span class="regexp">    res.writeHead(302, &#123;</span></span><br><span class="line"><span class="regexp">      Location: context.url</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">    res.end()</span></span><br><span class="line"><span class="regexp">  &#125; else &#123;</span></span><br><span class="line"><span class="regexp">    res.write(html)</span></span><br><span class="line"><span class="regexp">    res.end()</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;).listen(3000)</span></span><br></pre></td></tr></table></figure></p><h3 id="basename-string-1"><a href="#basename-string-1" class="headerlink" title="basename: string"></a>basename: string</h3><p>所有地址的基本 URL . 正确格式化的基本名称应该有一个主要的斜杠，但没有尾部斜杠<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;StaticRouter basename=<span class="string">"/calendar"</span>&gt;</span><br><span class="line">  &lt;Link to=<span class="string">"/today"</span>/&gt; <span class="comment">// renders &lt;a href="/calendar/today"&gt;</span></span><br><span class="line">&lt;<span class="regexp">/StaticRouter&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="location-string"><a href="#location-string" class="headerlink" title="location: string"></a>location: string</h3><p>服务器收到的 URL, 在 node 服务上可能是 req.url<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;StaticRouter location=&#123;req.url&#125;&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/StaticRouter&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="location-object-1"><a href="#location-object-1" class="headerlink" title="location: object"></a>location: object</h3><p>一个格式像 { pathname, search, hash, state } 的地址对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;StaticRouter location=&#123;&#123; <span class="attr">pathname</span>: <span class="string">'/bubblegum'</span> &#125;&#125;&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/StaticRouter&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="context-object"><a href="#context-object" class="headerlink" title="context: object"></a>context: object</h3><p>记录渲染结果的纯JavaScript对象。 见上面的例子</p><h3 id="children-node-4"><a href="#children-node-4" class="headerlink" title="children: node"></a>children: node</h3><p>要呈现的单个子元素。</p><h2 id="lt-Switch-gt"><a href="#lt-Switch-gt" class="headerlink" title="&lt; Switch &gt;"></a>&lt; Switch &gt;</h2><p>渲染匹配地址(location)的第一个 &lt; Route &gt; 或者 &lt; Redirect &gt;<br>这与只使用一堆&lt; Route &gt;有什么不同？<br>&lt; Switch &gt;的独特之处是独它仅仅渲染一个路由。相反地，每一个包含匹配地址(location)的&lt; Route &gt;都会被渲染。思考下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;Route path=<span class="string">"/:user"</span> component=&#123;User&#125;/&gt;</span><br><span class="line">&lt;Route component=&#123;NoMatch&#125;/&gt;</span><br></pre></td></tr></table></figure></p><p>如果现在的URL是 /about ，那么 &lt; About &gt;, &lt; User &gt;, 还有 &lt; NoMatch &gt; 都会被渲染，因为它们都与路径(path)匹配。这种设计，允许我们以多种方式将多个 &lt; Route &gt; 组合到我们的应用程序中，例如侧栏(sidebars)，面包屑(breadcrumbs)，bootstrap tabs等等。 然而，偶尔我们只想选择一个&lt; Route &gt; 来渲染。如果我们现在处于 /about ，我们也不希望匹配 /:user （或者显示我们的 “404” 页面 ）。以下是使用 Switch 的方法来实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125;/&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/:user"</span> component=&#123;User&#125;/&gt;</span><br><span class="line">  &lt;Route component=&#123;NoMatch&#125;/&gt;</span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br></pre></td></tr></table></figure></p><p>现在，如果我们处于 /about, <switch> 将开始寻找匹配的 <route>。 <route path="/about"> 将被匹配， <switch> 将停止寻找匹配并渲染<about>。 同样，如果我们处于 /michael ， <user> 将被渲染。  </user></about></switch></route></route></switch></p><p>这对于过渡动画也是起作用的，因为匹配的 <route> 在与前一个相同的位置被渲染。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;Fade&gt;</span><br><span class="line">  &lt;Switch&gt;</span><br><span class="line">    &#123;<span class="comment">/* there will only ever be one child here */</span>&#125;</span><br><span class="line">    &#123;<span class="comment">/* 这里只会有一个子节点 */</span>&#125;</span><br><span class="line">    &lt;Route/&gt;</span><br><span class="line">    &lt;Route/&gt;</span><br><span class="line">  &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Fade&gt;</span><br><span class="line"></span><br><span class="line">&lt;Fade&gt;</span><br><span class="line">  &lt;Route/&gt;</span><br><span class="line">  &lt;Route/&gt;</span><br><span class="line">  &#123;<span class="comment">/* there will always be two children here,</span></span><br><span class="line"><span class="comment">      one might render null though, making transitions</span></span><br><span class="line"><span class="comment">      a bit more cumbersome to work out */</span>&#125;</span><br><span class="line">   &#123;<span class="comment">/* 这里总是有两个子节点,</span></span><br><span class="line"><span class="comment">      一个可能会渲染为null, 使计算过渡增加了一点麻烦 */</span>&#125;    </span><br><span class="line">&lt;<span class="regexp">/Fade&gt;</span></span><br></pre></td></tr></table></figure></route></p><h3 id="children-node-5"><a href="#children-node-5" class="headerlink" title="children: node"></a>children: node</h3><p>&lt; Switch &gt; 的所有子节点应为 &lt; Route &gt; 或 &lt; Redirect &gt; 元素。只有匹配当前地址(location)的第一个子节点才会被渲染。&lt; Route &gt; 元素使用它们的 path 属性匹配，&lt; Redirect &gt; 元素使用它们的 from 属性匹配。没有 path 属性的&lt; Route &gt; 或者 没有 from 属性的 &lt; Redirect &gt; 将总是可以匹配当前的地址(location)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Route path=<span class="string">"/users"</span> component=&#123;Users&#125;/&gt;</span><br><span class="line">  &lt;Redirect <span class="keyword">from</span>=<span class="string">"/accounts"</span> to=<span class="string">"/users"</span>/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Route component=&#123;NoMatch&#125;/&gt;</span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>本文档中的「history」以及「history对象」请参照 history 包中的内容。 History 是 React Router 的两大重要依赖之一（除去 React 本身），在不同的 Javascript 环境中，history 以多种形式实现了对于 session 历史的管理。<br>我们会经常使用以下术语：</p><ul><li>「browser history」 - history 在 DOM 上的实现，经常使用于支持 HTML5 history API 的浏览器端。</li><li>「hash history」 - history 在 DOM 上的实现，经常使用于旧版本浏览器端。</li><li><p>「memory history」 - 一种存储于内存的 history 实现，经常用于测试或是非 DOM 环境（例如 React Native）。</p><p>history 对象通常会具有以下属性和方法：</p></li><li>length -（ number 类型）指的是 history 堆栈的数量。</li><li>action -（ string 类型）指的是当前的动作（action），例如 PUSH，REPLACE 以及 POP 。</li><li>location -（ object类型）是指当前的位置（location），location 会具有如下属性：<ul><li>pathname -（ string 类型）URL路径。</li><li>search -（ string 类型）URL中的查询字符串（query string）。</li><li>hash -（ string 类型）URL的 hash 分段。</li><li>state -（ string 类型）是指 location 中的状态，例如在 push(path, state) 时，state会描述什么时候 location 被放置到堆栈中等信息。这个 state 只会出现在 browser history 和 memory history 的环境里。</li></ul></li><li>push(path, [state]) -（ function 类型）在 hisotry 堆栈顶加入一个新的条目。</li><li>replace(path, [state]) -（ function 类型）替换在 history 堆栈中的当前条目。</li><li>go(n) -（ function 类型）将 history 对战中的指针向前移动 n 。</li><li>goBack() -（ function 类型）等同于 go(-1) 。</li><li>goForward() -（ function 类型）等同于 go(1) 。</li><li>block(prompt) -（ function 类型）阻止跳转，（请参照 history 文档）。<h3 id="history-是可变的（mutable）"><a href="#history-是可变的（mutable）" class="headerlink" title="history 是可变的（mutable）"></a>history 是可变的（mutable）</h3>history 对象是可变的，因此我们建议从 <route> 的 prop里来获取 location ，而不是从 history.location 直接获取。这样做可以保证 React 在生命周期中的钩子函数正常执行，例如以下代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="comment">// locationChanged 变量为 true</span></span><br><span class="line">    <span class="keyword">const</span> locationChanged = nextProps.location !== <span class="keyword">this</span>.props.location</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不正确，locationChanged 变量会 *永远* 为 false ，因为 history 是可变的（mutable）。</span></span><br><span class="line">    <span class="keyword">const</span> locationChanged = nextProps.history.location !== <span class="keyword">this</span>.props.history.location</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Route component=&#123;Comp&#125;/&gt;</span><br></pre></td></tr></table></figure></route></li></ul><p>不同的实现也许会提供给你额外的属性，更多详情请参照 <a href="https://github.com/ReactTraining/history#properties" target="_blank" rel="noopener">history 文档</a>。</p><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>Location 是指你当前的位置，下一步打算去的位置，或是你之前所在的位置，形式大概就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  key: <span class="string">'ac3df4'</span>, <span class="comment">// 在使用 hashHistory 时，没有 key</span></span><br><span class="line">  pathname: <span class="string">'/somewhere'</span></span><br><span class="line">  search: <span class="string">'?some=search-string'</span>,</span><br><span class="line">  hash: <span class="string">'#howdy'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    [userDefined]: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你使用以下几种方式来获取 location 对象：</p><ul><li>在 Route component 中，以 this.props.location 的方式获取，</li><li>在 Route render 中，以 ({ location }) =&gt; () 的方式获取，</li><li>在 Route children 中，以 ({ location }) =&gt; () 的方式获取，</li><li>在 withRouter 中，以 this.props.location 的方式获取。</li></ul><p>你也可以在 history.location 中获取 location 对象，但是别那么写，因为 history 是可变的。更多信息请参见 <a href="https://github.com/ReactTraining/history#properties" target="_blank" rel="noopener">history 文档</a>。  </p><p>location 对象不会发生改变，因此你可以在生命周期的钩子函数中使用 location 对象来查看当前页面的位置是否发生改变，这种技巧在获取远程数据以及使用动画时非常有用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象来查看当前页面的位置是否发生改变，这种技巧在获取远程数据以及使用动画时非常有用。componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.location !== <span class="keyword">this</span>.props.location) &#123;</span><br><span class="line">    <span class="comment">// 已经跳转了！</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以在不同环境中使用 location ：</p><ul><li>Web Link to</li><li>Native Link to</li><li>Redirect to</li><li>history.push</li><li>history.replace<br>通常情况下，你只需要给一个字符串当做 location ，但是，当你需要添加一些 location 的状态时，你可以对象的形式使用 location 。并且当你需要多个 UI ，而这些 UI 取决于历史时，例如弹出框（modal），使用location 对象会有很大帮助。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/ 通常你只需要这样使用 location</span><br><span class="line">&lt;Link to=<span class="string">"/somewhere"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是你同样可以这么用js</span></span><br><span class="line"><span class="keyword">const</span> location = &#123;</span><br><span class="line">  pathname: <span class="string">'/somewhere'</span></span><br><span class="line">  state: &#123; <span class="attr">fromDashboard</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Link to=&#123;location&#125;/&gt;</span><br><span class="line">&lt;Redirect to=&#123;location&#125;/&gt;</span><br><span class="line">history.push(location)</span><br><span class="line">history.replace(location)</span><br></pre></td></tr></table></figure></li></ul><p>最后，你可以把 location 传入一下组件：</p><ul><li>Route</li><li>Switch<br>这样做可以让组件不使用路由状态（router state）中的真实 location，因为我们有时候需要组件去渲染一个其他的 location 而不是本身所处的真实 location，比如使用动画或是等待跳转时。<h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2>match 对象包含了 <route path> 如何与URL匹配的信息。match 对象包含以下属性：</route></li><li>params -（ object 类型）即路径参数，通过解析URL中动态的部分获得的键值对。</li><li>isExact - 当为 true 时，整个URL都需要匹配。</li><li>path -（ string 类型）用来做匹配的路径格式。在需要嵌套 <route> 的时候用到。</route></li><li>url -（ string 类型）URL匹配的部分，在需要嵌套 <link> 的时候会用到。<br>你可以在以下地方获取 match 对象：</li><li>在 Route component 中，以 this.props.match 方式。</li><li>在 Route render 中，以 ({ match }) =&gt; () 方式。</li><li>在 Route children 中，以 ({ match }) =&gt; () 方式</li><li>在 withRouter 中，以 this.props.match 方式</li><li>matchPath 的返回值<br>当一个 Route 没有 path 时，它会匹配一切路径，你会匹配到最近的父级。在 withRouter 里也是一样的。</li></ul><h3 id="null-matches"><a href="#null-matches" class="headerlink" title="null matches"></a>null matches</h3><p>即使路径的路径与当前位置不匹配，&lt; Route &gt;也可以使用子属性来调用其子功能。 但在这种情况下，匹配将为null。 能够在匹配时渲染&lt; Route &gt;的内容可能是有用的，但是这种情况会产生一些挑战。</p><p>“解析”URL的默认方法是将match.url字符串拼接到“相对”路径。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`<span class="subst">$&#123;match.url&#125;</span>/relative-path`</span></span><br></pre></td></tr></table></figure></p><p>如果在匹配为空时尝试执行此操作，最终会出现TypeError。 这意味着在使用子属性尝试连接&lt; Route &gt;内的“relative”路径是不安全的。</p><p>当你在生成空匹配对象的&lt; Route &gt;中使用没有path的&lt; Route &gt;时，会出现类似但更微妙的情况。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// location.pathname = '/matches'</span></span><br><span class="line">&lt;Route path=<span class="string">'/does-not-match'</span> children=&#123;(&#123; match &#125;) =&gt; (</span><br><span class="line">  <span class="comment">// match === null</span></span><br><span class="line">  &lt;Route render=&#123;(&#123; <span class="attr">match</span>:pathlessMatch &#125;) =&gt; (</span><br><span class="line">    <span class="comment">// pathlessMatch === ???</span></span><br><span class="line">  )&#125;/&gt;</span><br><span class="line">)&#125;/&gt;</span><br></pre></td></tr></table></figure></p><p>没有path属性的&lt; Route &gt;从其父级继承匹配对象。 如果她们的父匹配为null，那么她们的匹配也将为null。 这意味着<br>a）任何子路由/链接必须是绝对路径，因为没有要解析的父级<br>b）父级匹配可以为null的无路径路由将需要使用子属性来渲染。</p><h2 id="matchPath"><a href="#matchPath" class="headerlink" title="matchPath"></a>matchPath</h2><p>这允许您使用与一样使用的相同的代码，除了在正常渲染循环之外，例如在服务器上渲染之前收集数据依赖关系<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; matchPath &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> match = matchPath(<span class="string">'/users/123'</span>, &#123;</span><br><span class="line">  path: <span class="string">'/users/:id'</span></span><br><span class="line">  exact: <span class="literal">true</span>,</span><br><span class="line">  strict: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="pathname"><a href="#pathname" class="headerlink" title="pathname"></a>pathname</h3><p>第一参数是你想要匹配的 pathname, 如果你正在服务端的 nodos.js 下使用, 将会是 req.url</p><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>第二个参数是不予匹配的属性, 他们于匹配 Route 接收的参数属性是相同的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path, <span class="comment">// like /users/:id</span></span><br><span class="line">  strict, <span class="comment">// 可选, 默认 false</span></span><br><span class="line">  exact <span class="comment">// 可选, 默认 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h2><p>你可以通过withRouter的高阶组件访问history对象的属性和最相似的&lt; Route &gt;的匹配。 每次路由更改时，无论如何是如何渲染的，withRouter将会给封装的组件传递更新的match,location 和 history属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mport React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">"react-router"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A simple component that shows the pathname of the current location</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowTheLocation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    match: PropTypes.object.isRequired,</span><br><span class="line">    location: PropTypes.object.isRequired,</span><br><span class="line">    history: PropTypes.object.isRequired</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; match, location, history &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>You are now at &#123;location.pathname&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new component that is "connected" (to borrow redux</span></span><br><span class="line"><span class="comment">// terminology) to the router.</span></span><br><span class="line"><span class="keyword">const</span> ShowTheLocationWithRouter = withRouter(ShowTheLocation);</span><br></pre></td></tr></table></figure></p><h3 id="重要提醒"><a href="#重要提醒" class="headerlink" title="重要提醒"></a>重要提醒</h3><p>withRouter不追踪location的更改，而是在从&lt; Router &gt;组件传播出去的location改变后重新渲染，这意味着withRouter不会在路由改变时重新渲染，除非她的父组件重新渲染。  </p><p>静态方法和属性。</p><p>封装的组件的所有非React的静态方法和属性都会被自动的复制到已连接的组件。</p><h3 id="Component-WrappedComponent"><a href="#Component-WrappedComponent" class="headerlink" title="Component.WrappedComponent"></a>Component.WrappedComponent</h3><p>封装的组件作为返回组件上的静态属性WrappedComponent暴露，这个组件可以用于测试。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyComponent.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(MyComponent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyComponent.test.js</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./MyComponent'</span></span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent.WrappedComponent</span> <span class="attr">location</span>=<span class="string">&#123;&#123;...&#125;&#125;</span> <span class="attr">...</span> /&gt;</span>)</span></span><br></pre></td></tr></table></figure></p><h3 id="wrappedComponentRef-func"><a href="#wrappedComponentRef-func" class="headerlink" title="wrappedComponentRef: func"></a>wrappedComponentRef: func</h3><p>作为引用的属性被传递给封装的组件的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Container extends React.Component &#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.component.doSomething();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;MyComponent wrappedComponentRef=&#123;c =&gt; (this.component = c)&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h5 id=&quot;转载说明&quot;&gt;&lt;a href=&quot;#转载说明&quot; class=&quot;headerlink&quot; title=&quot;转载说明&quot;&gt;&lt;/a&gt;转载说明&lt;/h5&gt;&lt;p&gt;原翻译作者：&lt;a href=&quot;https://www.jianshu.com/u/5d660a47
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="React Router" scheme="http://yoursite.com/tags/React-Router/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门学习笔记15 —— Webpack中的三个小插件</title>
    <link href="http://yoursite.com/2019/08/11/webpack%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015%20%E2%80%94%E2%80%94%20Webpack%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B0%8F%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/08/11/webpack入门学习笔记15 —— Webpack中的三个小插件/</id>
    <published>2019-08-10T16:00:00.000Z</published>
    <updated>2019-12-15T05:25:44.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><p>在前面的博客中我们说过，webpack之所以有这么强大的功能，是因为它借助了很多 <strong>loader</strong> 和 <strong>插件</strong> 的帮助。在之前webpack配置中，我们已经介绍了很多 <strong>loader</strong> 和 <strong>插件</strong> ，在这里再介绍三种小插件，可以帮助我们更好地使用webpack构建项目。</p><p>这三款插件分别是：CleanWebpackPlugin、CopyWebpackPlugin、BannerPlugin(webpack内置插件)。下面一一对这些插件进行介绍。</p><h2 id="2-CleanWebpackPlugin"><a href="#2-CleanWebpackPlugin" class="headerlink" title="2. CleanWebpackPlugin"></a>2. CleanWebpackPlugin</h2><p>该插件的作用是：每次进行 <strong>build</strong> 的时候，将之前的dist目录下的代码清除，然后再打包生成新的代码文件。</p><p>当我们在使用 <strong>build</strong> 命令进行打包编译项目的时候，webpack会根据配置信息，将打包编译好的项目输出到一个文件夹中(<strong>默认文件夹是dist</strong>) 。在项目的开发过程中，我们肯定会多次执行 <strong>build</strong> 命令，这个时候我们希望每次执行 <strong>build</strong> 命令的时候，都可以将之前打包生成的代码文件删除，然后生成最新的代码文件。</p><p>但是实际情况却是之前的代码不会删除，比如：第一次打包编译项目，生成了a.js文件，第二次打包编译项目，生成了b.js文件。这个时候，a.js文件使用不到的，但该文件还是会存在dist文件夹下，这是我们不愿意看到的。</p><p>这里我们可以借助CleanWebpackPlugin插件进行删除之前的文件，首先执行以下命令进行安装插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add clean-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>安装完成之后，在 <strong>webpack.config.js</strong> 文件中书写以下代码进行配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">/* 节省篇幅，其余配置已省略 */</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin([</span><br><span class="line">            <span class="string">'./dist'</span><span class="comment">// 指定你要清楚文件的目录，可以传入多个目录参数</span></span><br><span class="line">        ])</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 <strong><a href="https://github.com/Fengzhen8023/webpack-learning" target="_blank" rel="noopener">GitHub仓库 - webpack-learning</a></strong> ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。</p><h2 id="3-CopyWebpackPlugin"><a href="#3-CopyWebpackPlugin" class="headerlink" title="3.CopyWebpackPlugin"></a>3.CopyWebpackPlugin</h2><p>该插件的作用是：在每次进行 <strong>build</strong> 的时候，将某些静态资源复制到特定文件夹下。</p><p>比如将一些特定的Excel文件，拷贝到<strong>dist</strong> 目录下，可以借助这款插件的帮助。使用这款插件，首先要执行以下命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add copy-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>配置代码也是非常简单，直接在 <strong>webpack.config.js</strong> 文件中书写以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">modules.export = &#123;</span><br><span class="line">    <span class="comment">/* 节省篇幅，其余配置已省略 */</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">            <span class="comment">// 参数是数组，可以对多个位置的文件进行copy </span></span><br><span class="line">            &#123; <span class="attr">from</span>: <span class="string">'./doc'</span>, <span class="attr">to</span>: <span class="string">'./dist'</span> &#125;</span><br><span class="line">        ])</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明的是，这里的 <strong>from</strong> 和 <strong>to</strong> 属性根据自己的实际情况进行配置。</p><h2 id="4-BannerPlugin-webpack内置插件"><a href="#4-BannerPlugin-webpack内置插件" class="headerlink" title="4. BannerPlugin(webpack内置插件)"></a>4. BannerPlugin(webpack内置插件)</h2><p>这是一款webpack的内置插件，作用是：代码版权声明插件，在编译好的 <strong>.js</strong> 文件的头部插入我们指定的版权声明文字，起到版权声明的作用。</p><p>既然是webpack内置插件，所以我们不用额外进行安装，可以直接进行在 <strong>webpack.config.js</strong> 文件中进行配置，示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> webpack = <span class="built_in">require</span>(<span class="string">'wepack'</span>);</span><br><span class="line"></span><br><span class="line">modules.export = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 参数是你要一个字符串，值是你要添加的版权声明信息</span></span><br><span class="line">        <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">'Made by Allen Feng'</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成之后，再次进行打包编译项目，就可以在生成的 <strong>.js</strong> 文件中看到我们的版权信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*! Made by Allen Feng */</span>!<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> n=&#123;&#125;;<span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">r</span>)</span>&#123;<span class="keyword">if</span>(n[r])<span class="keyword">return</span> n[r]......</span><br></pre></td></tr></table></figure><h2 id="5-写在最后"><a href="#5-写在最后" class="headerlink" title="5. 写在最后"></a>5. 写在最后</h2><p>以上便是这三款小插件，可以帮助我们更好的使用webpack构建项目。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-写在前面&quot;&gt;&lt;a href=&quot;#1-写在前面&quot; class=&quot;headerlink&quot; title=&quot;1. 写在前面&quot;&gt;&lt;/a&gt;1. 写在前面&lt;/h2&gt;&lt;p&gt;在前面的博客中我们说过，webpack之所以有这么强大的功能，是因为它借助了很多 &lt;strong&gt;loa
      
    
    </summary>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门学习笔记12 —— 打包编译后文件的引入路径问题</title>
    <link href="http://yoursite.com/2019/08/04/webpack%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012%20%E2%80%94%E2%80%94%20%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91%E5%90%8E%E6%96%87%E4%BB%B6%E7%9A%84%E5%BC%95%E5%85%A5%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/08/04/webpack入门学习笔记12 —— 打包编译后文件的引入路径问题/</id>
    <published>2019-08-03T16:00:00.000Z</published>
    <updated>2019-12-15T05:25:44.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><p>在一些基于Webpack的项目中，我们可能会遇到这个情况：使用本地开发服务器开发项目的时候，项目可以正常运行，所需要的资源也能正常请求到。但是项目经打包编译，部署到服务器上之后，会报错一些 <strong>404</strong> 的错误，显示一些图片文件、css文件或js文件等找不到。</p><p>这是因为打包后的项目文件的引用路径问题，如果我们不做额外配置，打包编译后得到的 <strong>.html</strong> 文件的代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">en</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">UTF-8</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">viewport</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">X-UA-Compatible</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">css/main.css</span> <span class="attr">rel</span>=<span class="string">stylesheet</span>&gt;</span><span class="comment">&lt;!-- 注意这里的文件引入路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">logo.png</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="comment">&lt;!-- 注意这里的文件引入路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">text/javascript</span> <span class="attr">src</span>=<span class="string">index.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="comment">&lt;!-- 注意这里的文件引入路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个时候，如果是在本地开发服务器中查看项目，是没有问题的。因为在本地开发服务器下，有且只有我们当前开发的这一个项目，并且项目所需要的文件，也都可以通过开发服务器的根域名获取到。比如可以直接通过 <strong>localhost：8080/css/main.css</strong> 找到相关文件。</p><p>但是真实的服务器上可能有很多项目，想要访问项目文件，需要通过 <strong>域名+项目目录</strong> 来访问，比如 <strong><a href="http://www.fengzhen8023.com/myProject/css/main/css" target="_blank" rel="noopener">www.fengzhen8023.com/myProject/css/main/css</a></strong> 来访问。</p><p>但是如上面 <strong>.html</strong> 文件所示，文件的引入路径中，没有项目目录名。所以会直接到根域名下找所需要的资源，那么最终肯定是获取不到，报出一些404的错误。</p><p>所以根据服务器部署的实际情况，我们在打包编译项目的时候，需要做一些额外配置，使得在引入文件资源的时候，在前面加一些路径，比如域名或者项目文件名等，使得文件可以被正常引入。</p><p>这也是本篇博客的主要内容，包括两个方面：</p><ul><li>在所有的文件引用路径中，添加前缀域名</li><li>单独给图片文件引用路径中，添加前缀域名</li></ul><h2 id="2-在所有的文件引用路径中，添加前缀域名"><a href="#2-在所有的文件引用路径中，添加前缀域名" class="headerlink" title="2. 在所有的文件引用路径中，添加前缀域名"></a>2. 在所有的文件引用路径中，添加前缀域名</h2><p>为了达到这个目的，我们需要在 <strong>webpack.config.js</strong> 文件中进行配置，配置的方法非常简单，这里直接给出代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">/* 节省篇幅，其他配置已省略 */</span> </span><br><span class="line">    output: &#123; </span><br><span class="line">        filename: <span class="string">"index.js"</span>, <span class="comment">// 出口文件的文件名</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">"build"</span>), <span class="comment">//出口文件的路径，注意一定要是绝对路径</span></span><br><span class="line">        publicPath: <span class="string">'http://www.fengzhen8023.com/myProject/'</span><span class="comment">// 给所有的文件引用路径中，添加前缀域名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 <strong><a href="https://github.com/Fengzhen8023/webpack-learning" target="_blank" rel="noopener">GitHub仓库 - webpack-learning</a></strong> ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。</p><p>配置完成之后，再次进行打包编译项目，得到的 <strong>.html</strong> 文件如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">en</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">UTF-8</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">viewport</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">X-UA-Compatible</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">http://www.fengzhen8023.com/myProject/css/main.css</span> <span class="attr">rel</span>=<span class="string">stylesheet</span>&gt;</span><span class="comment">&lt;!-- 注意这里的文件引入路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">http://www.fengzhen8023.com/myProject/logo.png</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="comment">&lt;!-- 注意这里的文件引入路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">text/javascript</span> <span class="attr">src</span>=<span class="string">http://www.fengzhen8023.com/myProject/index.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="comment">&lt;!-- 注意这里的文件引入路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如此，部署到服务器上的项目，就可以正常访问所需要的文件了。</p><h2 id="3-单独给图片文件引用路径中，添加前缀域名"><a href="#3-单独给图片文件引用路径中，添加前缀域名" class="headerlink" title="3. 单独给图片文件引用路径中，添加前缀域名"></a>3. 单独给图片文件引用路径中，添加前缀域名</h2><p>在上一节中，我们知道如何给项目中所需要引入的文件添加前缀，这里在介绍，如何单独给图片资源引用路径添加前缀域名，使得项目更具灵活性。</p><p>这个时候需要使用到一个laoder—— <strong>url-loader</strong>，使用之前首先要进行安装，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add url-loader -D</span><br></pre></td></tr></table></figure><p>安装完成之后，在 <strong>webpack.config.js</strong> 中进行如下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">/* 节省篇幅，其他配置已省略 */</span> </span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|jpg|jpeg|gif)$/</span>,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        limit: <span class="number">2</span> * <span class="number">1024</span>, <span class="comment">// 小于2k的图片，直接使用Base64编码进行处理</span></span><br><span class="line">                        outputPath: <span class="string">'/image/'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于url-loader和Base64的相关介绍，大家可以查看我的上一篇博客: <strong><a href="https://github.com/Fengzhen8023/webpack-learning/blob/master/blog/11.%20%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AF%B9%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91%E7%9A%84%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%88%86%E7%B1%BB.md" target="_blank" rel="noopener">在项目中对打包编译的文件进行分类</a></strong>，里面有较为详细的介绍。</p><p>配置完成，再次编译项目的时候，得到的 <strong>.html</strong> 文件中的代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">en</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">UTF-8</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">viewport</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">X-UA-Compatible</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">css/main.css</span> <span class="attr">rel</span>=<span class="string">stylesheet</span>&gt;</span> <span class="comment">&lt;!-- css文件引用路径没有做处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">/image/logo.png</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span> <span class="comment">&lt;!-- 注意这的图片的引用路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">text/javascript</span> <span class="attr">src</span>=<span class="string">index.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> <span class="comment">&lt;!-- js文件引用路径没有做处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-写在最后"><a href="#4-写在最后" class="headerlink" title="4. 写在最后"></a>4. 写在最后</h2><p>以上便是这篇博客的全部内容，如果你想对其他的文件单独进行引用路径的修改，可以查阅相关的文档，不过大致思路是：</p><p>给处理这些文件的loader配置相关的属性，来指定打包编译后，文件的引用路径。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-写在前面&quot;&gt;&lt;a href=&quot;#1-写在前面&quot; class=&quot;headerlink&quot; title=&quot;1. 写在前面&quot;&gt;&lt;/a&gt;1. 写在前面&lt;/h2&gt;&lt;p&gt;在一些基于Webpack的项目中，我们可能会遇到这个情况：使用本地开发服务器开发项目的时候，项目可以正常
      
    
    </summary>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门学习笔记13 —— 使用Webpack打包多页面应用</title>
    <link href="http://yoursite.com/2019/08/04/webpack%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013%20%E2%80%94%E2%80%94%20%E4%BD%BF%E7%94%A8Webpack%E6%89%93%E5%8C%85%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2019/08/04/webpack入门学习笔记13 —— 使用Webpack打包多页面应用/</id>
    <published>2019-08-03T16:00:00.000Z</published>
    <updated>2019-12-15T05:25:44.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><p>如果你熟悉Vue或者React的话，那么你肯定知道使用这些框架创建的应用属于 <strong>单页面应用</strong> 。这些框架底层使用的就是Webpack来构建项目，通过对项目文件进行打包编译，最终生成一个 <strong>.html</strong> 文件，所以我们说这些应用属于 <strong>单页面应用</strong>。</p><p>但是在使用webpack进行构建项目的时候，不仅可以构建单页面应用，还可以构建多页面应用。</p><p>在实际的项目中，如果该项目初期使用的就是 <strong>脚手架（比如Vue脚手架或者React脚手架）</strong> 搭建起来的，那么该项目大多是单页面应用。</p><p>但是如果项目在前期不是使用 <strong>脚手架</strong> 搭建起来的，比如使用 <strong>jQuery</strong> 库来开发的。但是后期有几个大的业务逻辑，需要使用 <strong>Vue脚手架</strong> 或者是 <strong>React脚手架</strong> 来开发，这个时候可能就需要使用Webpack来构建多页面应用，每一个大的业务逻辑对应一个单页面应用。</p><p>所以在这篇博客中，我就来跟大家介绍一下如何使用Webpak，构建多页面应用。主要内容包括：</p><ul><li>如何通过打包编译，生成不同的 <strong>.js</strong> 文件</li><li>如何在 <strong>.html</strong> 文件中，引入指定的 <strong>.js</strong> 文件</li></ul><h2 id="2-如何通过打包编译，生成不同的-js-文件"><a href="#2-如何通过打包编译，生成不同的-js-文件" class="headerlink" title="2. 如何通过打包编译，生成不同的 .js 文件"></a>2. 如何通过打包编译，生成不同的 <strong>.js</strong> 文件</h2><p>如果你看过我之前的博客，那么你就会知道在 <strong><a href="https://github.com/Fengzhen8023/webpack-learning/blob/master/history/webpack.config.6.js" target="_blank" rel="noopener">webpack.config.js</a></strong> 文件中，有以下的配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">"./src/index.js"</span>, <span class="comment">// 打包的入口文件，默认是src目录下的index.js文件</span></span><br><span class="line">    output: &#123; <span class="comment">// 配置文件默认是dist目录下的main.js文件</span></span><br><span class="line">        filename: <span class="string">"index.js"</span>, <span class="comment">// 出口文件的文件名</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">"build"</span>), <span class="comment">//出口文件的路径，注意一定要是绝对路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上的配置，webpack就可以找到项目的入口文件（<strong>./src/index.js</strong>）来对项目进行打包编译，最终生成的就是一个单页面应用。这就给我们提供一个思路：如果我们想要使用webpack打包编译，生成多页面应用，也要通过修改这两个配置属性来完成。</p><p>想要构建多页面应用，配置方式非常简单，这里直接给出配置代码，然后再作出解释：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;    <span class="comment">// 指定入口文件</span></span><br><span class="line">        <span class="string">'home'</span>: <span class="string">"./src/index.js"</span>,   </span><br><span class="line">        <span class="string">'other'</span>: <span class="string">"./src/other.js"</span></span><br><span class="line">    &#125;, </span><br><span class="line">    output: &#123; <span class="comment">// 配置文件默认是dist目录下的main.js文件</span></span><br><span class="line">        filename: <span class="string">"[name].js"</span>, <span class="comment">// 出口文件的文件名</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">"build"</span>), <span class="comment">//出口文件的路径，注意一定要是绝对路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码，我们可以看到，<strong>entry</strong> 属性的值由字符串变为了对象。在该对象中，我们配置了两个属性，这就表明，我们准备使用webpack来构建 <strong>两个</strong> 单页面应用，分别是 <strong>home</strong> 应用和 <strong>other</strong> 应用。他们都有一个对应的入口文件，webpack在打包编译的时候，就是从他们的入口文件触发，分别构建对应的单页面应用。</p><p>同时我们还修改了 <strong>output.filename</strong> 这个属性，不再是固定的 <strong>index.js</strong>，而是 <strong>[name].js</strong> 。这样就可以通过 <strong>entry对象</strong> 的两个属性（即home和other）来动态生成对应的 <strong>.js</strong> 文件。</p><p>现在你可以在 <strong>src文件夹</strong> 下创建两个入口文件 <strong>index.js</strong> 和 <strong>other.js</strong> ，在里面写对应的代码，然后执行webpack的 <strong>build</strong> 命令，就可以进行打包编译，最终会生成两个文件，即  <strong>index.js</strong> 和 <strong>other.js</strong> ，到这一步多页面应用的 <strong>.js</strong> 文件已经构建完成了。</p><h2 id="3-如何在-html-文件中，引入指定的-js-文件"><a href="#3-如何在-html-文件中，引入指定的-js-文件" class="headerlink" title="3. 如何在 .html 文件中，引入指定的 .js 文件"></a>3. 如何在 <strong>.html</strong> 文件中，引入指定的 <strong>.js</strong> 文件</h2><p>现在多页面应用的 <strong>.js</strong> 文件已经构建完成，但是我们还需要在 <strong>.html</strong> 文件中引入 <strong>.js</strong> 文件，多页面应用才算是正式完成，所以这一节我们介绍如何在 <strong>.html</strong> 文件中引入 <strong>.js</strong> 文件。</p><p>想要达到这个目的，我们需要解除 <strong>html-webpack-plugin</strong> 这一插件的帮助，首先执行以下代码进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>安装完成之后，到 <strong>webpack.config.js</strong> 文件中做以下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> HtmlWebpackPlugin = requier(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">/* 节省篇幅，其余配置已省略 */</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">'./index.html'</span>,</span><br><span class="line">            filename: <span class="string">'home.html'</span>,</span><br><span class="line">            chunks: [<span class="string">'home'</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">'./index.html'</span>,</span><br><span class="line">            filename: <span class="string">'other.html'</span>,</span><br><span class="line">            chunks: [<span class="string">'other'</span>]</span><br><span class="line">            <span class="comment">// chunks: ['other', 'home']// 也可以引入多个 .js 文件</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 <strong><a href="https://github.com/Fengzhen8023/webpack-learning" target="_blank" rel="noopener">GitHub仓库 - webpack-learning</a></strong> ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。</p><p>因为我们这里构建的是两个单页面应用，所以这里要创建两个 <strong>HtmlWebpackPlugin</strong> 对象，在每个对象中，都有三个属性，这里一一对这些属性做出解释：</p><ul><li><strong>template:</strong> 这是模板文件，webpack会在这个文件中，通过 <strong><code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code></strong> 标签引入打包编译生成的 <strong>.js</strong> 文件，生成最终的 <strong>.html</strong> 页面文件。</li><li><strong>filename:</strong> 在模板文件中引入 <strong>.js</strong> 文件，会生成一个新的 <strong>.html</strong> 文件，通过 <strong>filename</strong> 属性，可以指定生成的 <strong>.html</strong> 文件的名称。</li><li><strong>chunks:</strong> 现在模板文件和打包编译的 <strong>.js</strong> 文件都已经有了，但是要在模板文件中引入哪些 <strong>.js</strong> 文件呢？可以通过 <strong>chunks</strong> 属性来指定。我们可以通过数组的形式，指定一个或多个 <strong>.js</strong> 文件，这样就可以在模板文件中引入一个或多个 <strong>.js</strong> 文件。</li></ul><p>有了上面的配置，现在执行webpack的 <strong>build</strong> 命令，就可以进行打包编译，最终最终会生成 <strong>home.html</strong> 和 <strong>other.html</strong> 两个文件，也就是两个单页面应用。如此一来，我们就使用webpack成功构建了多页面应用。</p><h2 id="4-写在最后"><a href="#4-写在最后" class="headerlink" title="4. 写在最后"></a>4. 写在最后</h2><p>到此为止，我们如何使用webpack构建多页面应用，并且生成了对应的 <strong>.html</strong> 文件，现在到项目中，使用这些 <strong>.html</strong> 文件，就可以使用我们开发的应用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-写在前面&quot;&gt;&lt;a href=&quot;#1-写在前面&quot; class=&quot;headerlink&quot; title=&quot;1. 写在前面&quot;&gt;&lt;/a&gt;1. 写在前面&lt;/h2&gt;&lt;p&gt;如果你熟悉Vue或者React的话，那么你肯定知道使用这些框架创建的应用属于 &lt;strong&gt;单页面应用
      
    
    </summary>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门学习笔记10 —— 在项目中使用图片资源</title>
    <link href="http://yoursite.com/2019/07/28/webpack%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010%20%E2%80%94%E2%80%94%20%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90/"/>
    <id>http://yoursite.com/2019/07/28/webpack入门学习笔记10 —— 在项目中使用图片资源/</id>
    <published>2019-07-27T16:00:00.000Z</published>
    <updated>2019-12-15T05:25:44.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><p>在前端项目中，图片是必不可少的一种资源。在使用图片的时候，我们可以有以下几种方式：</p><ul><li>在 <strong>.html</strong> 文件中，通过 <strong><code>&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;</code></strong> 标签引入图片</li><li>在 <strong>.css</strong> 文件中，通过 <strong><code>background: url()</code></strong> 属性来引入图片</li><li>在 <strong>.js</strong> 文件中，通过 <strong><code>import</code></strong> 或者 <strong><code>require</code></strong> 语法来引入图片</li></ul><p>但是在基于webpack的项目中，如果你只是简单的引入，而没有对这些图片文件做一些配置处理的话，是不能成功的。比如，如果你在一个 <strong>.js</strong> 文件中书写以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">'./logo.png'</span></span><br><span class="line"><span class="built_in">console</span>.log(logo);</span><br></pre></td></tr></table></figure><p>或者在 <strong>.css</strong> 文件中，书写以下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'./logo.png'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在进行打包编译项目或者启动本地开发服务器的时候，会报出以下错误：</p><p><img src="http://q1d2135zd.bkt.clouddn.com//webpack-10-01.png" alt></p><p>错误提示很明显：我们需要一个合适的loader来处理这些图片文件。</p><p>那么在这篇博客中，我们就来讲述一下：如何进行配置webpack，使得图片资源可以在项目中被正常地使用。主要内容包括：</p><ul><li>使用 file-loader 处理图片资源</li><li>使用 html-withimg-loader 处理图片资源</li></ul><h2 id="2-使用-file-loader-处理图片资源"><a href="#2-使用-file-loader-处理图片资源" class="headerlink" title="2. 使用 file-loader 处理图片资源"></a>2. 使用 file-loader 处理图片资源</h2><p>首先讲述如何使用 <strong>file-loader</strong> 来处理图片资源，既然是一个loader，那么第一步肯定是安装，安装命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add file-loader -D</span><br></pre></td></tr></table></figure><p>安装完成之后，到 <strong>webpack.config.js</strong> 文件中进行配置，配置规则非常简单，这里直接给出代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">/* 节省篇幅，其他配置信息已省略 */</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|jpg|jpeg|gif)$/</span>,  <span class="comment">// 使用正则匹配文件图片</span></span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: <span class="string">'file-loader'</span>   <span class="comment">// 使用file-loader对这些文件进行处理</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 <strong><a href="https://github.com/Fengzhen8023/webpack-learning" target="_blank" rel="noopener">GitHub仓库 - webpack-learning</a></strong> ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。</p><p>这里介绍一下 <strong>file-loader</strong> 的作用：对项目中使用到的图片文件进行处理，将处理后的文件保存到 <strong>输出文件夹</strong></p><p>，并返回输出文件夹下该文件的 <strong>URL</strong> 。如此一来，这个文件就可以被正常使用。</p><p>下面我们在项目中体验一下这个loader的作用，在一个 <strong>.js</strong> 文件中书写以下代码，使用图片资源：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">'./logo.png'</span>   <span class="comment">// 引入图片</span></span><br><span class="line"><span class="built_in">console</span>.log(logo);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src = logo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].appendChild(img);</span><br></pre></td></tr></table></figure><p>打包编译之后，就可以在页面上看到这样图片了。</p><p>同理，在 <strong>.css</strong> 文件中也可以正常使用图片资源，参考代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'./logo.png'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这时候，你在 <strong>.html</strong> 文件中 <strong><code>&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;</code></strong> 标签引入图片，webpack一样会报错。仅靠file-loader做不到这一点，为了解决这个问题，我们需要 <strong>在file-loader的基础上</strong>，使用下面讲到的loader。</p><h2 id="3-使用-html-withimg-loader-处理图片资源"><a href="#3-使用-html-withimg-loader-处理图片资源" class="headerlink" title="3. 使用 html-withimg-loader 处理图片资源"></a>3. 使用 html-withimg-loader 处理图片资源</h2><p>这个loader的作用是：处理 <strong>.html</strong> 文件中引用的图片，使得图片能够被正常使用。但是要注意，使用这个loader的时候，同时也要使用上面的 <strong>file-loader</strong> 。</p><p>和上面一样，首先我们要做的还是进行安装，安装命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add html-withimg-loader -D</span><br></pre></td></tr></table></figure><p>安装完成之后，到 <strong>webpack.config.js</strong> 文件中进行配置，配置规则非常简单，这里直接给出代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> <span class="comment">/* 节省篇幅，其他配置信息已省略 */</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// 配置 file-loader</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|jpg|jpeg|gif)$/</span>,   </span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: <span class="string">'file-loader'</span>    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 配置 html-withimg-loader</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">                use: <span class="string">'html-withimg-loader'</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成之后，我们就可以在 <strong>.html</strong> 文件中正常使用图片，比如以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入logo.png图片 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./logo.png"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在进行打包编译项目，得到编译后的 <strong>index.html</strong> 文件代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">en</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">UTF-8</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">viewport</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">X-UA-Compatible</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意这里的图片引用路径不再是logo.png --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个路径是 file-loader 对文件处理后生成新文件的路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">2b9a35ac93ae4d5ea1eb21230d61c324.png</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个时候在浏览器中打开编译后的 <strong>index.html</strong> 文件，就可以看到我们的图片了。</p><h2 id="4-优化图片处理方式，减少http请求"><a href="#4-优化图片处理方式，减少http请求" class="headerlink" title="4. 优化图片处理方式，减少http请求"></a>4. 优化图片处理方式，减少http请求</h2><p>在编写前端项目的过程中，我们可能会用到很多图片资源，有些图片非常小，只有几KB。但是这些小图片的数量有时却非常大，有的项目中可能有几十个甚至是上百个图片。</p><p>这就会导致一个问题：项目上线之后，为了请求这些图片资源，浏览器端会大量使用http请求来获取图片，这就可能导致浏览器的开销过大，性能较低。那么怎么来解决这个问题呢？</p><p>这里我们介绍一种编码方式——Base64编码。这不是一种加密解密方式，它是一种编码方式。简单来说，它的作用就是：使用字符来表示任意二进制文件（这些字符包括：<strong>A B … Z a b … z 0 1 … 9 + /</strong> 等64个字符）。</p><p>为了更加贴切的体会Base64编码，你可以复制以下长长的Base64编码，粘贴到浏览器地址栏，便可以看到这段Base64编码表示的图片了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:image/png;base64,iVBORw0KGgoAAAANSUhEU 中间省略很长很长一段编码 AABJRU5ErkJggg==</span><br></pre></td></tr></table></figure><p>使用Base64对图片进行编码，就可以将这些图片切入到静态的 <strong>.html</strong> 文件中，这样就不需要再使用http请求来获取图片了，从而节省浏览器开销，提高性能。</p><p>为了在基于Webpack的项目中使用Base64编码处理图片，我们需要使用 <strong>url-loader</strong> 来进行处理。首先安装该loader，安装命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add url-loader -D</span><br></pre></td></tr></table></figure><p>安装完成之后，我们到 <strong>webpack.config.js</strong> 文件中进行相关配置，配置非常简单，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   <span class="comment">/* 节省篇幅，其他的配置信息已省略 */</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|jpg|jpeg|gif)$/</span>,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        limit: <span class="number">200</span>*<span class="number">1024</span><span class="comment">// 小于200k的图片，使用Base64进行处理</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 <strong><a href="https://github.com/Fengzhen8023/webpack-learning" target="_blank" rel="noopener">GitHub仓库 - webpack-learning</a></strong> ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。</p><p>上述配置非常好理解：对于png、jpg等图片格式的资源，使用url-loader进行处理，如果图片小于200k，那么就是用Base64进行编码；如果图片大于200k，就不做处理，使用http请求来获取图片。</p><p>配置完成之后，当我们编译项目时，就会在生成的 <strong>.html</strong> 文件中看到使用Base64编码后的图片，由于内容较多，就不贴代码，想查看的编译后代码的同学，可以点击 <strong><a href="https://github.com/Fengzhen8023/webpack-learning/blob/master/history/Base64Image.html" target="_blank" rel="noopener">Github连接</a></strong> 进行查看。</p><h2 id="5-写在最后"><a href="#5-写在最后" class="headerlink" title="5. 写在最后"></a>5. 写在最后</h2><p>这是本篇博客的全部内容，关于 <strong>file-loader</strong> 的更多知识，推荐大家访问 <strong><a href="https://www.webpackjs.com/loaders/file-loader/" target="_blank" rel="noopener">webpack官网 - file-loader</a></strong> 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-写在前面&quot;&gt;&lt;a href=&quot;#1-写在前面&quot; class=&quot;headerlink&quot; title=&quot;1. 写在前面&quot;&gt;&lt;/a&gt;1. 写在前面&lt;/h2&gt;&lt;p&gt;在前端项目中，图片是必不可少的一种资源。在使用图片的时候，我们可以有以下几种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门学习笔记11 —— 在项目中对打包编译的文件进行分类</title>
    <link href="http://yoursite.com/2019/07/28/webpack%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011%20%E2%80%94%E2%80%94%20%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AF%B9%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91%E7%9A%84%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/07/28/webpack入门学习笔记11 —— 在项目中对打包编译的文件进行分类/</id>
    <published>2019-07-27T16:00:00.000Z</published>
    <updated>2019-12-15T05:25:44.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><p>在前面的博客中，我们对Webpack项目进行了很多配置，也多次打包编译了项目。如果你细心观察的话，你会看到，项打包编译后的目代码,全部都放在了 <strong>build</strong> 文件夹下，没有根据文件格式的不同再次进行分类。</p><p><img src="http://q1d2135zd.bkt.clouddn.com//webpack-11-01.png" alt></p><p>但是我们所期望的场景是：项目打包编译之后，对文件进行分类，不同的文件放在不同的文件夹下。比如打包编译后，图片全部都放在 <strong>build/images</strong> 文件夹下，样式文件全部放在 <strong>build/css</strong> 文件夹下，这样便于管理项目。如下图所示：</p><p><img src="http://q1d2135zd.bkt.clouddn.com//webpack-11-02.png" alt></p><p>那么需要如何配置，才能达到这个目的呢？在这篇博客中，我会跟大家分享。</p><p>本片博客的主要内容有：</p><ul><li>将图片文件进行分类</li><li>将CSS样式文件进行分类</li></ul><h2 id="2-将图片文件进行分类"><a href="#2-将图片文件进行分类" class="headerlink" title="2. 将图片文件进行分类"></a>2. 将图片文件进行分类</h2><p>想要对图片进行分类，我们需要使用 <strong>url-loader</strong> 来处理图片文件。第一步还是安装该loader，安装命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add url-loader -D</span><br></pre></td></tr></table></figure><p>安装完成之后，到 <strong>webpack.config.js</strong> 中进行配置，配置规则非常简单，这里直接给出代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">/* 节省篇幅，其余配置已省略 */</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [ &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|jpg|jpeg|gif)$/</span>,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        limit: <span class="number">2</span> * <span class="number">1024</span>,    <span class="comment">// 小于2k的图片，直接使用Base64编码进行处理</span></span><br><span class="line">                        outputPath: <span class="string">'/image/'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 <strong><a href="https://github.com/Fengzhen8023/webpack-learning" target="_blank" rel="noopener">GitHub仓库 - webpack-learning</a></strong> ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。</p><p>下面对上述配置进行简单解释：</p><ul><li>使用url-loader处理图片资源的时候，需要指定 <strong>limit</strong> 属性，当图片小于该属性大小的时候，直接使用Base64编码处理图片，不会再项目中生成图片文件。</li><li>当图片大于该属性大小的时候，不使用Base64编码处理图片，而是将该图片放到 <strong>build</strong> 文件夹下，如果指定了 <strong>outputPath</strong> 属性，那么图片会放到该属性指定的目录下。</li></ul><h2 id="3-将CSS样式文件进行分类"><a href="#3-将CSS样式文件进行分类" class="headerlink" title="3. 将CSS样式文件进行分类"></a>3. 将CSS样式文件进行分类</h2><p>对打包编译后的CSS文件进行分类，需要借助一个插件，即：<strong>mini-css-extract-plugin</strong> 。使用之前需要使用以下命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure><p>安装完成之后，进行以下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MiniCssExtract = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)     <span class="comment">// 引入插件</span></span><br><span class="line"><span class="comment">/* 节省篇幅，其余配置已省略 */</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtract(&#123;</span><br><span class="line">            filename: <span class="string">'css/main.css'</span>    <span class="comment">// 配置CSS输出位置</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成之后，进行打包编译项目，就会看到编译后的CSS文件在 <strong>build/css</strong> 文件夹之下了。</p><h2 id="4-写在最后"><a href="#4-写在最后" class="headerlink" title="4. 写在最后"></a>4. 写在最后</h2><p>以上便是本篇博客的所有内容，希望对一些初次接触Webpack的前端小白有所帮助。</p><p>文章中如有错误之后，还希望各位大佬予以纠正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-写在前面&quot;&gt;&lt;a href=&quot;#1-写在前面&quot; class=&quot;headerlink&quot; title=&quot;1. 写在前面&quot;&gt;&lt;/a&gt;1. 写在前面&lt;/h2&gt;&lt;p&gt;在前面的博客中，我们对Webpack项目进行了很多配置，也多次打包编译了项目。如果你细心观察的话，你会看
      
    
    </summary>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门学习笔记08 —— 使用ESLint检查项目代码</title>
    <link href="http://yoursite.com/2019/07/21/webpack%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B008%20%E2%80%94%E2%80%94%20%E4%BD%BF%E7%94%A8ESLint%E6%A3%80%E6%9F%A5%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2019/07/21/webpack入门学习笔记08 —— 使用ESLint检查项目代码/</id>
    <published>2019-07-20T16:00:00.000Z</published>
    <updated>2019-12-15T05:25:44.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><p>JavaScript作为一门动态语言，灵活性是它的一个优点，同时又是一个缺点。有的时候因为语法太过于灵活，导致一些隐藏的Bug被我们忽略，代码质量得不到保证。</p><p>为了提到项目代码的质量，大多数架构师在初始化项目的时候，都会使用一个检查工具来帮助实现代码的规范性和正确性，同时也可以提高项目代码后期的可维护性。在基于webpack的项目中，经常被使用到的代码检查工具是 <strong>ESLint</strong> 。</p><p><img src="http://q1d2135zd.bkt.clouddn.com//webpack-08-01.png" alt></p><p>它就像是一个测试人员一样，告诉你哪里写得不对（<strong>errors</strong>），哪里写得不好（<strong>warnings</strong>）。那么在本篇博客中，就讲解如何在自己的项目中，配置使用 <strong>ESLint</strong> 这一检查工具。主要内容有：</p><ul><li>安装并配置 ESLint-loader</li><li>根据实际情况，编写ESLint的配置文件</li></ul><h2 id="2-安装并配置-ESLint-loader"><a href="#2-安装并配置-ESLint-loader" class="headerlink" title="2. 安装并配置 ESLint-loader"></a>2. 安装并配置 ESLint-loader</h2><p><strong>ESLint</strong> 这一代码检查工具在项目中的使用体现是一个 <strong>loader</strong> ，既然是loader，那么使用步骤和之前博客中讲述的几个loader一样，首先是安装，然后在webpack配置文件中，使用这些loader。</p><p>使用以下安装命令，安装 <strong>eslint</strong> 和 <strong>eslint-loader</strong> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add eslint eslint-loader -D</span><br></pre></td></tr></table></figure><p>安装完成之后，在 <strong>webpack.config.js</strong> 文件中，配置使用该loader的规则，配置非常简单，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        <span class="comment">/** 其他的配置规则，节省篇幅，故省略  **/</span> </span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>, </span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: <span class="string">'eslint-loader'</span>, </span><br><span class="line">                options: &#123;</span><br><span class="line">                    enforce: <span class="string">'pre'</span> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 <strong><a href="https://github.com/Fengzhen8023/webpack-learning" target="_blank" rel="noopener">GitHub仓库 - webpack-learning</a></strong> ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。</p><p>这里解释一下上面代码中标有注释的两个属性： <strong>enforce</strong> 和 <strong>exclude</strong> ：</p><ul><li><p><strong>enforce</strong>:  该属性表示loader的种类，loader有四种：<strong>前置loader、后置loader、普通loader、内联loader</strong> 。该属性默认是 <strong>normal(即默认loader)</strong> 。可以根据需要设置成 <strong>pre(前置loader)</strong> 或者 <strong>post(后置loader)</strong> 。</p><p>属性的而不同导致loader的一些行为不同，前面博客中讲过：在webpack.config.js配置文件中，loader的执行顺序是 <strong>从右到左，从下到上</strong>  。但是：</p><p>如果是前置loader，那么webpack会 <strong>优先</strong> 使用该loader处理文件；</p><p>如果是后置loader，那么webpack会在普通loader <strong>之后</strong> 处理文件；</p><p>如果是内联loader，可以在 <strong>.js</strong> 文件中使用，而 <strong>不只是</strong> 在webpack.config.js配置文件中使用。-</p></li></ul><ul><li><strong>exclude</strong> ：排除正则表达式匹配的文件或者文件夹，比如上述规则中，不使用eslint-loader对 <strong>node_modules</strong> 文件夹中的代码进行校验。</li></ul><p>好了，现在配置完成之后，你是不是想马上体验一下ESLint的强大功能？如果这个时候你进行打包编译项目，那么会得到一下错误信息：</p><p><img src="http://q1d2135zd.bkt.clouddn.com//webpack-09-01.png" alt></p><p>错误提示易懂，是因为我们没有配置ESlint的处理规则，这也是我们下面要讲述的知识点。</p><h2 id="3-编写ESLint的配置文件"><a href="#3-编写ESLint的配置文件" class="headerlink" title="3. 编写ESLint的配置文件"></a>3. 编写ESLint的配置文件</h2><p>如果你对ESLint非常熟悉，那么完全可以自己动手编写该配置文件，但是大多数人可能对ESLint的配置不是那么熟悉，这里推荐大家到 <strong><a href="https://cn.eslint.org/demo/" target="_blank" rel="noopener">官网的Demo配置页面</a></strong> ,根据自己的需求，来获取ESLint配置文件：</p><p><img src="http://q1d2135zd.bkt.clouddn.com//webpack-08-03.png" alt></p><p>在该页面，根据实际情况选择你的项目需要，然后点击页面底部的 <strong>Download .eslintrc.json file</strong> 即可下载得到一份ESLint配置文件。</p><p>将这个文件重命名（在文件名之前加一个 <strong>点</strong>）得到 <strong>.eslintrc.json</strong> 文件，然后将这个文件放到你的项目根目录下，和 <strong>webpack.config.js</strong> 文件同级。</p><p>如此一来，便配置好了ESLint。这个时候再来打包编译项目或者开启本地开发服务器，就可以看到ESLint发挥的作用了。比如，一个不规范的代码可能会得到以下错误提示：</p><p><img src="http://q1d2135zd.bkt.clouddn.com//webpack-08-04.png" alt></p><h2 id="4-写在后面"><a href="#4-写在后面" class="headerlink" title="4. 写在后面"></a>4. 写在后面</h2><p>以上便是这篇博客的全部内容，如果想学习更多ESLInt的知识，推荐访问ESLint的官网：<a href="https://cn.eslint.org/" target="_blank" rel="noopener">https://cn.eslint.org/</a> 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-写在前面&quot;&gt;&lt;a href=&quot;#1-写在前面&quot; class=&quot;headerlink&quot; title=&quot;1. 写在前面&quot;&gt;&lt;/a&gt;1. 写在前面&lt;/h2&gt;&lt;p&gt;JavaScript作为一门动态语言，灵活性是它的一个优点，同时又是一个缺点。有的时候因为语法太过于灵活
      
    
    </summary>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门学习笔记09 —— 在项目中引入全局变量</title>
    <link href="http://yoursite.com/2019/07/21/webpack%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B009%20%E2%80%94%E2%80%94%20%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%95%E5%85%A5%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2019/07/21/webpack入门学习笔记09 —— 在项目中引入全局变量/</id>
    <published>2019-07-20T16:00:00.000Z</published>
    <updated>2019-12-15T05:25:44.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><p>在做项目的时候，我们可能会经常遇到这种场景：一个变量我在很多文件中都要用到。这变量可能是第三方包，或者是自己定义的一个工具类对象等。</p><p>比如在基于jQuery的多页面应用中，在每一个页面中都要使用到 <strong>jQuery对象</strong> ；在单页面应用中，一个 <strong>消息提示框</strong> 在所有组件中都要用到。</p><p>这个时候我们应该怎么办，如果在所有页面中都引用这个变量的话，工作量比较大，而且对项目的维护也不是很友好。这篇博客就来讲解：如何高效便捷地引入全局变量。主要内容包括：</p><ul><li>使用 <strong>webpack模块</strong> 注册全局变量</li><li>将变量暴露给 <strong>window对象</strong> ，成为全局变量</li></ul><p>我们jquery对象为例，讲解如何在基于webpack的项目中，注入全局变量。首先安装jquery包：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yard add jquery</span><br></pre></td></tr></table></figure></p><h2 id="2-使用webpack模块注入全局变量"><a href="#2-使用webpack模块注入全局变量" class="headerlink" title="2. 使用webpack模块注入全局变量"></a>2. 使用webpack模块注入全局变量</h2><p>这里要特别注意一下，webpack是一个工具，可以帮助我们构建项目，在这个工具里面，有一个 <strong>同名模块</strong>，叫做 <strong>webpack</strong> ，我们今天就是要使用这个模块来给每一个页面或者组件注入一个对象。</p><p>配置的规则很简单，这里先给出 <strong>webpack.config.js</strong> 文件中的配置代码，然后再进行解释：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 节省篇幅，其他的配置信息忽已略 */</span></span><br><span class="line"><span class="keyword">let</span> Webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)    <span class="comment">// 引入webpack模块</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [      <span class="comment">// 这是一个插件，所以要在plugins属性中配置</span></span><br><span class="line">        <span class="keyword">new</span> Webpack.ProvidePlugin(&#123;</span><br><span class="line">            $: <span class="string">'jquery'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 <strong><a href="https://github.com/Fengzhen8023/webpack-learning" target="_blank" rel="noopener">GitHub仓库 - webpack-learning</a></strong> ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。</p><p>上述配置的作用是：给项目中的每一个文件，都注入一个对象 <strong>$</strong> ，这个对象就是我们安装的jquery包。安装完成之后，在其他页面中无需引入，即可使用jQuery语法。比如某一个 <strong>.js</strong> 文件中书写以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log($)</span><br><span class="line"><span class="built_in">console</span>.log($(<span class="built_in">window</span>));</span><br></pre></td></tr></table></figure><p>项目启动之后，就会在控制台输出jquery对象和选择的window对象。由此可知，我们成功注册了一个全局变量。</p><h2 id="3-将变量暴露给-window对象-，成为全局变量"><a href="#3-将变量暴露给-window对象-，成为全局变量" class="headerlink" title="3. 将变量暴露给 window对象 ，成为全局变量"></a>3. 将变量暴露给 <strong>window对象</strong> ，成为全局变量</h2><p>从事前端开发的程序员都知道，JS的全局变量就是 <strong>window</strong> 对象的属性或方法，所以如果在项目中，如果我们能够把一个变量，设置成 <strong>window</strong> 对象的属性或者方法，那么它就成为了全局变量，就可以在其他文件中使用了。</p><p>想要达到这个目的，我们可以借助 <strong>expose-loader</strong> ，首先执行以下命令，进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add expose-loader -D</span><br></pre></td></tr></table></figure><p>expose-loader是一个 <strong>内联loader</strong> ，即可以字节在文件中使用，当然也可以在 <strong>webpack.config.js</strong> 配置文件中使用。我们先来讲解如何在文件中使用这一loader。</p><p>现在假设项目中有一个 <strong>index.js</strong> 文件，我们在这个文件中将 <strong>$对象</strong> 暴露给 <strong>window</strong> 对象，使之成为全局变量，那么可以书写以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $<span class="number">1</span> <span class="keyword">from</span> <span class="string">'expose-loader?$!jquery'</span><span class="comment">// 引入jquery对象，并将该对象暴露给window的$属性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log($<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.$);</span><br></pre></td></tr></table></figure><p>可能上面的代码你看着有些头晕，我来讲解一下：</p><ol><li>首先通过 <strong>import</strong> 命令，从安装的jquery包中导入一个对象，将这个对象命名为 <strong>\$1</strong> ，<strong>\$1</strong> 不是全局对象。</li><li>通过 <strong><code>expose-loader?$!jquery</code></strong> 命令，从安装的jquery模块中导入一个对象，将这个对象添加到 <strong>window</strong> 对象的 <strong>\$</strong> 属性上。这样一来，就得到了一个全局变量 <strong>window.\$</strong> ，即 <strong>$</strong> 。</li></ol><p>如果你不喜欢在文件使用内联loader设置全局对象，那么可以在 <strong>webpac.config.js</strong> 文件中，进行配置，配置代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">                test: <span class="built_in">require</span>.resolve(<span class="string">'jquery'</span>),    <span class="comment">// 匹配到引入jquery的文件</span></span><br><span class="line">                use: <span class="string">'expose-loader?$'</span>              <span class="comment">// 使用 expose-loader 进行处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你就可以在 <strong>index.js</strong> 文件中正常地引入jquery包，webpack会来使用 <strong>expose-loader</strong> 自动帮我们暴露全局变量。 <strong>index.js</strong> 文件代码参考如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $<span class="number">1</span> <span class="keyword">from</span> <span class="string">'jquery'</span><span class="comment">// 正常导入jquery包</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log($<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.$);</span><br></pre></td></tr></table></figure><p>这样设置之后，在其他的 <strong>.js</strong> 文件中，就无须再导入jquery，方便快捷。</p><h2 id="4-写在后面"><a href="#4-写在后面" class="headerlink" title="4. 写在后面"></a>4. 写在后面</h2><p>上面介绍了两种设置全局变量的方式，就我个人来说，比较喜欢第一种，大家可以根据需要和喜好，自行选择。</p><p>这就是本篇博客的全部内容了，大家加油，学懂webpack！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-写在前面&quot;&gt;&lt;a href=&quot;#1-写在前面&quot; class=&quot;headerlink&quot; title=&quot;1. 写在前面&quot;&gt;&lt;/a&gt;1. 写在前面&lt;/h2&gt;&lt;p&gt;在做项目的时候，我们可能会经常遇到这种场景：一个变量我在很多文件中都要用到。这变量可能是第三方包，或者是
      
    
    </summary>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门学习笔记07 ——  关于babel的一些补充</title>
    <link href="http://yoursite.com/2019/07/13/webpack%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B007%20%E2%80%94%E2%80%94%20%20%E5%85%B3%E4%BA%8Ebabel%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"/>
    <id>http://yoursite.com/2019/07/13/webpack入门学习笔记07 ——  关于babel的一些补充/</id>
    <published>2019-07-12T16:00:00.000Z</published>
    <updated>2019-12-15T05:25:44.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><p>在之前的一篇博客中：<strong><a href="https://github.com/Fengzhen8023/webpack-learning/blob/master/blog/6.%20%E4%BD%BF%E7%94%A8babel%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91js%E6%96%87%E4%BB%B6.md" target="_blank" rel="noopener">使用babel打包编译js文件</a></strong> ，简单介绍了如果在webpack中使用babel对高级JS语法进行转换，以方便浏览器能够识别。</p><p>但是babel的相关知识很多，不能面面俱到全部讲解，只能将我们项目中经常使用的一些插件或者配置介绍一下。我的目的是抛砖引玉，更多知识大家还是到babel官网学习：<strong><a href="https://babeljs.io/" target="_blank" rel="noopener">https://babeljs.io/</a></strong> 。</p><p>这篇博客中，根据我的学习，对babel做一些补充。随着自己学习的深入，我也会时常跟新这篇博客，完善babel相关的知识点。这篇博客的主要内容如下：</p><ul><li><strong>@babel/plugin-transform-runtime、@babel/runtime</strong> 插件的介绍</li></ul><h2 id="2-babel-plugin-transform-runtime、-babel-runtime插件"><a href="#2-babel-plugin-transform-runtime、-babel-runtime插件" class="headerlink" title="2. @babel/plugin-transform-runtime、@babel/runtime插件"></a>2. @babel/plugin-transform-runtime、@babel/runtime插件</h2><p>首先说一下这两款插件的使用场景，在之前的博客中提到过：babel默认配置的转化能力有限，只能将部分ES6语法转换成ES6语法，如果想要将更高级的ES6语法或者ES7等语法转成低级语法，需要进行额外的配置。</p><p>熟悉ES6语法的程序员肯定了解ES6语法中的 <strong>Generator 函数</strong> 和 <strong>Promise 对象</strong> ，并且在项目中也会使用到这些高级语法。比如以下语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generator().next(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'generator 执行完毕'</span>);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>那么问题来了，当你打包编译项目之后，在浏览器端运行的时候，会发现控制台报错了：</p><p><img src="https://upload-images.jianshu.io/upload_images/3879603-2b78e688ff596b0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这是因为babel的默认配置不支持转换这些高级语法，如果需要达到这个目的，就需要安装配置额外的插件，也就是我们现在提到的<strong>@babel/plugin-transform-runtime、@babel/runtime</strong> 插件。下面说一下如何安装配置：</p><p>首先安装 <strong>@babel/plugin-transform-runtime</strong> ，这是一个开发依赖，打包之后不需要这个包，所以执行下面的命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @babel/plugin-transform-runtime -D</span><br></pre></td></tr></table></figure><p>然后安装 <strong>@babel/runtime</strong> ，需要说明的是，这是运行环境中所需要的依赖包，打包编译之后还是也是需要它的，所以执行下面的命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @babel/runtime</span><br></pre></td></tr></table></figure><p>安装完成之后进行配置，配置的时候在上一篇博客配置babel的基础上进行配置即可，这里给出部分代码，具体的配置可以参考上一篇博客：<strong><a href="https://github.com/Fengzhen8023/webpack-learning/blob/master/blog/6.%20%E4%BD%BF%E7%94%A8babel%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91js%E6%96%87%E4%BB%B6.md" target="_blank" rel="noopener">使用babel打包编译js文件</a></strong> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presets: [</span><br><span class="line">                        <span class="string">'@babel/preset-env'</span>     <span class="comment">// 预设，将ES6转成ES5</span></span><br><span class="line">                    ],</span><br><span class="line">                    plugins: [</span><br><span class="line">                        <span class="string">'@babel/plugin-proposal-class-properties'</span>,   </span><br><span class="line">                        <span class="string">'@babel/plugin-transform-runtime'</span><span class="comment">// 配置运行时的转换插件</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            include: path.resolve(__dirname, <span class="string">'src'</span>)  <span class="comment">// 只转换src目录下的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行如上配置之后，就可以顺利运行项目中的  <strong>Generator 函数</strong> 和 <strong>Promise 对象</strong> 等语法了。</p><p>这里提一句：上面配置中的 <strong>include</strong> ，表示只对 <strong>src目录</strong> 下的 <strong>.js</strong> 文件进行匹配。除此之外，还可以使用 <strong>exclude</strong> 进行显示，表示匹配出这些文件夹之外的 <strong>.js</strong> 文件，支持使用正则表达式，比如：<code>exclude: /node_modules/</code> 。</p><h2 id="3-写在后面"><a href="#3-写在后面" class="headerlink" title="3. 写在后面"></a>3. 写在后面</h2><p>以上就是本篇博客的全部内容，随和后面学习的升入，博客会被时常更新，错误之处，还希望各位大神指出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-写在前面&quot;&gt;&lt;a href=&quot;#1-写在前面&quot; class=&quot;headerlink&quot; title=&quot;1. 写在前面&quot;&gt;&lt;/a&gt;1. 写在前面&lt;/h2&gt;&lt;p&gt;在之前的一篇博客中：&lt;strong&gt;&lt;a href=&quot;https://github.com/Fengzh
      
    
    </summary>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门学习笔记01 —— webpack基本简介</title>
    <link href="http://yoursite.com/2019/06/30/webpack%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B006%20%E2%80%94%E2%80%94%20%E4%BD%BF%E7%94%A8babel%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91js%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/06/30/webpack入门学习笔记06 —— 使用babel打包编译js文件/</id>
    <published>2019-06-29T16:00:00.000Z</published>
    <updated>2019-12-15T05:25:44.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><p>在前端项目中，占主导地位的文件，我想应该是 <strong>.js</strong> 文件。随着 <strong>JS语言</strong> 的不断升级改进，越来越多的高级语法被加入到该语言中，比如我们熟知的 <strong>ES6语法、ES7语法</strong> 等。</p><p>虽然  <strong>ES6语法、ES7语法</strong> 我们写起来感觉非常方便，但是目前市面上的浏览器却不认识这些语法，这就导致我们辛辛苦苦做出来的项目却不能运行，让人很抓狂。这个时候我们要怎么办呢？</p><p>办法肯定是有的，我们可以借助webpack这一工具，来将这些高级语法，转换成浏览器能够识别的低级语法（如ES5语法），这样就可以使项目正常运行了。而webpack之所以能够做到这一点，是因为它使用了 <strong>babel</strong> 这一工具。这是一个什么工具呢？这篇博客就会来讲解。</p><p>为了方便不同的读者都能从这篇博客中有所收获，本篇博客准备在前半部分介绍如何在webpack中配置 <strong>babel</strong> 来编译转换高版本语法，在后半部分会讲解关于 <strong>babel</strong> 的知识。大家各取所需，根据自己的实际情况来选择阅读哪一部分。</p><h2 id="2-在webpack中配置babel，编译高本版JS语法"><a href="#2-在webpack中配置babel，编译高本版JS语法" class="headerlink" title="2. 在webpack中配置babel，编译高本版JS语法"></a>2. 在webpack中配置babel，编译高本版JS语法</h2><p>既然要使用 <strong>babel</strong> 我们就要先安装这些依赖包，这里我们需要安装三个包：<strong>babel-loader 、 @babel/core 、 @babel/preset-env</strong> ，安装命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add babel-loader @babel/core @babel/preset-env -D</span><br></pre></td></tr></table></figure><p>简单介绍一下这是三个包的：<strong>babel-loader</strong> 和 <strong>@babel/core</strong> 是核心插件。<strong>@babel/preset-env</strong> 是babel的 <strong>预设</strong> ，它的主要功能是将 <strong>ES6</strong> 语法转成 <strong>ES5</strong> 语法。</p><p>依赖包安装完成之后，要到 <strong>webpack.config.js</strong> 文件中进行配置，配置的步骤和前面博客中讲述的配置 <strong>.css</strong> 文件的步骤类似，这里直接给出配置代码（重点关注有注释的部分）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">let</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>)</span><br><span class="line"><span class="keyword">let</span> MiniCssExtract = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        port: <span class="number">3000</span>,  </span><br><span class="line">        progress: <span class="literal">true</span>,  </span><br><span class="line">        contentBase: <span class="string">"./build"</span>,  </span><br><span class="line">        compress: <span class="literal">true</span>  </span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">"development"</span>,  </span><br><span class="line">    entry: <span class="string">"./src/index.js"</span>,  </span><br><span class="line">    output: &#123;  </span><br><span class="line">        filename: <span class="string">"index.js"</span>,  </span><br><span class="line">        path: path.resolve(__dirname, <span class="string">"build"</span>)  </span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">            filename: <span class="string">'index.html'</span>,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                removeAttributeQuotes: <span class="literal">true</span>,</span><br><span class="line">                collapseWhitespace: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            hash: <span class="literal">true</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtract(&#123;</span><br><span class="line">            filename: <span class="string">'main.css'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtract.loader,</span><br><span class="line">                    <span class="string">'css-loader'</span>,</span><br><span class="line">                    <span class="string">'postcss-loader'</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtract.loader,</span><br><span class="line">                    <span class="string">'css-loader'</span>,</span><br><span class="line">                    <span class="string">'less-loader'</span>,</span><br><span class="line">                    <span class="string">'postcss-loader'</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,      <span class="comment">// 匹配js文件，然后用下面所配置的工具对这些文件进行编译处理</span></span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: <span class="string">'babel-loader'</span>,     <span class="comment">// babel的核心模块</span></span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [              <span class="comment">// 配置babel的预设，将ES语法转成ES5语法</span></span><br><span class="line">                            <span class="string">'@babel/preset-env'</span></span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成之后，我们就可以在项目中使用 <strong>ES6</strong> 语法来编写项目了。注意我这里说的是 <strong>ES6</strong> 语法，如果在项目中你使用了更新的 <strong>ES7</strong> 语法，仅靠上面的配置是不行的，在你进行打包编译的时候会报错，比如在项目中使用了以下的 <strong>ES7</strong> 语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    className = <span class="string">'A'</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure><p>这个时候再进行打包编译的时候，会报错以下错误：根据提示，是因为我们没有安装所需要的依赖包。</p><p><img src="http://q1d2135zd.bkt.clouddn.com//webpack-06-01.png" alt></p><p>道理很简单，仅靠上面书写的 <strong>babel</strong> 配置，只能转换 <strong>ES6</strong> 语法，如果要转换更高版本的语法，就要进行其他配置，比如这里转换 <strong>ES7</strong> 语法。</p><p>根据提示，我们需要安装所需的包：<strong>@babel/plugin-proposal-class-properties</strong> ，安装代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @babel/plugin-proposal-class-properties -D</span><br></pre></td></tr></table></figure><p>安装完成之后，修改 <strong>webpack.config.js</strong> 文件中的 <strong>babel</strong> 配置，修改后的代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">            presets: [</span><br><span class="line">                <span class="string">'@babel/preset-env'</span></span><br><span class="line">            ],</span><br><span class="line">            plugins: [<span class="comment">// 配置babel插件，转换更更高版本语法</span></span><br><span class="line">                <span class="string">'@babel/plugin-proposal-class-properties'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，如果你在项目中使用了其他的高级语法，比如 <strong>装饰器</strong> ，那么也是需要额外配置的，这里就不一一阐述，到时候你可根据webpack的报错信息，进行查找配置即可。</p><p>到这里webpack打包编译 <strong>.js</strong> 文件的相关知识已经讲完，下面结合自己的认识，介绍一些 <strong>babel</strong> 的知识。</p><h2 id="3-babel是个什么东西"><a href="#3-babel是个什么东西" class="headerlink" title="3. babel是个什么东西"></a>3. babel是个什么东西</h2><p>首先列出babel的中文官网，更多知识可查阅该官网：<strong><a href="https://www.babeljs.cn/" target="_blank" rel="noopener">https://www.babeljs.cn/</a></strong>  。</p><p>根据官网的定义：Babel 是一个 <strong>工具链</strong> ，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。 在具体的实践中，babel可以帮我们做一下事情：</p><ul><li>语法转换</li><li>通过 Polyfill 方式在目标环境中添加缺失的特性 (通过 <a href="https://www.babeljs.cn/docs/babel-polyfill" target="_blank" rel="noopener">@babel/polyfill</a> 模块)</li><li>源码转换 (codemods)</li><li>更多 …</li></ul><p>对于前端小白来说，上面的文字还不足以帮助他们了解babel，下面我用大白话来说一下：我们将babel类比成手机上使用的 <strong>中英词典APP</strong>。</p><p>我们知道，手机上安装的 <strong>中英词典APP</strong> 可以帮助我们将不认识的英文翻译成我们熟知的汉语，这样我们就可以理解单词和句子表达的意义了。类似，<strong>babel</strong> 可以将我们写的 <strong>ES6</strong> 语法翻译成浏览器熟悉的 <strong>ES5</strong> 语法，这样，浏览器就可以知道这些 <strong>JS</strong> 代码要做什么事情了。比如下面的例子：</p><p><img src="http://q1d2135zd.bkt.clouddn.com//webpack-06-02.png" alt></p><p><strong>中英词典APP</strong> 在我们安装之初，就可以将英文成中文，是因为开发程序员在这个APP中预先设置了中英翻译功能。同理，<strong>babel</strong> 在配置之初就可以将 <strong>ES6</strong> 语法翻译成 <strong>ES5</strong> 语法，是因为我们在配置之初，给 <strong>babel</strong> 指定了 <strong>预设（presets）</strong> ，才使得 <strong>babel</strong> 可以做到这一点。</p><p>默认状态下，<strong>中英词典APP</strong> 可以将英语翻译成汉语，但是不能将俄语翻译成汉语，因为程序员在开发之前，没有预先设置这个功能，如果我们想要这款APP也可以翻译俄语，那么就需要下载额外的 <strong>俄语翻译扩展包</strong> ，下载完成之后，就可以实现这个功能。</p><p>同理，在默认配置下， <strong>babel</strong> 可以将 <strong>ES6</strong> 翻译成 <strong>ES5</strong> ，但是不能将 <strong>ES7</strong> 翻译成 <strong>ES5</strong>。这是因为在 <strong>babel</strong> 中有将 <strong>ES6</strong> 翻译成 <strong>ES5</strong> 的 <strong>预设（presets）</strong> ，没有将 <strong>ES7</strong> 翻译成 <strong>ES5</strong> 的 <strong>预设（presets）</strong> 。如果要实现这个功能，我们就需要下载配置额外的 <strong>插件</strong>，比如第一节提到的 <strong>@babel/plugin-proposal-class-properties</strong> 。<strong>插件</strong> 配置下载配置完成之后，就可以将 <strong>ES7</strong> 等更高级语法翻译成 <strong>ES5</strong> 语法。</p><p>通过babel的中文官网，我们可以看到对于不同版本的语法，有不同的插件。相当于在 <strong>中英词典APP</strong> 中，对于不同的语言，有不同的扩展包，需要什么扩展包，我们下载即可。</p><p><img src="http://q1d2135zd.bkt.clouddn.com//webpack-06-03.png" alt></p><p>根据个人的经验，在使用这些插件的时候，项目开发之初不用配置。在打包编译的时候，如果报错了，再根据报错信息，查看缺少什么插件，然后再进行配置即可。当然，如果你经验很丰富，一开始就知道要使用那些插件，那么肯定要提前配置，</p><h2 id="4-写在最后"><a href="#4-写在最后" class="headerlink" title="4. 写在最后"></a>4. 写在最后</h2><p>好了，以上就是本篇博客的所有内容了，只是个人学习过程中的一些心得体会，如果有不当的地方，还希望各位大神给出指点。</p><p>如果你想深入学习 <strong>babel</strong> ，可以看他们官网的文档，个人觉得还是非常详细的：<strong><a href="https://www.babeljs.cn/docs/" target="_blank" rel="noopener">https://www.babeljs.cn/docs/</a></strong> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-写在前面&quot;&gt;&lt;a href=&quot;#1-写在前面&quot; class=&quot;headerlink&quot; title=&quot;1. 写在前面&quot;&gt;&lt;/a&gt;1. 写在前面&lt;/h2&gt;&lt;p&gt;在前端项目中，占主导地位的文件，我想应该是 &lt;strong&gt;.js&lt;/strong&gt; 文件。随着 &lt;st
      
    
    </summary>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
