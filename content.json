{"meta":{"title":"Fengzhen8023","subtitle":"fengzhen8023","description":"share, technology, App, Fron-end, JS, Vue, React","author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"webpack入门学习笔记14 —— Webpack的源码映射","slug":"webpack入门学习笔记14 —— Webpack的源码映射","date":"2019-12-15T05:25:44.809Z","updated":"2019-12-15T05:25:44.810Z","comments":true,"path":"2019/12/15/webpack入门学习笔记14 —— Webpack的源码映射/","link":"","permalink":"http://yoursite.com/2019/12/15/webpack入门学习笔记14 —— Webpack的源码映射/","excerpt":"","text":"1. 写在前面Webpack作为一个功能强大的构建工具，能够对我们书写的代码进行打包编译，从而生成一系列新的代码文件，使得项目能够够在浏览器中正常渲染。 Webpack在工作的过程中，会对代码进行打包编译，这就会带来一个问题：如果项目中代码错误，浏览器中的报错提示，定位到的是打包编译后的代码，而不是我们在项目中实际书写的代码，比如以下报错： 对于这种报错，如果是简单的项目还好。但是如果项目稍微复杂一点，开发人员进行调试程序，会变得非常困难。开发人员所期望看到的报错信息是这样的： 如果是这样的报错信息，那么我们就可以快速定位到错误代码的位置，从而快速修复。想要达到这个目的，我们需要这么做呢？这篇博客就和大家分享一下这方面的知识，即webpack中的 源码映射。 2. 配置devtool属性，进行源码映射配置webpack的源码映射非常简单，直接在 webpack.config.js 文件中指定 devtool 属性即可，下面给出配置的实例： 1234module.exports = &#123; /* 节省篇幅，其余配置已省略 */ devtool: \"eval-source-map\",&#125; 这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 GitHub仓库 - webpack-learning ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。 这里简单介绍下这个属性： devtool是开发工具，它的作用是生成源代码映射(Source Map)，方便调试 源代码映射记录了打包编译后的代码和源代码之间的位置对应关系。它可以让你在控制台查找日志（或错误）来源时，直接跳转到源代码中，而不是打包编译后的代码 该属性常使用的值有以下几个： source-map： 会产生单独的映射文件，控制台中的错误信息会定位到代码错误的文件，并且会定位到这文件的第几行第几列。帮助我们调试源代码。 eval-source-map： 不会产生单独的映射文件，但是控制台中的错误信息会定位到代码错误的文件，并且会定位到这文件的第几行第几列。 cheap-module-source-map： 会产生单独的映射文件，控制台中国的错误信息会定位到代码出错的文件，但是只能定位到第几行出错，不能定位到第几列。 cheap-module-eval-source-map： 不会产生单独的映射文件，控制台中国的错误信息会定位到代码出错的文件，但是只能定位到第几行出错，不能定位到第几列。这个模式构件速度适中，而且会生成较好的源代码映射，适合在开发环境中使用 。 3. 写在最后以上就是这篇博客的全部内容，希望对刚刚接触Webpack的同学有所帮助。","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}]},{"title":"React Router V5 翻译文档1：快速开始","slug":"React Router V5 翻译文档1：快速开始","date":"2019-12-14T16:10:00.000Z","updated":"2019-12-15T06:33:47.801Z","comments":true,"path":"2019/12/15/React Router V5 翻译文档1：快速开始/","link":"","permalink":"http://yoursite.com/2019/12/15/React Router V5 翻译文档1：快速开始/","excerpt":"","text":"转载说明原翻译作者：https://www.jianshu.com/u/5d660a479013原官网文档：https://reacttraining.com/react-router/web/guides/quick-start 快速开始你需要一个React web app 来添加react-router。 如果你需要创建一个新的React Web App,最容易的方式是通过一个叫做create-react-app的官方脚手架来创建。 第一步是先来安装create-react-app,如果你以及安装过这个工具，那么可以直接使用她来创建一个新的项目。 123npm install -g create-react-appcreate-react-app demo-appcd demo-app 安装React Router Dom 已经被发布到来npm上, 所以你可以用npm或yarn来安装她。1npm install react-router-dom 示例：基础路由在这个例子中，我们会使用来构建一个拥有3个页面的示例。注意: 我们用 &lt; Link to=”/“&gt; 来代替 &lt; a href=”/“&gt; 把下方的代码复制到demo-app里面的src目录下的App.js文件中123456789101112131415161718192021222324252627282930313233343536373839404142import React from \"react\";import &#123; BrowserRouter as Router, Route, Link &#125; from \"react-router-dom\";function Index() &#123; return &lt;h2&gt;Home&lt;/h2&gt;;&#125;function About() &#123; return &lt;h2&gt;About&lt;/h2&gt;;&#125;function Users() &#123; return &lt;h2&gt;Users&lt;/h2&gt;;&#125;function AppRouter() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about/\"&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/users/\"&gt;Users&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;Route path=\"/\" exact component=&#123;Index&#125; /&gt; &lt;Route path=\"/about/\" component=&#123;About&#125; /&gt; &lt;Route path=\"/users/\" component=&#123;Users&#125; /&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;export default AppRouter; 示例：嵌套路由这个示例向我们展示来嵌套路由如何工作，路由 ‘/topics’会加载Topics组件，这个组件会通过’:id’的路由来渲染出更多的内容。 把下方的代码复制到demo-app里面的src目录下的App.js文件中12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React from \"react\";import &#123; BrowserRouter as Router, Route, Link &#125; from \"react-router-dom\";function App() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;Header /&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/topics\" component=&#123;Topics&#125; /&gt; &lt;/div&gt; &lt;/Router&gt; );&#125;function Home() &#123; return &lt;h2&gt;Home&lt;/h2&gt;;&#125;function About() &#123; return &lt;h2&gt;About&lt;/h2&gt;;&#125;function Topic(&#123; match &#125;) &#123; return &lt;h3&gt;Requested Param: &#123;match.params.id&#125;&lt;/h3&gt;;&#125;function Topics(&#123; match &#125;) &#123; return ( &lt;div&gt; &lt;h2&gt;Topics&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;match.url&#125;/components`&#125;&gt;Components&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;match.url&#125;/props-v-state`&#125;&gt;Props v. State&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:id`&#125; component=&#123;Topic&#125; /&gt; &lt;Route exact path=&#123;match.path&#125; render=&#123;() =&gt; &lt;h3&gt;Please select a topic.&lt;/h3&gt;&#125; /&gt; &lt;/div&gt; );&#125;function Header() &#123; return ( &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about\"&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/topics\"&gt;Topics&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; );&#125;export default App;","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"React Router","slug":"React-Router","permalink":"http://yoursite.com/tags/React-Router/"}],"keywords":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}]},{"title":"React Router V5 翻译文档2：基础组件","slug":"React Router V5 翻译文档2：基础组件","date":"2019-12-14T16:09:00.000Z","updated":"2019-12-15T06:33:47.801Z","comments":true,"path":"2019/12/15/React Router V5 翻译文档2：基础组件/","link":"","permalink":"http://yoursite.com/2019/12/15/React Router V5 翻译文档2：基础组件/","excerpt":"","text":"转载说明原翻译作者：https://www.jianshu.com/u/5d660a479013原官网文档：https://reacttraining.com/react-router/web/guides/quick-start 基础组件React Router包含三种类型的组件： 路由组件，路由匹配组件，导航组件。 在你使用这些组件前，都必须从react-router-dom导入她们。1import &#123; BrowserRouter, Route, Link &#125; from \"react-router-dom\"; 路由组件任何一个拥有路由跳转功能都React应用都核心都必须是一个路由组件。对于Web项目来说，react-router-dom提供了&lt; BrowserRouter &gt;和&lt; HashRouter &gt;这两种路由。她们会为你创建一个专业的history对象。通常来说，如果你有一个服务器来响应请求，那就使用&lt; BrowserRouter &gt;。如果你是用静态文件来提供服务，那么就使用 &lt; HashRouter &gt;1234567import &#123; BrowserRouter &#125; from \"react-router-dom\";ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, holder); 路由匹配组件路由匹配组件有两种：&lt; Route &gt;和&lt; Switch &gt;路由匹配组件通过比较&lt; Route &gt;的path属性和当前页面地址栏的路径来工作。当一个&lt; Route &gt;匹配成功的时候，她会渲染出对应的内容，当匹配不成功的时候，任何内容都不会被渲染出来。当一个&lt; Route &gt;没有path属性时她对任何路径都会匹配成功。你可以在你想要根据浏览器地址来渲染内容的任何地方使用&lt; Route &gt;,但是我们通常会把一组&lt; Route &gt;放在一起。&lt; Switch &gt;就是用来把多个&lt; Route &gt;组合在一起的。我们不是必须要用&lt; Switch &gt;把多个&lt; Route &gt;组合在一起，但是这种做法通常是有用的。 &lt; Switch &gt;将迭代其所有子&lt; Route &gt;元素，并仅渲染与当前路径匹配的第一个子元素。 她对于多个path匹配相同的路径、动画路由之间的转换、没有路径匹配时的识别（这样你就可以渲染“404”组件）是有很大帮助的。12345678910111213141516171819import &#123; Route, Switch &#125; from \"react-router-dom\";// when location = &#123; pathname: '/about' &#125;&lt;Route path='/about' component=&#123;About&#125;/&gt; // renders &lt;About/&gt;&lt;Route path='/contact' component=&#123;Contact&#125;/&gt; // renders null&lt;Route component=&#123;Always&#125;/&gt; // renders &lt;Always/&gt;&lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/contact\" component=&#123;Contact&#125; /&gt;&lt;/Switch&gt;&lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/contact\" component=&#123;Contact&#125; /&gt; &#123;/* when none of the above match, &lt;NoMatch&gt; will be rendered */&#125; &lt;Route component=&#123;NoMatch&#125; /&gt;&lt;/Switch&gt; 路由渲染属性对于一个&lt; Route &gt;组件，你可以设置三种属性：component, render, children 来渲染出相应的内容。在这里我们只关注component和render,因为她们是经常会用到的，更多的内容可以查看&lt; Route &gt;的API文档。 当你有一个已存在的组件（无论是一个React组件还是一个无状态的函数组件）想要渲染时应该使用component。当你必须传递一些参数变量给组件时应该用render属性，她采用内联函数的形式。你不应该使用component属性来渲染一个带有参数变量的内联函数组件，这会导致不必要的组件的挂载和卸载。123456789101112131415161718192021const Home = () =&gt; &lt;div&gt;Home&lt;/div&gt;;const App = () =&gt; &#123; const someVariable = true; return ( &lt;Switch&gt; &#123;/* these are good */&#125; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" render=&#123;props =&gt; &lt;About &#123;...props&#125; extra=&#123;someVariable&#125; /&gt;&#125; /&gt; &#123;/* do not do this */&#125; &lt;Route path=\"/contact\" component=&#123;props =&gt; &lt;Contact &#123;...props&#125; extra=&#123;someVariable&#125; /&gt;&#125; /&gt; &lt;/Switch&gt; );&#125;; 导航组件React Router 提供了&lt; Link &gt;组件用来在你的应用中创建超链接。&lt; Link &gt;会在页面的任何地方被渲染成&lt; a &gt;标签 &lt; NavLink &gt;是一种特殊的&lt; Link &gt;组件，当她的to属性匹配地址栏的路径时，她渲染成的&lt; a &gt;标签会带有’active’的样式。 如果你想要强制跳转，你可以使用&lt; Redirect &gt;。当一个&lt; Redirect &gt;组件被渲染时，她会导航到其to属性匹配的路径。12345678910&lt;Link to=\"/\"&gt;Home&lt;/Link&gt;// &lt;a href='/'&gt;Home&lt;/a&gt;// location = &#123; pathname: '/react' &#125;&lt;NavLink to=\"/react\" activeClassName=\"hurray\"&gt; React&lt;/NavLink&gt;// &lt;a href='/react' className='hurray'&gt;React&lt;/a&gt;&lt;Redirect to=\"/login\" /&gt;","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"React Router","slug":"React-Router","permalink":"http://yoursite.com/tags/React-Router/"}],"keywords":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}]},{"title":"React Router V5 翻译文档3：服务端渲染","slug":"React Router V5 翻译文档3：服务端渲染","date":"2019-12-14T16:08:00.000Z","updated":"2019-12-15T06:33:47.801Z","comments":true,"path":"2019/12/15/React Router V5 翻译文档3：服务端渲染/","link":"","permalink":"http://yoursite.com/2019/12/15/React Router V5 翻译文档3：服务端渲染/","excerpt":"","text":"转载说明原翻译作者：https://www.jianshu.com/u/5d660a479013原官网文档：https://reacttraining.com/react-router/web/guides/quick-start 服务端渲染由于服务端是无状态的，所以服务端渲染和客户端渲染并不相同. 最基本的就是我们封装app时, 使用无状态的 &lt; StaticRouter &gt;来代替&lt; BrowserRouter &gt;, 使用来自于服务端的请求url来匹配路由。接下来我们会讨论 context 属性123456789101112// client&lt;BrowserRouter&gt; &lt;App/&gt;&lt;/BrowserRouter&gt;// server (not the complete story)&lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt; &lt;App/&gt;&lt;/StaticRouter&gt; 当你在客户端渲染 &lt; Redirect &gt;, 浏览器地址栏会改变状态使我们能看到新的页面,然而在一个静态的服务环境下, 我们不能够改变app的状态。代替的是, 我们将渲染的结果赋给context属性. 如果我们找到了 context.url, 那么我们知道这个app重定向了. 这允许我们向服务端发送一个重定向请求12345678910111213141516const context = &#123;&#125;const markup = ReactDOMServer.renderToString( &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125; &gt; &lt;App/&gt; &lt;/StaticRouter&gt;)if (context.url) &#123; // Somewhere a `&lt;Redirect&gt;` was rendered redirect(301, context.url)&#125; else &#123; // we're good, send the response&#125; 添加明确的应用内容信息路由只能添加 context.url. 但是你可能想要发送重定向的301或302的响应。或许你在某些特殊的UI渲染后需要发送一个404响应, 又或者在客户端没有认证的情况下发送401。 context属性是属于你的, 所以你可以任意改变她. 下面是分辨301与302重定向的方法。1234567891011121314151617181920212223242526272829303132333435363738394041const RedirectWithStatus = (&#123; from, to, status &#125;) =&gt; ( &lt;Route render=&#123;(&#123; staticContext &#125;) =&gt; &#123; // there is no `staticContext` on the client, so // we need to guard against that here if (staticContext) staticContext.status = status return &lt;Redirect from=&#123;from&#125; to=&#123;to&#125;/&gt; &#125;&#125;/&gt;)// somewhere in your appconst App = () =&gt; ( &lt;Switch&gt; &#123;/* some other routes */&#125; &lt;RedirectWithStatus status=&#123;301&#125; from=\"/users\" to=\"/profiles\" /&gt; &lt;RedirectWithStatus status=&#123;302&#125; from=\"/courses\" to=\"/dashboard\" /&gt; &lt;/Switch&gt;)// on the serverconst context = &#123;&#125;const markup = ReactDOMServer.renderToString( &lt;StaticRouter context=&#123;context&#125;&gt; &lt;App/&gt; &lt;/StaticRouter&gt;)if (context.url) &#123; // can use the `context.status` that // we added in RedirectWithStatus redirect(context.status, context.url)&#125; 404, 401, 或其他状态我们现在可以做到和上面一样的事，创建一个包含想要内容的组件，当收到不同的的状态码时可以在应用的任何地方渲染该组件。12345678910function Status(&#123; code, children &#125;) &#123; return ( &lt;Route render=&#123;(&#123; staticContext &#125;) =&gt; &#123; if (staticContext) staticContext.status = code; return children; &#125;&#125; /&gt; );&#125; 现在，当你想要给静态内容添加一个状态码时，你可以在应用的任何地方渲染一种状态。12345678910111213141516function NotFound() &#123; return ( &lt;Status code=&#123;404&#125;&gt; &lt;div&gt; &lt;h1&gt;Sorry, can’t find that.&lt;/h1&gt; &lt;/div&gt; &lt;/Status&gt; );&#125;// somewhere else&lt;Switch&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/dashboard\" component=&#123;Dashboard&#125; /&gt; &lt;Route component=&#123;NotFound&#125; /&gt;&lt;/Switch&gt;; 组合所有内容虽然这不是一个真正的应用，但是她展现了将所有内容组合在一起所需的常规部分12345678910111213141516171819202122232425262728293031import &#123; createServer &#125; from 'http'import React from 'react'import ReactDOMServer from 'react-dom/server'import &#123; StaticRouter &#125; from 'react-router'import App from './App'createServer((req, res) =&gt; &#123; const context = &#123;&#125; const html = ReactDOMServer.renderToString( &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125; &gt; &lt;App/&gt; &lt;/StaticRouter&gt; ) if (context.url) &#123; res.writeHead(301, &#123; Location: context.url &#125;) res.end() &#125; else &#123; res.write(` &lt;!doctype html&gt; &lt;div id=\"app\"&gt;$&#123;html&#125;&lt;/div&gt; `) res.end() &#125;&#125;).listen(3000) 然后是客户端123456789import ReactDOM from 'react-dom'import &#123; BrowserRouter &#125; from 'react-router-dom'import App from './App'ReactDOM.render(( &lt;BrowserRouter&gt; &lt;App/&gt; &lt;/BrowserRouter&gt;), document.getElementById('app')) 数据加载要做到这一点有很多不同的方法，对此并没有最佳的实践。所以我们寻求多种方法的不同组合方式，而不是规定或倾向某一种。我们相信React Router可以在你的应用的规则限制下找到一种合理的方式。 最主要的约束是你希望在页面渲染前加载完数据。React Router暴露了一个matchPath静态函数，你可以用她来进行路由匹配。你可以在服务端用这个函数来确定哪些依赖的数据是要在渲染前完成的。 这种方法的特点是在进行实际跳转前设定好静态匹配规则，在实际跳转前就已经知道要使用哪些数据。1234567const routes = [ &#123; path: '/', component: Root, loadData: () =&gt; getSomeData(), &#125;, // etc.] 然后使用这些规则在应用中渲染你的路由123456789import &#123; routes &#125; from './routes'const App = () =&gt; ( &lt;Switch&gt; &#123;routes.map(route =&gt; ( &lt;Route &#123;...route&#125;/&gt; ))&#125; &lt;/Switch&gt;) 在服务端你可能会做这些；123456789101112131415161718import &#123; matchPath &#125; from 'react-router-dom'// inside a requestconst promises = []// use `some` to imitate `&lt;Switch&gt;` behavior of selecting only// the first to matchroutes.some(route =&gt; &#123; // use `matchPath` here const match = matchPath(req.url, route) if (match) promises.push(route.loadData(match)) return match&#125;)Promise.all(promises).then(data =&gt; &#123; // do something w/ the data so the client // can access it then render the app&#125;) 最后，客户端需要获取数据。我们并不是给你的应用规定数据加载的模式，但这些是在开发中常用的形式。 你可能会对我们的进行数据加载和静态路由配置的React Router Config包感兴趣。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"React Router","slug":"React-Router","permalink":"http://yoursite.com/tags/React-Router/"}],"keywords":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}]},{"title":"React Router V5 翻译文档4：代码拆分","slug":"React Router V5 翻译文档4：代码拆分","date":"2019-12-14T16:07:00.000Z","updated":"2019-12-15T06:33:47.802Z","comments":true,"path":"2019/12/15/React Router V5 翻译文档4：代码拆分/","link":"","permalink":"http://yoursite.com/2019/12/15/React Router V5 翻译文档4：代码拆分/","excerpt":"","text":"转载说明原翻译作者：https://www.jianshu.com/u/5d660a479013原官网文档：https://reacttraining.com/react-router/web/guides/quick-start 代码拆分Web应用一个非常出色的特性就是我们不必下载整个应用就可以使用。你可以认为代码拆分是逐渐递增的加载我们的应用。在这里，我们使用webpack, @babel/plugin-syntax-dynamic-import,和loadable-components来实现。 webpack内置了对动态导入的支持; 但是，如果你使用Babel（例如，将JSX编译为JavaScript），那么你将需要同时使用@ babel / plugin-syntax-dynamic-import插件。 这是一个仅只进行语法解析的插件，这意味着Babel不会进行任何其他转换。 该插件只允许Babel解析动态导入，因此webpack可以将它们打包成不同的代码模块。 你的.babelrc应该是这样的：1234&#123; \"presets\": [\"@babel/preset-react\"], \"plugins\": [\"@babel/plugin-syntax-dynamic-import\"]&#125; loadable-components是一个用于加载具有动态导入功能的组件的库。 她会自动处理各种边缘情况，使代码拆分变得简单，以下是如何使用loadable-components的示例：123456789101112import loadable from '@loadable/component'import Loading from \"./Loading\";const LoadableComponent = loadable(() =&gt; import('./Dashboard'), &#123; fallback: Loading,&#125;)export default class LoadableDashboard extends React.Component &#123; render() &#123; return &lt;LoadableComponent /&gt;; &#125;&#125; 只需使用LoadableDashboard（或任何你自定义的组件），当你在应用程序中使用它时，它将自动加载和渲染。在实际组件加载时，fallback是一种占位的组件。此处提供了完整的文档 代码拆分和Server-Side渲染loadable-components包含了server-side渲染的引导。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"React Router","slug":"React-Router","permalink":"http://yoursite.com/tags/React-Router/"}],"keywords":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}]},{"title":"React Router V5 翻译文档5：滚动恢复","slug":"React Router V5 翻译文档5：滚动恢复","date":"2019-12-14T16:06:00.000Z","updated":"2019-12-15T06:33:47.801Z","comments":true,"path":"2019/12/15/React Router V5 翻译文档5：滚动恢复/","link":"","permalink":"http://yoursite.com/2019/12/15/React Router V5 翻译文档5：滚动恢复/","excerpt":"","text":"转载说明原翻译作者：https://www.jianshu.com/u/5d660a479013原官网文档：https://reacttraining.com/react-router/web/guides/quick-start 滚动恢复在早期的React Router版本中，我们为滚动恢复提供了开箱即用的支持，从那时起开发者就一直在使用。希望本文档可以帮助你获取你需要的滚动条和路由的内容。 浏览器已经开始使用history.pushState自己处理滚动恢复，这就像她们以前使用普通浏览器导航一样处理滚动恢复。现在这个很酷的特性已经在Chrome中被支持了。 因为浏览器开始处理“默认情况”，并且不同的应用程序具有不同的滚动需求（就像本站这样），所以我们不提供默认的滚动管理。但是本指南应该可以帮助你实现任何滚动需求。 滚动到顶部大多数情况下，你需要的是“滚动到顶部”这个功能，因为大部分情况是有一个包含了大量内容的长页面。使用组件可以直接处理这中情况，该组件将会实现在每个导航上滚动窗口到顶部，你需要确保使用withRouter封装该组件以使其能够访问路由器的props。12345678910111213class ScrollToTop extends Component &#123; componentDidUpdate(prevProps) &#123; if (this.props.location.pathname !== prevProps.location.pathname) &#123; window.scrollTo(0, 0); &#125; &#125; render() &#123; return this.props.children; &#125;&#125;export default withRouter(ScrollToTop); 然后将其渲染在应用的顶部123456789101112function App() &#123; return ( &lt;Router&gt; &lt;ScrollToTop&gt; &lt;App /&gt; &lt;/ScrollToTop&gt; &lt;/Router&gt; );&#125;// or just render it bare anywhere you want, but just one :)&lt;ScrollToTop /&gt;; 如果你有一个连接到路由的tab选项卡，那么你可能不希望在切换标签时滚动到顶部。此时可以使用。123456789101112131415161718192021class ScrollToTopOnMount extends Component &#123; componentDidMount() &#123; window.scrollTo(0, 0); &#125; render() &#123; return null; &#125;&#125;class LongContent extends Component &#123; render() &#123; &lt;div&gt; &lt;ScrollToTopOnMount /&gt; &lt;h1&gt;Here is my long content page&lt;/h1&gt; &lt;/div&gt;; &#125;&#125;// somewhere else&lt;Route path=\"/long-content\" component=&#123;LongContent&#125; /&gt;; 通用解决方案对于通用解决方案（以及浏览器开始本地实现）我们谈论两件事： 导航跳转时自动滚动到页面顶部，这样不会出现创建一个新的页面滚动条在底部。 在前进或后退时保留原来滚动条的位置（不包含点击跳转链接） 对于第一点我们想要发布一个通用的api，这是我们想要的：1234567891011&lt;Router&gt; &lt;ScrollRestoration&gt; &lt;div&gt; &lt;h1&gt;App&lt;/h1&gt; &lt;RestoredScroll id=\"bunny\"&gt; &lt;div style=&#123;&#123; height: \"200px\", overflow: \"auto\" &#125;&#125;&gt;I will overflow&lt;/div&gt; &lt;/RestoredScroll&gt; &lt;/div&gt; &lt;/ScrollRestoration&gt;&lt;/Router&gt; 首先，ScrollRestoration将在导航时向上滚动窗口。 其次，它将使用location.key将窗口滚动位置和RestoredScroll组件的滚动位置保存到sessionStorage。 然后，当ScrollRestoration或RestoredScroll组件挂载时，他们可以从sessionsStorage中查找它们的位置。 对我来说棘手的是当我不希望管理窗口滚动时,如何实现一个“选择退出”API，。 例如，当你有一些浮动在页面上的选项卡导航时，你可能不希望滚动到顶部（选项卡可能会滚动到视图之外）。 当我了解到chrome现在已经在为我们管理滚动位置，并且意识到不同的应用将有不同的滚动需求时，我有点失去了做这件事的信念 - 特别是当人们只想滚动到顶部时（ 你看到的是很容易直接添加到你的应用的内容）。 基于此，我们觉得我们已经没有足够的力量来完成这项工作（就像你的时间是有限的一样）。但是，我们很乐意帮助任何愿意使用通用解决方案的人。如果你一开始就使用她，你的项目会有一个可靠的解决方案。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"React Router","slug":"React-Router","permalink":"http://yoursite.com/tags/React-Router/"}],"keywords":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}]},{"title":"React Router V5 翻译文档6：设计思想","slug":"React Router V5 翻译文档6：设计思想","date":"2019-12-14T16:05:00.000Z","updated":"2019-12-15T06:32:31.526Z","comments":true,"path":"2019/12/15/React Router V5 翻译文档6：设计思想/","link":"","permalink":"http://yoursite.com/2019/12/15/React Router V5 翻译文档6：设计思想/","excerpt":"","text":"转载说明原翻译作者：https://www.jianshu.com/u/5d660a479013原官网文档：https://reacttraining.com/react-router/web/guides/quick-start 设计思想这篇指南是是用来解释React Router使用时的心智模型。我们将其称为“动态路由”，这与你可能更熟悉的“静态路由”完全不同。 静态路由如果你使用过Rails，Express，Ember，Angular等框架，那么你已经使用过了静态路由。 在这些框架中，当你在进行任何渲染之前，会将路由声明为应用初始化的一部分。React Router pre-v4在大多数情况下也是静态的。下面我们来看看如何在express中配置路由：1234567// Express Style routing:app.get(\"/\", handleIndex);app.get(\"/invoices\", handleInvoices);app.get(\"/invoices/:id\", handleInvoice);app.get(\"/invoices/:id/edit\", handleInvoiceEdit);app.listen(); 请注意在应用监听请求之前是如何声明路由的。我们使用的客户端路由与其是相似当。在Angular中，你可以预先声明路由，然后在渲染之前将它们导入顶级AppModule中：123456789101112131415161718192021222324252627282930// Angular Style routing:const appRoutes: Routes = [ &#123; path: \"crisis-center\", component: CrisisListComponent &#125;, &#123; path: \"hero/:id\", component: HeroDetailComponent &#125;, &#123; path: \"heroes\", component: HeroListComponent, data: &#123; title: \"Heroes List\" &#125; &#125;, &#123; path: \"\", redirectTo: \"/heroes\", pathMatch: \"full\" &#125;, &#123; path: \"**\", component: PageNotFoundComponent &#125;];@NgModule(&#123; imports: [RouterModule.forRoot(appRoutes)]&#125;)export class AppModule &#123;&#125; Ember有一个常规的routes.js文件，在构建时会读取这个文件当内容并导入到应用中。这会在应用渲染前进行。12345678910// Ember Style Router:Router.map(function() &#123; this.route(\"about\"); this.route(\"contact\"); this.route(\"rentals\", function() &#123; this.route(\"show\", &#123; path: \"/:rental_id\" &#125;); &#125;);&#125;);export default Router; 尽管API不同，但她们都遵循“静态路由”模型。React Router遵循这个模型直到v4。但是要成功使用React Router，你需要忘记这一切。 背景坦率地说，我们React Router直到v2版本所采取的开发方向感到非常沮丧。 我们（Michael和Ryan）感觉现在采用的这种路由方式受限于API，我们正在重新实现React（生命周期等）的部分，并且它与React给我们创造UI的心智模型不匹配。当我们在研讨会之前在一家酒店的走廊互相讨论时。我们互相问道：“如果我们使用我们在之前讨论的模式构建路由会是什么样子？”开发只需要几个小时，我们就有了一个验证的概念，我们知道她是未来我们想要路由。 我们最终意识到API并不应该在React的“外部”，这是一个由React的其余部分组成并自然落实到位的API。我们认为你会喜欢她。 动态路由动态路由指的是在应用渲染时发生的路由，而不是在正在运行的应用之外配置或规定好的路由。这意味着几乎所有东西都是React Router中的一个组件。接下来看一下这个API是如何工作的： 首先，创建一个路由组件，将其渲染在应用的顶部。123456789101112// react-nativeimport &#123; NativeRouter &#125; from \"react-router-native\";// react-dom (what we'll use here)import &#123; BrowserRouter &#125; from \"react-router-dom\";ReactDOM.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, el); 接下来，创建一个链接组件将其链接到一个新的地址。1234567const App = () =&gt; ( &lt;div&gt; &lt;nav&gt; &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt; &lt;/nav&gt; &lt;/div&gt;); 最后，当用户查看‘/dashboard’路径时，渲染该路由并展示对应UI12345678910const App = () =&gt; ( &lt;div&gt; &lt;nav&gt; &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt; &lt;/nav&gt; &lt;div&gt; &lt;Route path=\"/dashboard\" component=&#123;Dashboard&#125; /&gt; &lt;/div&gt; &lt;/div&gt;); Route将渲染，props是一些看起来像{match，location，history}这样的特定的路由的属性。如果用户不在‘/dashboard’路径下，那么Route将不渲染任何东西。这就是它的全部内容。 嵌套路由很多路由库都有一些“嵌套路由”的概念。如果你使用过React Router V4以前的版本，那么你就会知道我们也是这样做的。然而当你从静态路由配置移动到动态渲染路由时，该如何“嵌套路由”呢？12345678910111213141516171819const App = () =&gt; ( &lt;BrowserRouter&gt; &#123;/* here's a div */&#125; &lt;div&gt; &#123;/* here's a Route */&#125; &lt;Route path=\"/tacos\" component=&#123;Tacos&#125; /&gt; &lt;/div&gt; &lt;/BrowserRouter&gt;);// when the url matches `/tacos` this component rendersconst Tacos = (&#123; match &#125;) =&gt; ( // here's a nested div &lt;div&gt; &#123;/* here's a nested Route, match.url helps us make a relative path */&#125; &lt;Route path=&#123;match.url + \"/carnitas\"&#125; component=&#123;Carnitas&#125; /&gt; &lt;/div&gt;); 如上代码，React Router并没有嵌套的API，Router仅仅是一个组件，就想一个普通的div一样。 响应路由设想一下用户导航到’/invoice’。你的应用需要适用于不同的尺寸的屏幕，当她们具有较窄的视口时，你只需向其显示发票列表和到发票详情的链接。她们可以导航到更深入的层级。123456789101112131415161718192021222324Small Screenurl: /invoices+----------------------+| || Dashboard || |+----------------------+| || Invoice 01 || |+----------------------+| || Invoice 02 || |+----------------------+| || Invoice 03 || |+----------------------+| || Invoice 04 || |+----------------------+ 在更大的屏幕上，我们会想要显示一个类别-详细内容的视图，其中导航位于左侧，详情或特定发票显示在右侧。123456789101112131415161718192021222324Large Screenurl: /invoices/dashboard+----------------------+---------------------------+| | || Dashboard | || | Unpaid: 5 |+----------------------+ || | Balance: $53,543.00 || Invoice 01 | || | Past Due: 2 |+----------------------+ || | || Invoice 02 | || | +-------------------+ |+----------------------+ | | || | | + + + | || Invoice 03 | | | + | | | || | | | | | + | + | |+----------------------+ | | | | | | | | || | +--+-+--+--+--+--+--+ || Invoice 04 | || | |+----------------------+---------------------------+ 现在暂停考虑一下两种屏幕尺寸的/invoice URL,她是大尺寸屏幕的有效路由吗？我们应该把右边的东西放在什么位置？1234567891011121314151617181920212223Large Screenurl: /invoices+----------------------+---------------------------+| | || Dashboard | || | |+----------------------+ || | || Invoice 01 | || | |+----------------------+ || | || Invoice 02 | ??? || | |+----------------------+ || | || Invoice 03 | || | |+----------------------+ || | || Invoice 04 | || | |+----------------------+---------------------------+ 在大屏幕上，’/invoice’不是有效的路线，但在小屏幕上她是有效的，更有趣的是，请考虑一个拥尺寸手机的人。她/他可以用横屏和竖屏两种方式来查看手机页面。突然间，我们有足够的空间来显示类别-详情这种UI，所以你应该立即重定向！ React Router在先前版本的静态路由并没有真正成功的答案。但是，当路由是动态的时，你可以声明性地重组这些功能。如果你开始考虑将路由作为UI而不是静态配置，那么你会写出以下代码：12345678910111213141516171819202122232425262728293031const App = () =&gt; ( &lt;AppLayout&gt; &lt;Route path=\"/invoices\" component=&#123;Invoices&#125; /&gt; &lt;/AppLayout&gt;);const Invoices = () =&gt; ( &lt;Layout&gt; &#123;/* always show the nav */&#125; &lt;InvoicesNav /&gt; &lt;Media query=&#123;PRETTY_SMALL&#125;&gt; &#123;screenIsSmall =&gt; screenIsSmall ? ( // small screen has no redirect &lt;Switch&gt; &lt;Route exact path=\"/invoices/dashboard\" component=&#123;Dashboard&#125; /&gt; &lt;Route path=\"/invoices/:id\" component=&#123;Invoice&#125; /&gt; &lt;/Switch&gt; ) : ( // large screen does! &lt;Switch&gt; &lt;Route exact path=\"/invoices/dashboard\" component=&#123;Dashboard&#125; /&gt; &lt;Route path=\"/invoices/:id\" component=&#123;Invoice&#125; /&gt; &lt;Redirect from=\"/invoices\" to=\"/invoices/dashboard\" /&gt; &lt;/Switch&gt; ) &#125; &lt;/Media&gt; &lt;/Layout&gt;); 当用户将手机从纵向旋转到横向时，此代码会自动将其重定向到详情页。该组有效路由将根据用户手中的移动设备的动态特性而改变。 这只是一个例子。我们还有许多其他问题可以讨论，我们总结一下规律：我们应该考虑组件，而不是静态路由。考虑如何使用React的声明可组合性来解决问题，因为几乎每个“React Router问题”都可能是“React问题”。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"React Router","slug":"React-Router","permalink":"http://yoursite.com/tags/React-Router/"}],"keywords":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}]},{"title":"React Router V5 翻译文档7：测试","slug":"React Router V5 翻译文档7：测试","date":"2019-12-14T16:04:00.000Z","updated":"2019-12-15T06:33:47.802Z","comments":true,"path":"2019/12/15/React Router V5 翻译文档7：测试/","link":"","permalink":"http://yoursite.com/2019/12/15/React Router V5 翻译文档7：测试/","excerpt":"","text":"转载说明原翻译作者：https://www.jianshu.com/u/5d660a479013原官网文档：https://reacttraining.com/react-router/web/guides/quick-start 测试React Router依赖React上下文来工作。 这会影响您如何测试使用我们组件的组件。 如果你对应用渲染的或者组件进行单元测试，那么你会得到一些有关上下文的错误和警告信息。虽然你可能会找出自己的路由上下文的内容，我们推荐你将你的单元测试包裹在或者中。代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041class Sidebar extends Component &#123; // ... render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.toggleExpand&#125;&gt; expand &lt;/button&gt; &lt;ul&gt; &#123;users.map(user =&gt; ( &lt;li&gt; &lt;Link to=&#123;user.path&#125;&gt; &#123;user.name&#125; &lt;/Link&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;// brokentest('it expands when the button is clicked', () =&gt; &#123; render( &lt;Sidebar/&gt; ) click(theButton) expect(theThingToBeOpen)&#125;)// fixed!test('it expands when the button is clicked', () =&gt; &#123; render( &lt;MemoryRouter&gt; &lt;Sidebar/&gt; &lt;/MemoryRouter&gt; ) click(theButton) expect(theThingToBeOpen)&#125;) 从特定路由开始&lt; MemoryRouter &gt;支持initialEntries和initialIndex 属性。因此你可以从一个特定的路径来启动你的应用（或者是从应用的一小部分)。12345678test(\"current user is active in sidebar\", () =&gt; &#123; render( &lt;MemoryRouter initialEntries=&#123;[\"/users/2\"]&#125;&gt; &lt;Sidebar /&gt; &lt;/MemoryRouter&gt; ); expectUserToBeActive(2);&#125;); 导航当路径改变时我们有许多路由测试的任务，因此你可能不需要再测试这个。但是如果你必须这样做的话，既然这发生在渲染时，那么我们可以这样做：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import &#123; render, unmountComponentAtNode &#125; from \"react-dom\";import React from \"react\";import &#123; Route, Link, MemoryRouter &#125; from \"react-router-dom\";import &#123; Simulate &#125; from \"react-addons-test-utils\";// a way to render any part of your app inside a MemoryRouter// you pass it a list of steps to execute when the location// changes, it will call back to you with stuff like// `match` and `location`, and `history` so you can control// the flow and make assertions.const renderTestSequence = (&#123; initialEntries, initialIndex, subject: Subject, steps&#125;) =&gt; &#123; const div = document.createElement(\"div\"); class Assert extends React.Component &#123; componentDidMount() &#123; this.assert(); &#125; componentDidUpdate() &#123; this.assert(); &#125; assert() &#123; const nextStep = steps.shift(); if (nextStep) &#123; nextStep(&#123; ...this.props, div &#125;); &#125; else &#123; unmountComponentAtNode(div); &#125; &#125; render() &#123; return this.props.children; &#125; &#125; class Test extends React.Component &#123; render() &#123; return ( &lt;MemoryRouter initialIndex=&#123;initialIndex&#125; initialEntries=&#123;initialEntries&#125; &gt; &lt;Route render=&#123;props =&gt; ( &lt;Assert &#123;...props&#125;&gt; &lt;Subject /&gt; &lt;/Assert&gt; )&#125; /&gt; &lt;/MemoryRouter&gt; ); &#125; &#125; render(&lt;Test /&gt;, div);&#125;;// our Subject, the App, but you can test any sub// section of your app tooconst App = () =&gt; ( &lt;div&gt; &lt;Route exact path=\"/\" render=&#123;() =&gt; ( &lt;div&gt; &lt;h1&gt;Welcome&lt;/h1&gt; &lt;/div&gt; )&#125; /&gt; &lt;Route path=\"/dashboard\" render=&#123;() =&gt; ( &lt;div&gt; &lt;h1&gt;Dashboard&lt;/h1&gt; &lt;Link to=\"/\" id=\"click-me\"&gt; Home &lt;/Link&gt; &lt;/div&gt; )&#125; /&gt; &lt;/div&gt;);// the actual test!it(\"navigates around\", done =&gt; &#123; renderTestSequence(&#123; // tell it the subject you're testing subject: App, // and the steps to execute each time the location changes steps: [ // initial render (&#123; history, div &#125;) =&gt; &#123; // assert the screen says what we think it should console.assert(div.innerHTML.match(/Welcome/)); // now we can imperatively navigate as the test history.push(\"/dashboard\"); &#125;, // second render from new location (&#123; div &#125;) =&gt; &#123; console.assert(div.innerHTML.match(/Dashboard/)); // or we can simulate clicks on Links instead of // using history.push Simulate.click(div.querySelector(\"#click-me\"), &#123; button: 0 &#125;); &#125;, // final render (&#123; location &#125;) =&gt; &#123; console.assert(location.pathname === \"/\"); // you'll want something like `done()` so your test // fails if you never make it here. done(); &#125; ] &#125;);&#125;);","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"React Router","slug":"React-Router","permalink":"http://yoursite.com/tags/React-Router/"}],"keywords":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}]},{"title":"React Router V5 翻译文档8：Redux集成","slug":"React Router V5 翻译文档8：Redux集成","date":"2019-12-14T16:03:00.000Z","updated":"2019-12-15T06:33:47.802Z","comments":true,"path":"2019/12/15/React Router V5 翻译文档8：Redux集成/","link":"","permalink":"http://yoursite.com/2019/12/15/React Router V5 翻译文档8：Redux集成/","excerpt":"","text":"转载说明原翻译作者：https://www.jianshu.com/u/5d660a479013原官网文档：https://reacttraining.com/react-router/web/guides/quick-start Redux集成Redux是React生态系统的重要组成部分。我们希望将React Router和Redux尽可能地无缝集成以满足人们想要同时使用她们的需求。 阻塞更新通常，React Router和Redux可以很好地协同工作。但有时，应用可能会发生有一个组件在位置更改时不会更新（子路由或点击导航链接不会更新）的情况。 如果这种情况发生在以下场景： 该组件通过connect()(comp)连接到redux。 该组件不是“路由组件”，这意味着它不会像这样渲染：&lt; Route component = {SomeConnectedThing} /&gt; 问题通常是Redux实现了本来应该由组件自动更新的部分，如果她没有从路由接收属性，则没有任何迹象表明组件应该发生改变。这很容易解决，找到连接组件的位置并将其封装在withRouter方法中。123456// beforeexport default connect(mapStateToProps)(Something)// afterimport &#123; withRouter &#125; from 'react-router-dom'export default withRouter(connect(mapStateToProps)(Something)) 深度集成一些人想要做到： 从store中访问并同步数据。 能够通过调用actions进行导航跳转。 支持在Redux devtools中调试路由改变。 所有这些需要深度集成。 我们的建议是更不不要将路由放在Redux store中。 原因： 路由数据已经成为你的大部分组件所在意的属性。无论她是来自store还是router，你的组件代码都大致相同。 在大多数情况下，你可以使用Link，NavLink和Redirect来执行导航操作。有时你可能还需要在初始化操作启动某个异步任务之后以编程方式导航。例如，你可以在用户提交登录表单时调度action。你的thunk，saga或其他异步操作需要验证身份，如果成功，她需要某种方式导航的新页面。解决方案是在action的payload中包含历史对象（提供给所有路由组件），并且在适当的时候你的异步操作可以使用这来进行导航跳转。 路由改变对于时间旅行式的调试不太重要。唯一需要关注的情况是调试route/store同步的问题，但如果你根本不同步这个问题就会消失。 但是如果你强烈想要将你的route与store同步，你可能想尝试 Connected React Router，一个绑定React Router v4和Redux的第三方类库。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"React Router","slug":"React-Router","permalink":"http://yoursite.com/tags/React-Router/"}],"keywords":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}]},{"title":"React Router V5 翻译文档9：静态路由","slug":"React Router V5 翻译文档9：静态路由","date":"2019-12-14T16:02:00.000Z","updated":"2019-12-15T06:33:47.802Z","comments":true,"path":"2019/12/15/React Router V5 翻译文档9：静态路由/","link":"","permalink":"http://yoursite.com/2019/12/15/React Router V5 翻译文档9：静态路由/","excerpt":"","text":"转载说明原翻译作者：https://www.jianshu.com/u/5d660a479013原官网文档：https://reacttraining.com/react-router/web/guides/quick-start 静态路由以前版本的React Router使用静态路由来配置应用的路由跳转。这允许在渲染之前检查和匹配路由。由于v4版本我们转移到动态路由组件而不是静态路由配置，一些以前的用例变得不那么明显和棘手。我们现在正在开发一个包来处理静态路由配置和React路由，以继续满足这些用例。她现在正在开发中，但我们很乐意为你尝试并提供帮助。 React Router Config","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"React Router","slug":"React-Router","permalink":"http://yoursite.com/tags/React-Router/"}],"keywords":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}]},{"title":"React Router V5 翻译文档10：API","slug":"React Router V5 翻译文档10：API","date":"2019-12-14T16:01:00.000Z","updated":"2019-12-15T06:33:47.802Z","comments":true,"path":"2019/12/15/React Router V5 翻译文档10：API/","link":"","permalink":"http://yoursite.com/2019/12/15/React Router V5 翻译文档10：API/","excerpt":"","text":"转载说明原翻译作者：https://www.jianshu.com/u/5d660a479013原官网文档：https://reacttraining.com/react-router/web/guides/quick-start 这部分API文档翻译参考了项目react-router-CN &lt; BrowserRouter &gt; 使用HTML5提供的history API(pushState, replaceState和popstate事件)来同步UI和URL。12345678910import &#123; BrowserRouter &#125; from 'react-router-dom'&lt;BrowserRouter basename=&#123;optionalString&#125; forceRefresh=&#123;optionalBool&#125; getUserConfirmation=&#123;optionalFunc&#125; keyLength=&#123;optionalNumber&#125;&gt; &lt;App/&gt;&lt;/BrowserRouter&gt; basename: String当前位置的基准URL。如果你的页面部署在服务器的二级子目录，你需要将basename设置到此子目录。 正确的URL格式是前面有一个前导斜杠，但不能有尾部斜杠。12&lt;BrowserRouter basename=\"/calendar\"/&gt;&lt;Link to=\"/today\"/&gt; // 渲染为 &lt;a href=\"/calendar/today\"&gt; getUserConfirmation: func当导航需要确认时执行的函数。默认使用window.confirm。1234567// 使用默认的确认函数const getConfirmation = (message, callback) =&gt; &#123; const allowTransition = window.confirm(message) callback(allowTransition)&#125;&lt;BrowserRouter getUserConfirmation=&#123;getConfirmation&#125;/&gt; forceRefresh: bool当设置为true时，在导航的过程中整个页面将会刷新。只有当浏览器不支持HTML5的 history API 时，才设置为true。12const supportsHistory = 'pushState' in window.history&lt;BrowserRouter forceRefresh=&#123;!supportsHistory&#125;/&gt; keyLength: numberlocation.key的长度。默认是6。1&lt;BrowserRouter keyLength=&#123;12&#125;/&gt; children: node渲染单一子组件（元素）。 &lt; HashRouter &gt;HashRouter 是一种特定的 ， HashRouter 使用 URL 的 hash (例如：window.location.hash) 来同步UI和URL。 注意：使用 hash 的方式记录导航历史不支持 location.key 和 location.state。在以前的版本中，我们为这种行为提供了 shim，但是仍有一些问题我们无法解决。任何依赖此行为的代码或插件都将无法正常使用。 由于该技术仅用于支持传统的浏览器，因此在用于浏览器时可以使用 代替。12345import &#123; HashRouter &#125; from 'react-router-dom'&lt;HashRouter&gt; &lt;App/&gt;&lt;/HashRouter&gt; basename: string当前位置的基准 URL。正确的 URL 格式是前面有一个前导斜杠，但不能有尾部斜杠。12&lt;HashRouter basename=\"/calendar\"/&gt;&lt;Link to=\"/today\"/&gt; // renders &lt;a href=\"#/calendar/today\"&gt; getUserConfirmation: func当导航需要确认时执行的函数。默认使用 window.confirm。1234567// 使用默认的确认函数const getConfirmation = (message, callback) =&gt; &#123; const allowTransition = window.confirm(message) callback(allowTransition)&#125;&lt;HashRouter getUserConfirmation=&#123;getConfirmation&#125;/&gt; hashType: stringwindow.location.hash 使用的 hash 类型。有如下几种： “slash” - 后面跟一个斜杠，例如 #/ 和 #/sunshine/lollipops “noslash” - 后面没有斜杠，例如 # 和 #sunshine/lollipops “hashbang” - Google 风格的 “ajax crawlable”，例如 #!/ 和 #!/sunshine/lollipops 默认为 “slash”。 children: node渲染单一子组件（元素）。 &lt; Link &gt;为您的应用提供声明式的、无障碍导航。123import &#123; Link &#125; from 'react-router-dom'&lt;Link to=\"/about\"&gt;关于&lt;/Link&gt; to: string需要跳转到的路径(pathname)或地址（location）。1&lt;Link to=\"/courses\"/&gt; to: object需要跳转到的地址（location）。123456&lt;Link to=&#123;&#123; pathname: '/courses', search: '?sort=name', hash: '#the-hash', state: &#123; fromDashboard: true &#125;&#125;&#125;/&gt; replace: bool当设置为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址。当设置为 false 时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。默认为 false。1&lt;Link to=\"/courses\" replace /&gt; &lt; NavLink &gt;&lt; NavLink &gt;是 &lt; Link &gt; 的一个特定版本, 会在匹配上当前 URL 的时候会给已经渲染的元素添加样式参数123import &#123; NavLink &#125; from 'react-router-dom'&lt;NavLink to=\"/about\"&gt;About&lt;/NavLink&gt; activeClassName: string当元素匹配上当前 URL 的时候, 这个类会被赋予给这个元素. 其默认值为 active, 这个值会被添加到 className 属性的后面(追加)1234&lt;NavLink to=\"/faq\" activeClassName=\"selected\"&gt;FAQs&lt;/NavLink&gt; activeStyle: object当元素被选中时, 为此元素添加样式1234567&lt;NavLink to=\"/faq\" activeStyle=&#123;&#123; fontWeight: 'bold', color: 'red' &#125;&#125;&gt;FAQs&lt;/NavLink&gt; exact: bool当值为 true 时, 只有当地址完全匹配 class 和 style 才会应用1234&lt;NavLink exact to=\"/profile\"&gt;Profile&lt;/NavLink strict: bool当值为 true 时，在确定位置是否与当前 URL 匹配时，将考虑位置 pathname 后的斜线 有关详细信息，请参阅&lt; Route strict &gt;文档。1234&lt;NavLink strict to=\"/events/\"&gt;Events&lt;/NavLink&gt; isActive: func添加用于确定链接是否活动的额外逻辑的功能。 如果您想要做的更多，请验证链接的路径名是否与当前URL的 pathname 匹配。12345678910111213// only consider an event active if its event id is an odd numberconst oddEvent = (match, location) =&gt; &#123; if (!match) &#123; return false &#125; const eventID = parseInt(match.params.eventID) return !isNaN(eventID) &amp;&amp; eventID % 2 === 1&#125;&lt;NavLink to=\"/events/123\" isActive=&#123;oddEvent&#125;&gt;Event 123&lt;/NavLink&gt; &lt; Prompt &gt;当用户离开当前页的时候做出提示. 当你的应用处在特定状态, 此状态不希望用户离开时(例如填写表格到一半), 你应该使用。123456import &#123; Prompt &#125; from 'react-router'&lt;Prompt when=&#123;formIsHalfFilledOut&#125; message=\"Are you sure you want to leave?\"/&gt; message: string当用户尝试导航离开时，提示用户的消息。1&lt;Prompt message=\"Are you sure you want to leave?\" /&gt; message: func会与用户试图前往下一个地址（location） 和 action 一起被调用。函返回一个字符串用作向用户提示，或者返回true用作允许过渡。1234567Prompt message=&#123;location =&gt; location.pathname.startsWith(\"/app\") ? true : `Are you sure you want to go to $&#123;location.pathname&#125;?` &#125;/&gt; when: bool你可以随时渲染，而不是有条件地在警戒后面渲染它。 当when={true} 时，禁止导航 当when={false} 时，允许导航1&lt;Prompt when=&#123;formIsHalfFilledOut&#125; message=\"Are you sure?\" /&gt; &lt; MemoryRouter &gt;&lt; Router &gt; 能在内存保存你 “URL” 的历史纪录(并没有对地址栏读写). 在非浏览器或者测试环境比如React Native下很有用。12345import &#123; MemoryRouter &#125; from 'react-router'&lt;MemoryRouter&gt; &lt;App/&gt;&lt;/MemoryRouter&gt; initialEntries: array在历史栈中的一个 location 数组. 这些可能会成为含有 { pathname, search, hash, state } 或一些简单的 URL 字符串的完整的地址对象123456&lt;MemoryRouter initialEntries=&#123;[ '/one', '/two', &#123; pathname: '/three' &#125; ]&#125; initialIndex=&#123;1&#125;&gt; &lt;App/&gt;&lt;/MemoryRouter&gt; initialIndex: numberinitialEntries 数组中的初始化地址索引 getUserConfirmation: func用于确认导航的函数. 当使用直接使用时，你必须使用这个选项 keyLength: numberlocation.key 的长度, 默认为 61&lt;MemoryRouter keyLength=&#123;12&#125;/&gt; children: node要呈现的 单个子元素。 &lt; Redirect &gt;渲染 的时候将会导航到一个新的地址（location）。这个新的地址（location）将会覆盖在访问历史记录里面的原地址，就像服务端的重定向（HTTP 3XX）一样123456789import &#123; Route, Redirect &#125; from 'react-router'&lt;Route exact path=\"/\" render=&#123;() =&gt; ( loggedIn ? ( &lt;Redirect to=\"/dashboard\"/&gt; ) : ( &lt;PublicHomePage/&gt; ))&#125;/&gt; to: string重定向目标URL。1&lt;Redirect to=\"/somewhere/else\"/&gt; to: object重定向目标地址(location)。12345&lt;Redirect to=&#123;&#123; pathname: '/login', search: '?utm=your+face', state: &#123; referrer: currentLocation &#125;&#125;&#125;/&gt; push: bool当设置为 true 时，重定向（redirecting）将会把新地址加入访问历史记录里面，而不是替换掉目前的地址1&lt;Redirect push to=\"/somewhere/else\"/&gt; from: string需要被重定向的路径（pathname）。当渲染一个包含在里面的的时候，这可以用作匹配一个地址（location）。1234&lt;Switch&gt; &lt;Redirect from='/old-path' to='/new-path'/&gt; &lt;Route path='/new-path' component=&#123;Place&#125;/&gt;&lt;/Switch&gt; &lt; Route &gt;想要理解并使用好React Router，最重要的可能就是Route组件了。Route组件主要的作用就是当一个location匹配路由的path时，渲染某些UI。考虑这样的代码：12345678import &#123; BrowserRouter as Router, Route &#125; from 'react-router-dom'&lt;Router&gt; &lt;div&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/news\" component=&#123;NewsFeed&#125;/&gt; &lt;/div&gt;&lt;/Router&gt; 如果应用的地址是/,那么相应的UI会类似这个样子：1234&lt;div&gt; &lt;Home/&gt; &lt;!-- react-empty: 2 --&gt;&lt;/div&gt; 如果应用的地址是/news,那么相应的UI就会成为这个样子：1234&lt;div&gt; &lt;!-- react-empty: 1 --&gt; &lt;NewsFeed/&gt;&lt;/div&gt; 这里的react-empty注释只是演示了React渲染null的细节，但对我们具有启发性。其实Route就算是null也会被渲染，只要地址与路由的路径匹配，组件就会渲染。 Route渲染方法这三种渲染方法都会获得相同的三个的属性： match location history component只有在地址匹配的时候React的组件才会被渲染，route props也会随着一起被渲染。12345&lt;Route path=\"/user/:username\" component=&#123;User&#125;/&gt;const User = (&#123; match &#125;) =&gt; &#123; return &lt;h1&gt;Hello &#123;match.params.username&#125;!&lt;/h1&gt;&#125; 如果你使用component(而不是像下面这样使用render),路由会根据指定的组件使用React.createElement来创建一个新的React element。这就意味着如果你提供的是一个内联的函数的话会带来很多意料之外的重新挂载。所以，对于内联渲染，要使用render属性(如下所示)。 render: func这种方式对于内联渲染和包装组件却不引起意料之外的重新挂载特别方便。使用render属性，你可以选择传一个在地址匹配时被调用的函数，而不是像使用component属性那样得到一个新创建的React element。使用render属性会获得跟使用component属性一样的route props。12345678910111213// 便捷的行内渲染&lt;Route path=\"/home\" render=&#123;() =&gt; &lt;div&gt;Home&lt;/div&gt;&#125;/&gt;// 包装/合成const FadingRoute = (&#123; component: Component, ...rest &#125;) =&gt; ( &lt;Route &#123;...rest&#125; render=&#123;props =&gt; ( &lt;FadeIn&gt; &lt;Component &#123;...props&#125;/&gt; &lt;/FadeIn&gt; )&#125;/&gt;)&lt;FadingRoute path=\"/cool\" component=&#123;Something&#125;/&gt; 警告: &lt; Route component &gt;的优先级要比&lt; Route render &gt;高，所以不要在同一个 中同时使用这两个属性。 children: func有时候你可能想不管地址是否匹配都渲染一些内容，这种情况你可以使用children属性。它与render属性的工作方式基本一样，除了它是不管地址匹配与否都会被调用。除了在路径不匹配URL时match的值为null之外，children渲染属性会获得与component和render一样的route props。这就允许你根据是否匹配路由来动态地调整UI了，来看这个例子，如果理由匹配的话就添加一个active类：123456789101112&lt;ul&gt; &lt;ListItemLink to=\"/somewhere\"/&gt; &lt;ListItemLink to=\"/somewhere-else\"/&gt;&lt;/ul&gt;const ListItemLink = (&#123; to, ...rest &#125;) =&gt; ( &lt;Route path=&#123;to&#125; children=&#123;(&#123; match &#125;) =&gt; ( &lt;li className=&#123;match ? 'active' : ''&#125;&gt; &lt;Link to=&#123;to&#125; &#123;...rest&#125;/&gt; &lt;/li&gt; )&#125;/&gt;) 这种属性对于动画也特别有用:12345678&lt;Route children=&#123;(&#123; match, ...rest &#125;) =&gt; ( &#123;/* Animate总会被渲染, 所以你可以使用生命周期来使它的子组件出现 或者隐藏 */&#125; &lt;Animate&gt; &#123;match &amp;&amp; &lt;Something &#123;...rest&#125;/&gt;&#125; &lt;/Animate&gt;)&#125;/&gt; 警告: &lt; Route component &gt;和&lt; Route render &gt; 的优先级都比&lt; Route children &gt; 高，所以在同一个中不要同时使用一个以上的属性. path: string可以是任何path-to-regexp能理解的有效URL。1&lt;Route path=\"/users/:id\" component=&#123;User&#125;/&gt; 没有path属性的Route 总是会 匹配。 exact: bool当值为true时，则要求路径与location.pathname必须 完全 匹配。1&lt;Route exact path=\"/one\" component=&#123;About&#125;/&gt; 路径 location.pathname exact 是否匹配? /one /one/two true 否 /one /one/two false 是 strict: bool当设为true的时候，有结尾斜线的路径只能匹配有斜线的location.pathname，这个值并不会对location.pathname中有其他的片段有影响。1&lt;Route strict path=\"/one/\" component=&#123;About&#125;/&gt; 路径 location.pathname 是否匹配? /one/ /one 否 /one/ /one/ 是 /one/ /one/two 是 警告: stict可以强制location.pathname不包含结尾的斜线，但是要做到这点必须把strict和exect都设置为true。1&lt;Route exact strict path=\"/one\" component=&#123;About&#125;/&gt; 路径 location.pathname 是否匹配? /one /one 是 /one /one/ 否 /one /one/two 否 location: object&lt; Route &gt;元素尝试将路径path当前history location（通常是当前浏览器URL）进行匹配。 除此之外，具有不同pathname的location也可以被传统用来匹配。 当你需要将&lt; Route &gt;匹配到当前history location以外的location时，这非常有用，如动画过渡示例中所示。 如果&lt; Route &gt;包含在&lt; Switch &gt;中并匹配了传递给的location（或当前history location），那么传递给&lt; Route &gt;的location属性将会被&lt; Switch &gt;使用的所覆盖。 sensitive: bool如果该属性为true,则在匹配时区分大小写path| location.pathname| sensitive| 是否匹配?|:-:|:-:|:-:|:-:|/one|/one| true| yes|/One| /one| true| no|/One| /one| false| yes| &lt; Router &gt;Router是所有路由组件共用的底层接口，一般我们的应用并不会使用这个接口，而是使用高级的路由： &lt; BrowserRouter &gt; &lt; HashRouter &gt; &lt; MemoryRouter &gt; &lt; NativeRouter &gt; &lt; StaticRouter &gt; 最常见的使用底层的&lt; Router &gt;的情形就是用来与Redux或者Mobx之类的状态管理库的定制的history保持同步。注意不是说使用状态管理库就必须使用&lt; Router &gt;，它仅用作于深度集成。12345678import &#123; Router &#125; from 'react-router'import createBrowserHistory from 'history/createBrowserHistory'const history = createBrowserHistory()&lt;Router history=&#123;history&#125;&gt; &lt;App/&gt;&lt;/Router&gt; history: object用来导航的history对象.1234import createBrowserHistory from 'history/createBrowserHistory'const customHistory = createBrowserHistory()&lt;Router history=&#123;customHistory&#125;/&gt; children: node需要渲染的单一组件。123&lt;Router&gt; &lt;App/&gt;&lt;/Router&gt; &lt; StaticRouter &gt;&lt; Router &gt; 从不会改变地址当用户实际上没有点击时, 这在服务端的渲染场景中可能会非常有用, 所以这个地址从来没有改变. 因此, 称为: static (静态). 当您只需要插入一个位置并在渲染输出上作出断言时，它也可用于简单的测试 这里有一个简单 nodejs 服务 : 为&lt; Redirect &gt;和其他请求的常规HTML发送302状态代码：123456789101112131415161718192021222324252627import &#123; createServer &#125; from 'http'import React from 'react'import ReactDOMServer from 'react-dom/server'import &#123; StaticRouter &#125; from 'react-router'createServer((req, res) =&gt; &#123; // This context object contains the results of the render const context = &#123;&#125; const html = ReactDOMServer.renderToString( &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt; &lt;App/&gt; &lt;/StaticRouter&gt; ) // context.url will contain the URL to redirect to if a &lt;Redirect&gt; was used if (context.url) &#123; res.writeHead(302, &#123; Location: context.url &#125;) res.end() &#125; else &#123; res.write(html) res.end() &#125;&#125;).listen(3000) basename: string所有地址的基本 URL . 正确格式化的基本名称应该有一个主要的斜杠，但没有尾部斜杠123&lt;StaticRouter basename=\"/calendar\"&gt; &lt;Link to=\"/today\"/&gt; // renders &lt;a href=\"/calendar/today\"&gt;&lt;/StaticRouter&gt; location: string服务器收到的 URL, 在 node 服务上可能是 req.url123&lt;StaticRouter location=&#123;req.url&#125;&gt; &lt;App/&gt;&lt;/StaticRouter&gt; location: object一个格式像 { pathname, search, hash, state } 的地址对象123&lt;StaticRouter location=&#123;&#123; pathname: '/bubblegum' &#125;&#125;&gt; &lt;App/&gt;&lt;/StaticRouter&gt; context: object记录渲染结果的纯JavaScript对象。 见上面的例子 children: node要呈现的单个子元素。 &lt; Switch &gt;渲染匹配地址(location)的第一个 &lt; Route &gt; 或者 &lt; Redirect &gt;这与只使用一堆&lt; Route &gt;有什么不同？&lt; Switch &gt;的独特之处是独它仅仅渲染一个路由。相反地，每一个包含匹配地址(location)的&lt; Route &gt;都会被渲染。思考下面的代码：123&lt;Route path=\"/about\" component=&#123;About&#125;/&gt;&lt;Route path=\"/:user\" component=&#123;User&#125;/&gt;&lt;Route component=&#123;NoMatch&#125;/&gt; 如果现在的URL是 /about ，那么 &lt; About &gt;, &lt; User &gt;, 还有 &lt; NoMatch &gt; 都会被渲染，因为它们都与路径(path)匹配。这种设计，允许我们以多种方式将多个 &lt; Route &gt; 组合到我们的应用程序中，例如侧栏(sidebars)，面包屑(breadcrumbs)，bootstrap tabs等等。 然而，偶尔我们只想选择一个&lt; Route &gt; 来渲染。如果我们现在处于 /about ，我们也不希望匹配 /:user （或者显示我们的 “404” 页面 ）。以下是使用 Switch 的方法来实现：123456&lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/about\" component=&#123;About&#125;/&gt; &lt;Route path=\"/:user\" component=&#123;User&#125;/&gt; &lt;Route component=&#123;NoMatch&#125;/&gt;&lt;/Switch&gt; 现在，如果我们处于 /about, 将开始寻找匹配的 。 将被匹配， 将停止寻找匹配并渲染。 同样，如果我们处于 /michael ， 将被渲染。 这对于过渡动画也是起作用的，因为匹配的 在与前一个相同的位置被渲染。123456789101112131415161718&lt;Fade&gt; &lt;Switch&gt; &#123;/* there will only ever be one child here */&#125; &#123;/* 这里只会有一个子节点 */&#125; &lt;Route/&gt; &lt;Route/&gt; &lt;/Switch&gt;&lt;/Fade&gt;&lt;Fade&gt; &lt;Route/&gt; &lt;Route/&gt; &#123;/* there will always be two children here, one might render null though, making transitions a bit more cumbersome to work out */&#125; &#123;/* 这里总是有两个子节点, 一个可能会渲染为null, 使计算过渡增加了一点麻烦 */&#125; &lt;/Fade&gt; children: node&lt; Switch &gt; 的所有子节点应为 &lt; Route &gt; 或 &lt; Redirect &gt; 元素。只有匹配当前地址(location)的第一个子节点才会被渲染。&lt; Route &gt; 元素使用它们的 path 属性匹配，&lt; Redirect &gt; 元素使用它们的 from 属性匹配。没有 path 属性的&lt; Route &gt; 或者 没有 from 属性的 &lt; Redirect &gt; 将总是可以匹配当前的地址(location)12345678&lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/users\" component=&#123;Users&#125;/&gt; &lt;Redirect from=\"/accounts\" to=\"/users\"/&gt; &lt;Route component=&#123;NoMatch&#125;/&gt;&lt;/Switch&gt; history本文档中的「history」以及「history对象」请参照 history 包中的内容。 History 是 React Router 的两大重要依赖之一（除去 React 本身），在不同的 Javascript 环境中，history 以多种形式实现了对于 session 历史的管理。我们会经常使用以下术语： 「browser history」 - history 在 DOM 上的实现，经常使用于支持 HTML5 history API 的浏览器端。 「hash history」 - history 在 DOM 上的实现，经常使用于旧版本浏览器端。 「memory history」 - 一种存储于内存的 history 实现，经常用于测试或是非 DOM 环境（例如 React Native）。 history 对象通常会具有以下属性和方法： length -（ number 类型）指的是 history 堆栈的数量。 action -（ string 类型）指的是当前的动作（action），例如 PUSH，REPLACE 以及 POP 。 location -（ object类型）是指当前的位置（location），location 会具有如下属性： pathname -（ string 类型）URL路径。 search -（ string 类型）URL中的查询字符串（query string）。 hash -（ string 类型）URL的 hash 分段。 state -（ string 类型）是指 location 中的状态，例如在 push(path, state) 时，state会描述什么时候 location 被放置到堆栈中等信息。这个 state 只会出现在 browser history 和 memory history 的环境里。 push(path, [state]) -（ function 类型）在 hisotry 堆栈顶加入一个新的条目。 replace(path, [state]) -（ function 类型）替换在 history 堆栈中的当前条目。 go(n) -（ function 类型）将 history 对战中的指针向前移动 n 。 goBack() -（ function 类型）等同于 go(-1) 。 goForward() -（ function 类型）等同于 go(1) 。 block(prompt) -（ function 类型）阻止跳转，（请参照 history 文档）。history 是可变的（mutable）history 对象是可变的，因此我们建议从 的 prop里来获取 location ，而不是从 history.location 直接获取。这样做可以保证 React 在生命周期中的钩子函数正常执行，例如以下代码：1234567891011class Comp extends React.Component &#123; componentWillReceiveProps(nextProps) &#123; // locationChanged 变量为 true const locationChanged = nextProps.location !== this.props.location // 不正确，locationChanged 变量会 *永远* 为 false ，因为 history 是可变的（mutable）。 const locationChanged = nextProps.history.location !== this.props.history.location &#125;&#125;&lt;Route component=&#123;Comp&#125;/&gt; 不同的实现也许会提供给你额外的属性，更多详情请参照 history 文档。 locationLocation 是指你当前的位置，下一步打算去的位置，或是你之前所在的位置，形式大概就像这样：123456789&#123; key: 'ac3df4', // 在使用 hashHistory 时，没有 key pathname: '/somewhere' search: '?some=search-string', hash: '#howdy', state: &#123; [userDefined]: true &#125;&#125; 你使用以下几种方式来获取 location 对象： 在 Route component 中，以 this.props.location 的方式获取， 在 Route render 中，以 ({ location }) =&gt; () 的方式获取， 在 Route children 中，以 ({ location }) =&gt; () 的方式获取， 在 withRouter 中，以 this.props.location 的方式获取。 你也可以在 history.location 中获取 location 对象，但是别那么写，因为 history 是可变的。更多信息请参见 history 文档。 location 对象不会发生改变，因此你可以在生命周期的钩子函数中使用 location 对象来查看当前页面的位置是否发生改变，这种技巧在获取远程数据以及使用动画时非常有用。12345对象来查看当前页面的位置是否发生改变，这种技巧在获取远程数据以及使用动画时非常有用。componentWillReceiveProps(nextProps) &#123; if (nextProps.location !== this.props.location) &#123; // 已经跳转了！ &#125;&#125; 你可以在不同环境中使用 location ： Web Link to Native Link to Redirect to history.push history.replace通常情况下，你只需要给一个字符串当做 location ，但是，当你需要添加一些 location 的状态时，你可以对象的形式使用 location 。并且当你需要多个 UI ，而这些 UI 取决于历史时，例如弹出框（modal），使用location 对象会有很大帮助。12345678910111213/ 通常你只需要这样使用 location&lt;Link to=\"/somewhere\"/&gt;// 但是你同样可以这么用jsconst location = &#123; pathname: '/somewhere' state: &#123; fromDashboard: true &#125;&#125;&lt;Link to=&#123;location&#125;/&gt;&lt;Redirect to=&#123;location&#125;/&gt;history.push(location)history.replace(location) 最后，你可以把 location 传入一下组件： Route Switch这样做可以让组件不使用路由状态（router state）中的真实 location，因为我们有时候需要组件去渲染一个其他的 location 而不是本身所处的真实 location，比如使用动画或是等待跳转时。matchmatch 对象包含了 如何与URL匹配的信息。match 对象包含以下属性： params -（ object 类型）即路径参数，通过解析URL中动态的部分获得的键值对。 isExact - 当为 true 时，整个URL都需要匹配。 path -（ string 类型）用来做匹配的路径格式。在需要嵌套 的时候用到。 url -（ string 类型）URL匹配的部分，在需要嵌套 的时候会用到。你可以在以下地方获取 match 对象： 在 Route component 中，以 this.props.match 方式。 在 Route render 中，以 ({ match }) =&gt; () 方式。 在 Route children 中，以 ({ match }) =&gt; () 方式 在 withRouter 中，以 this.props.match 方式 matchPath 的返回值当一个 Route 没有 path 时，它会匹配一切路径，你会匹配到最近的父级。在 withRouter 里也是一样的。 null matches即使路径的路径与当前位置不匹配，&lt; Route &gt;也可以使用子属性来调用其子功能。 但在这种情况下，匹配将为null。 能够在匹配时渲染&lt; Route &gt;的内容可能是有用的，但是这种情况会产生一些挑战。 “解析”URL的默认方法是将match.url字符串拼接到“相对”路径。1`$&#123;match.url&#125;/relative-path` 如果在匹配为空时尝试执行此操作，最终会出现TypeError。 这意味着在使用子属性尝试连接&lt; Route &gt;内的“relative”路径是不安全的。 当你在生成空匹配对象的&lt; Route &gt;中使用没有path的&lt; Route &gt;时，会出现类似但更微妙的情况。1234567// location.pathname = '/matches'&lt;Route path='/does-not-match' children=&#123;(&#123; match &#125;) =&gt; ( // match === null &lt;Route render=&#123;(&#123; match:pathlessMatch &#125;) =&gt; ( // pathlessMatch === ??? )&#125;/&gt;)&#125;/&gt; 没有path属性的&lt; Route &gt;从其父级继承匹配对象。 如果她们的父匹配为null，那么她们的匹配也将为null。 这意味着a）任何子路由/链接必须是绝对路径，因为没有要解析的父级b）父级匹配可以为null的无路径路由将需要使用子属性来渲染。 matchPath这允许您使用与一样使用的相同的代码，除了在正常渲染循环之外，例如在服务器上渲染之前收集数据依赖关系1234567import &#123; matchPath &#125; from 'react-router'const match = matchPath('/users/123', &#123; path: '/users/:id' exact: true, strict: false&#125;) pathname第一参数是你想要匹配的 pathname, 如果你正在服务端的 nodos.js 下使用, 将会是 req.url props第二个参数是不予匹配的属性, 他们于匹配 Route 接收的参数属性是相同的12345&#123; path, // like /users/:id strict, // 可选, 默认 false exact // 可选, 默认 false&#125; withRouter你可以通过withRouter的高阶组件访问history对象的属性和最相似的&lt; Route &gt;的匹配。 每次路由更改时，无论如何是如何渲染的，withRouter将会给封装的组件传递更新的match,location 和 history属性。12345678910111213141516171819202122mport React from \"react\";import PropTypes from \"prop-types\";import &#123; withRouter &#125; from \"react-router\";// A simple component that shows the pathname of the current locationclass ShowTheLocation extends React.Component &#123; static propTypes = &#123; match: PropTypes.object.isRequired, location: PropTypes.object.isRequired, history: PropTypes.object.isRequired &#125;; render() &#123; const &#123; match, location, history &#125; = this.props; return &lt;div&gt;You are now at &#123;location.pathname&#125;&lt;/div&gt;; &#125;&#125;// Create a new component that is \"connected\" (to borrow redux// terminology) to the router.const ShowTheLocationWithRouter = withRouter(ShowTheLocation); 重要提醒withRouter不追踪location的更改，而是在从&lt; Router &gt;组件传播出去的location改变后重新渲染，这意味着withRouter不会在路由改变时重新渲染，除非她的父组件重新渲染。 静态方法和属性。 封装的组件的所有非React的静态方法和属性都会被自动的复制到已连接的组件。 Component.WrappedComponent封装的组件作为返回组件上的静态属性WrappedComponent暴露，这个组件可以用于测试。123456// MyComponent.jsexport default withRouter(MyComponent)// MyComponent.test.jsimport MyComponent from './MyComponent'render(&lt;MyComponent.WrappedComponent location=&#123;&#123;...&#125;&#125; ... /&gt;) wrappedComponentRef: func作为引用的属性被传递给封装的组件的函数123456789class Container extends React.Component &#123; componentDidMount() &#123; this.component.doSomething(); &#125; render() &#123; return &lt;MyComponent wrappedComponentRef=&#123;c =&gt; (this.component = c)&#125; /&gt;; &#125;&#125;","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"React Router","slug":"React-Router","permalink":"http://yoursite.com/tags/React-Router/"}],"keywords":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}]},{"title":"webpack入门学习笔记15 —— Webpack中的三个小插件","slug":"webpack入门学习笔记15 —— Webpack中的三个小插件","date":"2019-08-10T16:00:00.000Z","updated":"2019-12-15T05:25:44.810Z","comments":true,"path":"2019/08/11/webpack入门学习笔记15 —— Webpack中的三个小插件/","link":"","permalink":"http://yoursite.com/2019/08/11/webpack入门学习笔记15 —— Webpack中的三个小插件/","excerpt":"","text":"1. 写在前面在前面的博客中我们说过，webpack之所以有这么强大的功能，是因为它借助了很多 loader 和 插件 的帮助。在之前webpack配置中，我们已经介绍了很多 loader 和 插件 ，在这里再介绍三种小插件，可以帮助我们更好地使用webpack构建项目。 这三款插件分别是：CleanWebpackPlugin、CopyWebpackPlugin、BannerPlugin(webpack内置插件)。下面一一对这些插件进行介绍。 2. CleanWebpackPlugin该插件的作用是：每次进行 build 的时候，将之前的dist目录下的代码清除，然后再打包生成新的代码文件。 当我们在使用 build 命令进行打包编译项目的时候，webpack会根据配置信息，将打包编译好的项目输出到一个文件夹中(默认文件夹是dist) 。在项目的开发过程中，我们肯定会多次执行 build 命令，这个时候我们希望每次执行 build 命令的时候，都可以将之前打包生成的代码文件删除，然后生成最新的代码文件。 但是实际情况却是之前的代码不会删除，比如：第一次打包编译项目，生成了a.js文件，第二次打包编译项目，生成了b.js文件。这个时候，a.js文件使用不到的，但该文件还是会存在dist文件夹下，这是我们不愿意看到的。 这里我们可以借助CleanWebpackPlugin插件进行删除之前的文件，首先执行以下命令进行安装插件： 1yarn add clean-webpack-plugin -D 安装完成之后，在 webpack.config.js 文件中书写以下代码进行配置： 1234567891011let CleanWebpackPlugin = require('clean-webpack-plugin')module.exports = &#123; /* 节省篇幅，其余配置已省略 */ plugins: [ new CleanWebpackPlugin([ './dist' // 指定你要清楚文件的目录，可以传入多个目录参数 ]) ] &#125; 这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 GitHub仓库 - webpack-learning ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。 3.CopyWebpackPlugin该插件的作用是：在每次进行 build 的时候，将某些静态资源复制到特定文件夹下。 比如将一些特定的Excel文件，拷贝到dist 目录下，可以借助这款插件的帮助。使用这款插件，首先要执行以下命令进行安装： 1yarn add copy-webpack-plugin -D 配置代码也是非常简单，直接在 webpack.config.js 文件中书写以下代码： 1234567891011let CopyWebpackPlugin = require('copy-webpack-plugin')modules.export = &#123; /* 节省篇幅，其余配置已省略 */ plugins: [ new CopyWebpackPlugin([ // 参数是数组，可以对多个位置的文件进行copy &#123; from: './doc', to: './dist' &#125; ]) ]&#125; 这里需要说明的是，这里的 from 和 to 属性根据自己的实际情况进行配置。 4. BannerPlugin(webpack内置插件)这是一款webpack的内置插件，作用是：代码版权声明插件，在编译好的 .js 文件的头部插入我们指定的版权声明文字，起到版权声明的作用。 既然是webpack内置插件，所以我们不用额外进行安装，可以直接进行在 webpack.config.js 文件中进行配置，示例代码如下： 12345678let webpack = require('wepack');modules.export = &#123; plugins: [ // 参数是你要一个字符串，值是你要添加的版权声明信息 new webpack.BannerPlugin('Made by Allen Feng') ]&#125; 配置完成之后，再次进行打包编译项目，就可以在生成的 .js 文件中看到我们的版权信息： 1/*! Made by Allen Feng */!function(e)&#123;var n=&#123;&#125;;function t(r)&#123;if(n[r])return n[r]...... 5. 写在最后以上便是这三款小插件，可以帮助我们更好的使用webpack构建项目。","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}]},{"title":"webpack入门学习笔记12 —— 打包编译后文件的引入路径问题","slug":"webpack入门学习笔记12 —— 打包编译后文件的引入路径问题","date":"2019-08-03T16:00:00.000Z","updated":"2019-12-15T05:25:44.809Z","comments":true,"path":"2019/08/04/webpack入门学习笔记12 —— 打包编译后文件的引入路径问题/","link":"","permalink":"http://yoursite.com/2019/08/04/webpack入门学习笔记12 —— 打包编译后文件的引入路径问题/","excerpt":"","text":"1. 写在前面在一些基于Webpack的项目中，我们可能会遇到这个情况：使用本地开发服务器开发项目的时候，项目可以正常运行，所需要的资源也能正常请求到。但是项目经打包编译，部署到服务器上之后，会报错一些 404 的错误，显示一些图片文件、css文件或js文件等找不到。 这是因为打包后的项目文件的引用路径问题，如果我们不做额外配置，打包编译后得到的 .html 文件的代码如下： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=en&gt;&lt;head&gt; &lt;meta charset=UTF-8&gt; &lt;meta name=viewport content=\"width=device-width,initial-scale=1\"&gt; &lt;meta http-equiv=X-UA-Compatible content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link href=css/main.css rel=stylesheet&gt; &lt;!-- 注意这里的文件引入路径 --&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=logo.png alt=\"\"&gt; &lt;!-- 注意这里的文件引入路径 --&gt; &lt;script type=text/javascript src=index.js&gt;&lt;/script&gt; &lt;!-- 注意这里的文件引入路径 --&gt;&lt;/body&gt;&lt;/html&gt; 这个时候，如果是在本地开发服务器中查看项目，是没有问题的。因为在本地开发服务器下，有且只有我们当前开发的这一个项目，并且项目所需要的文件，也都可以通过开发服务器的根域名获取到。比如可以直接通过 localhost：8080/css/main.css 找到相关文件。 但是真实的服务器上可能有很多项目，想要访问项目文件，需要通过 域名+项目目录 来访问，比如 www.fengzhen8023.com/myProject/css/main/css 来访问。 但是如上面 .html 文件所示，文件的引入路径中，没有项目目录名。所以会直接到根域名下找所需要的资源，那么最终肯定是获取不到，报出一些404的错误。 所以根据服务器部署的实际情况，我们在打包编译项目的时候，需要做一些额外配置，使得在引入文件资源的时候，在前面加一些路径，比如域名或者项目文件名等，使得文件可以被正常引入。 这也是本篇博客的主要内容，包括两个方面： 在所有的文件引用路径中，添加前缀域名 单独给图片文件引用路径中，添加前缀域名 2. 在所有的文件引用路径中，添加前缀域名为了达到这个目的，我们需要在 webpack.config.js 文件中进行配置，配置的方法非常简单，这里直接给出代码： 12345678module.exports = &#123; /* 节省篇幅，其他配置已省略 */ output: &#123; filename: \"index.js\", // 出口文件的文件名 path: path.resolve(__dirname, \"build\"), //出口文件的路径，注意一定要是绝对路径 publicPath: 'http://www.fengzhen8023.com/myProject/' // 给所有的文件引用路径中，添加前缀域名 &#125;&#125; 这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 GitHub仓库 - webpack-learning ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。 配置完成之后，再次进行打包编译项目，得到的 .html 文件如下： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=en&gt;&lt;head&gt; &lt;meta charset=UTF-8&gt; &lt;meta name=viewport content=\"width=device-width,initial-scale=1\"&gt; &lt;meta http-equiv=X-UA-Compatible content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link href=http://www.fengzhen8023.com/myProject/css/main.css rel=stylesheet&gt; &lt;!-- 注意这里的文件引入路径 --&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=http://www.fengzhen8023.com/myProject/logo.png alt=\"\"&gt; &lt;!-- 注意这里的文件引入路径 --&gt; &lt;script type=text/javascript src=http://www.fengzhen8023.com/myProject/index.js&gt;&lt;/script&gt; &lt;!-- 注意这里的文件引入路径 --&gt;&lt;/body&gt;&lt;/html&gt; 如此，部署到服务器上的项目，就可以正常访问所需要的文件了。 3. 单独给图片文件引用路径中，添加前缀域名在上一节中，我们知道如何给项目中所需要引入的文件添加前缀，这里在介绍，如何单独给图片资源引用路径添加前缀域名，使得项目更具灵活性。 这个时候需要使用到一个laoder—— url-loader，使用之前首先要进行安装，命令如下： 1yarn add url-loader -D 安装完成之后，在 webpack.config.js 中进行如下配置： 1234567891011121314151617module.exports = &#123; /* 节省篇幅，其他配置已省略 */ module: &#123; rules: [ &#123; test: /\\.(png|jpg|jpeg|gif)$/, use: &#123; loader: 'url-loader', options: &#123; limit: 2 * 1024, // 小于2k的图片，直接使用Base64编码进行处理 outputPath: '/image/' &#125; &#125; &#125; ] &#125;&#125; 关于url-loader和Base64的相关介绍，大家可以查看我的上一篇博客: 在项目中对打包编译的文件进行分类，里面有较为详细的介绍。 配置完成，再次编译项目的时候，得到的 .html 文件中的代码如下： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=en&gt;&lt;head&gt; &lt;meta charset=UTF-8&gt; &lt;meta name=viewport content=\"width=device-width,initial-scale=1\"&gt; &lt;meta http-equiv=X-UA-Compatible content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link href=css/main.css rel=stylesheet&gt; &lt;!-- css文件引用路径没有做处理 --&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=/image/logo.png alt=\"\"&gt; &lt;!-- 注意这的图片的引用路径 --&gt; &lt;script type=text/javascript src=index.js&gt;&lt;/script&gt; &lt;!-- js文件引用路径没有做处理 --&gt;&lt;/body&gt;&lt;/html&gt; 4. 写在最后以上便是这篇博客的全部内容，如果你想对其他的文件单独进行引用路径的修改，可以查阅相关的文档，不过大致思路是： 给处理这些文件的loader配置相关的属性，来指定打包编译后，文件的引用路径。","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}]},{"title":"webpack入门学习笔记13 —— 使用Webpack打包多页面应用","slug":"webpack入门学习笔记13 —— 使用Webpack打包多页面应用","date":"2019-08-03T16:00:00.000Z","updated":"2019-12-15T05:25:44.809Z","comments":true,"path":"2019/08/04/webpack入门学习笔记13 —— 使用Webpack打包多页面应用/","link":"","permalink":"http://yoursite.com/2019/08/04/webpack入门学习笔记13 —— 使用Webpack打包多页面应用/","excerpt":"","text":"1. 写在前面如果你熟悉Vue或者React的话，那么你肯定知道使用这些框架创建的应用属于 单页面应用 。这些框架底层使用的就是Webpack来构建项目，通过对项目文件进行打包编译，最终生成一个 .html 文件，所以我们说这些应用属于 单页面应用。 但是在使用webpack进行构建项目的时候，不仅可以构建单页面应用，还可以构建多页面应用。 在实际的项目中，如果该项目初期使用的就是 脚手架（比如Vue脚手架或者React脚手架） 搭建起来的，那么该项目大多是单页面应用。 但是如果项目在前期不是使用 脚手架 搭建起来的，比如使用 jQuery 库来开发的。但是后期有几个大的业务逻辑，需要使用 Vue脚手架 或者是 React脚手架 来开发，这个时候可能就需要使用Webpack来构建多页面应用，每一个大的业务逻辑对应一个单页面应用。 所以在这篇博客中，我就来跟大家介绍一下如何使用Webpak，构建多页面应用。主要内容包括： 如何通过打包编译，生成不同的 .js 文件 如何在 .html 文件中，引入指定的 .js 文件 2. 如何通过打包编译，生成不同的 .js 文件如果你看过我之前的博客，那么你就会知道在 webpack.config.js 文件中，有以下的配置： 1234567module.exports = &#123; entry: \"./src/index.js\", // 打包的入口文件，默认是src目录下的index.js文件 output: &#123; // 配置文件默认是dist目录下的main.js文件 filename: \"index.js\", // 出口文件的文件名 path: path.resolve(__dirname, \"build\"), //出口文件的路径，注意一定要是绝对路径 &#125;&#125; 通过以上的配置，webpack就可以找到项目的入口文件（./src/index.js）来对项目进行打包编译，最终生成的就是一个单页面应用。这就给我们提供一个思路：如果我们想要使用webpack打包编译，生成多页面应用，也要通过修改这两个配置属性来完成。 想要构建多页面应用，配置方式非常简单，这里直接给出配置代码，然后再作出解释： 12345678910module.exports = &#123; entry: &#123; // 指定入口文件 'home': \"./src/index.js\", 'other': \"./src/other.js\" &#125;, output: &#123; // 配置文件默认是dist目录下的main.js文件 filename: \"[name].js\", // 出口文件的文件名 path: path.resolve(__dirname, \"build\"), //出口文件的路径，注意一定要是绝对路径 &#125;,&#125; 通过上面的代码，我们可以看到，entry 属性的值由字符串变为了对象。在该对象中，我们配置了两个属性，这就表明，我们准备使用webpack来构建 两个 单页面应用，分别是 home 应用和 other 应用。他们都有一个对应的入口文件，webpack在打包编译的时候，就是从他们的入口文件触发，分别构建对应的单页面应用。 同时我们还修改了 output.filename 这个属性，不再是固定的 index.js，而是 [name].js 。这样就可以通过 entry对象 的两个属性（即home和other）来动态生成对应的 .js 文件。 现在你可以在 src文件夹 下创建两个入口文件 index.js 和 other.js ，在里面写对应的代码，然后执行webpack的 build 命令，就可以进行打包编译，最终会生成两个文件，即 index.js 和 other.js ，到这一步多页面应用的 .js 文件已经构建完成了。 3. 如何在 .html 文件中，引入指定的 .js 文件现在多页面应用的 .js 文件已经构建完成，但是我们还需要在 .html 文件中引入 .js 文件，多页面应用才算是正式完成，所以这一节我们介绍如何在 .html 文件中引入 .js 文件。 想要达到这个目的，我们需要解除 html-webpack-plugin 这一插件的帮助，首先执行以下代码进行安装： 1yarn add html-webpack-plugin -D 安装完成之后，到 webpack.config.js 文件中做以下配置： 123456789101112131415161718let HtmlWebpackPlugin = requier('html-webpack-plugin')module.exports = &#123; /* 节省篇幅，其余配置已省略 */ plugins: [ new HtmlWebpackPlugin(&#123; template: './index.html', filename: 'home.html', chunks: ['home'] &#125;), new HtmlWebpackPlugin(&#123; template: './index.html', filename: 'other.html', chunks: ['other'] // chunks: ['other', 'home'] // 也可以引入多个 .js 文件 &#125;), ]&#125; 这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 GitHub仓库 - webpack-learning ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。 因为我们这里构建的是两个单页面应用，所以这里要创建两个 HtmlWebpackPlugin 对象，在每个对象中，都有三个属性，这里一一对这些属性做出解释： template: 这是模板文件，webpack会在这个文件中，通过 &lt;script src=&quot;&quot;&gt;&lt;/script&gt; 标签引入打包编译生成的 .js 文件，生成最终的 .html 页面文件。 filename: 在模板文件中引入 .js 文件，会生成一个新的 .html 文件，通过 filename 属性，可以指定生成的 .html 文件的名称。 chunks: 现在模板文件和打包编译的 .js 文件都已经有了，但是要在模板文件中引入哪些 .js 文件呢？可以通过 chunks 属性来指定。我们可以通过数组的形式，指定一个或多个 .js 文件，这样就可以在模板文件中引入一个或多个 .js 文件。 有了上面的配置，现在执行webpack的 build 命令，就可以进行打包编译，最终最终会生成 home.html 和 other.html 两个文件，也就是两个单页面应用。如此一来，我们就使用webpack成功构建了多页面应用。 4. 写在最后到此为止，我们如何使用webpack构建多页面应用，并且生成了对应的 .html 文件，现在到项目中，使用这些 .html 文件，就可以使用我们开发的应用了。","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}]},{"title":"webpack入门学习笔记10 —— 在项目中使用图片资源","slug":"webpack入门学习笔记10 —— 在项目中使用图片资源","date":"2019-07-27T16:00:00.000Z","updated":"2019-12-15T05:25:44.808Z","comments":true,"path":"2019/07/28/webpack入门学习笔记10 —— 在项目中使用图片资源/","link":"","permalink":"http://yoursite.com/2019/07/28/webpack入门学习笔记10 —— 在项目中使用图片资源/","excerpt":"","text":"1. 写在前面在前端项目中，图片是必不可少的一种资源。在使用图片的时候，我们可以有以下几种方式： 在 .html 文件中，通过 &lt;img src=&quot;&quot; alt=&quot;&quot;&gt; 标签引入图片 在 .css 文件中，通过 background: url() 属性来引入图片 在 .js 文件中，通过 import 或者 require 语法来引入图片 但是在基于webpack的项目中，如果你只是简单的引入，而没有对这些图片文件做一些配置处理的话，是不能成功的。比如，如果你在一个 .js 文件中书写以下代码： 12import logo from './logo.png'console.log(logo); 或者在 .css 文件中，书写以下代码： 1234body &#123; background-color: gray; background: url('./logo.png')&#125; 那么在进行打包编译项目或者启动本地开发服务器的时候，会报出以下错误： 错误提示很明显：我们需要一个合适的loader来处理这些图片文件。 那么在这篇博客中，我们就来讲述一下：如何进行配置webpack，使得图片资源可以在项目中被正常地使用。主要内容包括： 使用 file-loader 处理图片资源 使用 html-withimg-loader 处理图片资源 2. 使用 file-loader 处理图片资源首先讲述如何使用 file-loader 来处理图片资源，既然是一个loader，那么第一步肯定是安装，安装命令如下： 1yarn add file-loader -D 安装完成之后，到 webpack.config.js 文件中进行配置，配置规则非常简单，这里直接给出代码： 12345678910111213module.exports = &#123; /* 节省篇幅，其他配置信息已省略 */ module: &#123; rules: [ &#123; test: /\\.(png|jpg|jpeg|gif)$/, // 使用正则匹配文件图片 use: &#123; loader: 'file-loader' // 使用file-loader对这些文件进行处理 &#125; &#125; ] &#125;&#125; 这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 GitHub仓库 - webpack-learning ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。 这里介绍一下 file-loader 的作用：对项目中使用到的图片文件进行处理，将处理后的文件保存到 输出文件夹 ，并返回输出文件夹下该文件的 URL 。如此一来，这个文件就可以被正常使用。 下面我们在项目中体验一下这个loader的作用，在一个 .js 文件中书写以下代码，使用图片资源： 1234567import logo from './logo.png' // 引入图片console.log(logo); let img = new Image();img.src = logo;document.getElementsByTagName('body')[0].appendChild(img); 打包编译之后，就可以在页面上看到这样图片了。 同理，在 .css 文件中也可以正常使用图片资源，参考代码如下： 1234body &#123; background-color: gray; background: url('./logo.png')&#125; 如果这时候，你在 .html 文件中 &lt;img src=&quot;&quot; alt=&quot;&quot;&gt; 标签引入图片，webpack一样会报错。仅靠file-loader做不到这一点，为了解决这个问题，我们需要 在file-loader的基础上，使用下面讲到的loader。 3. 使用 html-withimg-loader 处理图片资源这个loader的作用是：处理 .html 文件中引用的图片，使得图片能够被正常使用。但是要注意，使用这个loader的时候，同时也要使用上面的 file-loader 。 和上面一样，首先我们要做的还是进行安装，安装命令如下： 1yarn add html-withimg-loader -D 安装完成之后，到 webpack.config.js 文件中进行配置，配置规则非常简单，这里直接给出代码： 12345678910111213141516171819module.exports = &#123; /* 节省篇幅，其他配置信息已省略 */ module: &#123; rules: [ // 配置 file-loader &#123; test: /\\.(png|jpg|jpeg|gif)$/, use: &#123; loader: 'file-loader' &#125; &#125;, // 配置 html-withimg-loader &#123; test: /\\.html$/, use: 'html-withimg-loader' &#125; ] &#125;&#125; 配置完成之后，我们就可以在 .html 文件中正常使用图片，比如以下代码： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 引入logo.png图片 --&gt; &lt;img src=\"./logo.png\" alt=\"\"&gt; &lt;/body&gt;&lt;/html&gt; 现在进行打包编译项目，得到编译后的 index.html 文件代码如下： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=en&gt;&lt;head&gt; &lt;meta charset=UTF-8&gt; &lt;meta name=viewport content=\"width=device-width,initial-scale=1\"&gt; &lt;meta http-equiv=X-UA-Compatible content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 注意这里的图片引用路径不再是logo.png --&gt; &lt;!-- 这个路径是 file-loader 对文件处理后生成新文件的路径 --&gt; &lt;img src=2b9a35ac93ae4d5ea1eb21230d61c324.png alt=\"\"&gt;&lt;/body&gt;&lt;/html&gt; 这个时候在浏览器中打开编译后的 index.html 文件，就可以看到我们的图片了。 4. 优化图片处理方式，减少http请求在编写前端项目的过程中，我们可能会用到很多图片资源，有些图片非常小，只有几KB。但是这些小图片的数量有时却非常大，有的项目中可能有几十个甚至是上百个图片。 这就会导致一个问题：项目上线之后，为了请求这些图片资源，浏览器端会大量使用http请求来获取图片，这就可能导致浏览器的开销过大，性能较低。那么怎么来解决这个问题呢？ 这里我们介绍一种编码方式——Base64编码。这不是一种加密解密方式，它是一种编码方式。简单来说，它的作用就是：使用字符来表示任意二进制文件（这些字符包括：A B … Z a b … z 0 1 … 9 + / 等64个字符）。 为了更加贴切的体会Base64编码，你可以复制以下长长的Base64编码，粘贴到浏览器地址栏，便可以看到这段Base64编码表示的图片了。 1data:image/png;base64,iVBORw0KGgoAAAANSUhEU 中间省略很长很长一段编码 AABJRU5ErkJggg== 使用Base64对图片进行编码，就可以将这些图片切入到静态的 .html 文件中，这样就不需要再使用http请求来获取图片了，从而节省浏览器开销，提高性能。 为了在基于Webpack的项目中使用Base64编码处理图片，我们需要使用 url-loader 来进行处理。首先安装该loader，安装命令如下： 1yarn add url-loader -D 安装完成之后，我们到 webpack.config.js 文件中进行相关配置，配置非常简单，代码如下： 12345678910111213141516module.exports = &#123; /* 节省篇幅，其他的配置信息已省略 */ module: &#123; rules: [ &#123; test: /\\.(png|jpg|jpeg|gif)$/, use: &#123; loader: 'url-loader', options: &#123; limit: 200*1024 // 小于200k的图片，使用Base64进行处理 &#125; &#125; &#125; ] &#125;&#125; 这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 GitHub仓库 - webpack-learning ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。 上述配置非常好理解：对于png、jpg等图片格式的资源，使用url-loader进行处理，如果图片小于200k，那么就是用Base64进行编码；如果图片大于200k，就不做处理，使用http请求来获取图片。 配置完成之后，当我们编译项目时，就会在生成的 .html 文件中看到使用Base64编码后的图片，由于内容较多，就不贴代码，想查看的编译后代码的同学，可以点击 Github连接 进行查看。 5. 写在最后这是本篇博客的全部内容，关于 file-loader 的更多知识，推荐大家访问 webpack官网 - file-loader 。","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}]},{"title":"webpack入门学习笔记11 —— 在项目中对打包编译的文件进行分类","slug":"webpack入门学习笔记11 —— 在项目中对打包编译的文件进行分类","date":"2019-07-27T16:00:00.000Z","updated":"2019-12-15T05:25:44.808Z","comments":true,"path":"2019/07/28/webpack入门学习笔记11 —— 在项目中对打包编译的文件进行分类/","link":"","permalink":"http://yoursite.com/2019/07/28/webpack入门学习笔记11 —— 在项目中对打包编译的文件进行分类/","excerpt":"","text":"1. 写在前面在前面的博客中，我们对Webpack项目进行了很多配置，也多次打包编译了项目。如果你细心观察的话，你会看到，项打包编译后的目代码,全部都放在了 build 文件夹下，没有根据文件格式的不同再次进行分类。 但是我们所期望的场景是：项目打包编译之后，对文件进行分类，不同的文件放在不同的文件夹下。比如打包编译后，图片全部都放在 build/images 文件夹下，样式文件全部放在 build/css 文件夹下，这样便于管理项目。如下图所示： 那么需要如何配置，才能达到这个目的呢？在这篇博客中，我会跟大家分享。 本片博客的主要内容有： 将图片文件进行分类 将CSS样式文件进行分类 2. 将图片文件进行分类想要对图片进行分类，我们需要使用 url-loader 来处理图片文件。第一步还是安装该loader，安装命令如下： 1yarn add url-loader -D 安装完成之后，到 webpack.config.js 中进行配置，配置规则非常简单，这里直接给出代码： 12345678910111213141516module.exports = &#123; /* 节省篇幅，其余配置已省略 */ module: &#123; rules: [ &#123; test: /\\.(png|jpg|jpeg|gif)$/, use: &#123; loader: 'url-loader', options: &#123; limit: 2 * 1024, // 小于2k的图片，直接使用Base64编码进行处理 outputPath: '/image/' &#125; &#125; &#125; ] &#125;&#125; 这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 GitHub仓库 - webpack-learning ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。 下面对上述配置进行简单解释： 使用url-loader处理图片资源的时候，需要指定 limit 属性，当图片小于该属性大小的时候，直接使用Base64编码处理图片，不会再项目中生成图片文件。 当图片大于该属性大小的时候，不使用Base64编码处理图片，而是将该图片放到 build 文件夹下，如果指定了 outputPath 属性，那么图片会放到该属性指定的目录下。 3. 将CSS样式文件进行分类对打包编译后的CSS文件进行分类，需要借助一个插件，即：mini-css-extract-plugin 。使用之前需要使用以下命令进行安装： 1yarn add mini-css-extract-plugin -D 安装完成之后，进行以下配置： 123456789let MiniCssExtract = require('mini-css-extract-plugin') // 引入插件/* 节省篇幅，其余配置已省略 */module.exports = &#123; plugins: [ new MiniCssExtract(&#123; filename: 'css/main.css' // 配置CSS输出位置 &#125;), ]&#125; 配置完成之后，进行打包编译项目，就会看到编译后的CSS文件在 build/css 文件夹之下了。 4. 写在最后以上便是本篇博客的所有内容，希望对一些初次接触Webpack的前端小白有所帮助。 文章中如有错误之后，还希望各位大佬予以纠正。","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}]},{"title":"webpack入门学习笔记08 —— 使用ESLint检查项目代码","slug":"webpack入门学习笔记08 —— 使用ESLint检查项目代码","date":"2019-07-20T16:00:00.000Z","updated":"2019-12-15T05:25:44.807Z","comments":true,"path":"2019/07/21/webpack入门学习笔记08 —— 使用ESLint检查项目代码/","link":"","permalink":"http://yoursite.com/2019/07/21/webpack入门学习笔记08 —— 使用ESLint检查项目代码/","excerpt":"","text":"1. 写在前面JavaScript作为一门动态语言，灵活性是它的一个优点，同时又是一个缺点。有的时候因为语法太过于灵活，导致一些隐藏的Bug被我们忽略，代码质量得不到保证。 为了提到项目代码的质量，大多数架构师在初始化项目的时候，都会使用一个检查工具来帮助实现代码的规范性和正确性，同时也可以提高项目代码后期的可维护性。在基于webpack的项目中，经常被使用到的代码检查工具是 ESLint 。 它就像是一个测试人员一样，告诉你哪里写得不对（errors），哪里写得不好（warnings）。那么在本篇博客中，就讲解如何在自己的项目中，配置使用 ESLint 这一检查工具。主要内容有： 安装并配置 ESLint-loader 根据实际情况，编写ESLint的配置文件 2. 安装并配置 ESLint-loaderESLint 这一代码检查工具在项目中的使用体现是一个 loader ，既然是loader，那么使用步骤和之前博客中讲述的几个loader一样，首先是安装，然后在webpack配置文件中，使用这些loader。 使用以下安装命令，安装 eslint 和 eslint-loader ： 1yarn add eslint eslint-loader -D 安装完成之后，在 webpack.config.js 文件中，配置使用该loader的规则，配置非常简单，代码如下： 123456789101112131415module: &#123; rules: [ /** 其他的配置规则，节省篇幅，故省略 **/ &#123; test: /\\.js$/, use: &#123; loader: 'eslint-loader', options: &#123; enforce: 'pre' &#125; &#125;, exclude: /node_modules/ &#125; ]&#125; 这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 GitHub仓库 - webpack-learning ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。 这里解释一下上面代码中标有注释的两个属性： enforce 和 exclude ： enforce: 该属性表示loader的种类，loader有四种：前置loader、后置loader、普通loader、内联loader 。该属性默认是 normal(即默认loader) 。可以根据需要设置成 pre(前置loader) 或者 post(后置loader) 。 属性的而不同导致loader的一些行为不同，前面博客中讲过：在webpack.config.js配置文件中，loader的执行顺序是 从右到左，从下到上 。但是： 如果是前置loader，那么webpack会 优先 使用该loader处理文件； 如果是后置loader，那么webpack会在普通loader 之后 处理文件； 如果是内联loader，可以在 .js 文件中使用，而 不只是 在webpack.config.js配置文件中使用。- exclude ：排除正则表达式匹配的文件或者文件夹，比如上述规则中，不使用eslint-loader对 node_modules 文件夹中的代码进行校验。 好了，现在配置完成之后，你是不是想马上体验一下ESLint的强大功能？如果这个时候你进行打包编译项目，那么会得到一下错误信息： 错误提示易懂，是因为我们没有配置ESlint的处理规则，这也是我们下面要讲述的知识点。 3. 编写ESLint的配置文件如果你对ESLint非常熟悉，那么完全可以自己动手编写该配置文件，但是大多数人可能对ESLint的配置不是那么熟悉，这里推荐大家到 官网的Demo配置页面 ,根据自己的需求，来获取ESLint配置文件： 在该页面，根据实际情况选择你的项目需要，然后点击页面底部的 Download .eslintrc.json file 即可下载得到一份ESLint配置文件。 将这个文件重命名（在文件名之前加一个 点）得到 .eslintrc.json 文件，然后将这个文件放到你的项目根目录下，和 webpack.config.js 文件同级。 如此一来，便配置好了ESLint。这个时候再来打包编译项目或者开启本地开发服务器，就可以看到ESLint发挥的作用了。比如，一个不规范的代码可能会得到以下错误提示： 4. 写在后面以上便是这篇博客的全部内容，如果想学习更多ESLInt的知识，推荐访问ESLint的官网：https://cn.eslint.org/ 。","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}]},{"title":"webpack入门学习笔记09 —— 在项目中引入全局变量","slug":"webpack入门学习笔记09 —— 在项目中引入全局变量","date":"2019-07-20T16:00:00.000Z","updated":"2019-12-15T05:25:44.807Z","comments":true,"path":"2019/07/21/webpack入门学习笔记09 —— 在项目中引入全局变量/","link":"","permalink":"http://yoursite.com/2019/07/21/webpack入门学习笔记09 —— 在项目中引入全局变量/","excerpt":"","text":"1. 写在前面在做项目的时候，我们可能会经常遇到这种场景：一个变量我在很多文件中都要用到。这变量可能是第三方包，或者是自己定义的一个工具类对象等。 比如在基于jQuery的多页面应用中，在每一个页面中都要使用到 jQuery对象 ；在单页面应用中，一个 消息提示框 在所有组件中都要用到。 这个时候我们应该怎么办，如果在所有页面中都引用这个变量的话，工作量比较大，而且对项目的维护也不是很友好。这篇博客就来讲解：如何高效便捷地引入全局变量。主要内容包括： 使用 webpack模块 注册全局变量 将变量暴露给 window对象 ，成为全局变量 我们jquery对象为例，讲解如何在基于webpack的项目中，注入全局变量。首先安装jquery包：1yard add jquery 2. 使用webpack模块注入全局变量这里要特别注意一下，webpack是一个工具，可以帮助我们构建项目，在这个工具里面，有一个 同名模块，叫做 webpack ，我们今天就是要使用这个模块来给每一个页面或者组件注入一个对象。 配置的规则很简单，这里先给出 webpack.config.js 文件中的配置代码，然后再进行解释： 12345678910/* 节省篇幅，其他的配置信息忽已略 */let Webpack = require('webpack') // 引入webpack模块module.exports = &#123; plugins: [ // 这是一个插件，所以要在plugins属性中配置 new Webpack.ProvidePlugin(&#123; $: 'jquery' &#125;) ],&#125; 这里将其他的配置规则省略了，如果你想看其他的配置规则，可以查看我的 GitHub仓库 - webpack-learning ,或者通过本文末尾的链接，跳转到我之前的博客中进行查看。 上述配置的作用是：给项目中的每一个文件，都注入一个对象 $ ，这个对象就是我们安装的jquery包。安装完成之后，在其他页面中无需引入，即可使用jQuery语法。比如某一个 .js 文件中书写以下代码： 12console.log($)console.log($(window)); 项目启动之后，就会在控制台输出jquery对象和选择的window对象。由此可知，我们成功注册了一个全局变量。 3. 将变量暴露给 window对象 ，成为全局变量从事前端开发的程序员都知道，JS的全局变量就是 window 对象的属性或方法，所以如果在项目中，如果我们能够把一个变量，设置成 window 对象的属性或者方法，那么它就成为了全局变量，就可以在其他文件中使用了。 想要达到这个目的，我们可以借助 expose-loader ，首先执行以下命令，进行安装： 1yarn add expose-loader -D expose-loader是一个 内联loader ，即可以字节在文件中使用，当然也可以在 webpack.config.js 配置文件中使用。我们先来讲解如何在文件中使用这一loader。 现在假设项目中有一个 index.js 文件，我们在这个文件中将 $对象 暴露给 window 对象，使之成为全局变量，那么可以书写以下代码： 1234import $1 from 'expose-loader?$!jquery' // 引入jquery对象，并将该对象暴露给window的$属性console.log($1)console.log(window.$); 可能上面的代码你看着有些头晕，我来讲解一下： 首先通过 import 命令，从安装的jquery包中导入一个对象，将这个对象命名为 \\$1 ，\\$1 不是全局对象。 通过 expose-loader?$!jquery 命令，从安装的jquery模块中导入一个对象，将这个对象添加到 window 对象的 \\$ 属性上。这样一来，就得到了一个全局变量 window.\\$ ，即 $ 。 如果你不喜欢在文件使用内联loader设置全局对象，那么可以在 webpac.config.js 文件中，进行配置，配置代码如下： 123456789module.exports = &#123; module: &#123; rules: [&#123; test: require.resolve('jquery'), // 匹配到引入jquery的文件 use: 'expose-loader?$' // 使用 expose-loader 进行处理 &#125; ] &#125;&#125; 然后你就可以在 index.js 文件中正常地引入jquery包，webpack会来使用 expose-loader 自动帮我们暴露全局变量。 index.js 文件代码参考如下： 1234import $1 from 'jquery' // 正常导入jquery包console.log($1)console.log(window.$); 这样设置之后，在其他的 .js 文件中，就无须再导入jquery，方便快捷。 4. 写在后面上面介绍了两种设置全局变量的方式，就我个人来说，比较喜欢第一种，大家可以根据需要和喜好，自行选择。 这就是本篇博客的全部内容了，大家加油，学懂webpack！","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}]},{"title":"webpack入门学习笔记07 ——  关于babel的一些补充","slug":"webpack入门学习笔记07 ——  关于babel的一些补充","date":"2019-07-12T16:00:00.000Z","updated":"2019-12-15T05:25:44.806Z","comments":true,"path":"2019/07/13/webpack入门学习笔记07 ——  关于babel的一些补充/","link":"","permalink":"http://yoursite.com/2019/07/13/webpack入门学习笔记07 ——  关于babel的一些补充/","excerpt":"","text":"1. 写在前面在之前的一篇博客中：使用babel打包编译js文件 ，简单介绍了如果在webpack中使用babel对高级JS语法进行转换，以方便浏览器能够识别。 但是babel的相关知识很多，不能面面俱到全部讲解，只能将我们项目中经常使用的一些插件或者配置介绍一下。我的目的是抛砖引玉，更多知识大家还是到babel官网学习：https://babeljs.io/ 。 这篇博客中，根据我的学习，对babel做一些补充。随着自己学习的深入，我也会时常跟新这篇博客，完善babel相关的知识点。这篇博客的主要内容如下： @babel/plugin-transform-runtime、@babel/runtime 插件的介绍 2. @babel/plugin-transform-runtime、@babel/runtime插件首先说一下这两款插件的使用场景，在之前的博客中提到过：babel默认配置的转化能力有限，只能将部分ES6语法转换成ES6语法，如果想要将更高级的ES6语法或者ES7等语法转成低级语法，需要进行额外的配置。 熟悉ES6语法的程序员肯定了解ES6语法中的 Generator 函数 和 Promise 对象 ，并且在项目中也会使用到这些高级语法。比如以下语法： 1234567function * generator() &#123; yield 1;&#125;console.log(generator().next(() =&gt; &#123; console.log('generator 执行完毕');&#125;)); 那么问题来了，当你打包编译项目之后，在浏览器端运行的时候，会发现控制台报错了： 这是因为babel的默认配置不支持转换这些高级语法，如果需要达到这个目的，就需要安装配置额外的插件，也就是我们现在提到的@babel/plugin-transform-runtime、@babel/runtime 插件。下面说一下如何安装配置： 首先安装 @babel/plugin-transform-runtime ，这是一个开发依赖，打包之后不需要这个包，所以执行下面的命令进行安装： 1yarn add @babel/plugin-transform-runtime -D 然后安装 @babel/runtime ，需要说明的是，这是运行环境中所需要的依赖包，打包编译之后还是也是需要它的，所以执行下面的命令进行安装： 1yarn add @babel/runtime 安装完成之后进行配置，配置的时候在上一篇博客配置babel的基础上进行配置即可，这里给出部分代码，具体的配置可以参考上一篇博客：使用babel打包编译js文件 。 1234567891011121314151617181920module: &#123; rules: [ &#123; test: /\\.js$/, use: &#123; loader: 'babel-loader', options: &#123; presets: [ '@babel/preset-env' // 预设，将ES6转成ES5 ], plugins: [ '@babel/plugin-proposal-class-properties', '@babel/plugin-transform-runtime' // 配置运行时的转换插件 ] &#125; &#125;, include: path.resolve(__dirname, 'src') // 只转换src目录下的代码 &#125; ]&#125; 进行如上配置之后，就可以顺利运行项目中的 Generator 函数 和 Promise 对象 等语法了。 这里提一句：上面配置中的 include ，表示只对 src目录 下的 .js 文件进行匹配。除此之外，还可以使用 exclude 进行显示，表示匹配出这些文件夹之外的 .js 文件，支持使用正则表达式，比如：exclude: /node_modules/ 。 3. 写在后面以上就是本篇博客的全部内容，随和后面学习的升入，博客会被时常更新，错误之处，还希望各位大神指出。","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}]},{"title":"webpack入门学习笔记01 —— webpack基本简介","slug":"webpack入门学习笔记06 —— 使用babel打包编译js文件","date":"2019-06-29T16:00:00.000Z","updated":"2019-12-15T05:25:44.806Z","comments":true,"path":"2019/06/30/webpack入门学习笔记06 —— 使用babel打包编译js文件/","link":"","permalink":"http://yoursite.com/2019/06/30/webpack入门学习笔记06 —— 使用babel打包编译js文件/","excerpt":"","text":"1. 写在前面在前端项目中，占主导地位的文件，我想应该是 .js 文件。随着 JS语言 的不断升级改进，越来越多的高级语法被加入到该语言中，比如我们熟知的 ES6语法、ES7语法 等。 虽然 ES6语法、ES7语法 我们写起来感觉非常方便，但是目前市面上的浏览器却不认识这些语法，这就导致我们辛辛苦苦做出来的项目却不能运行，让人很抓狂。这个时候我们要怎么办呢？ 办法肯定是有的，我们可以借助webpack这一工具，来将这些高级语法，转换成浏览器能够识别的低级语法（如ES5语法），这样就可以使项目正常运行了。而webpack之所以能够做到这一点，是因为它使用了 babel 这一工具。这是一个什么工具呢？这篇博客就会来讲解。 为了方便不同的读者都能从这篇博客中有所收获，本篇博客准备在前半部分介绍如何在webpack中配置 babel 来编译转换高版本语法，在后半部分会讲解关于 babel 的知识。大家各取所需，根据自己的实际情况来选择阅读哪一部分。 2. 在webpack中配置babel，编译高本版JS语法既然要使用 babel 我们就要先安装这些依赖包，这里我们需要安装三个包：babel-loader 、 @babel/core 、 @babel/preset-env ，安装命令如下： 1yarn add babel-loader @babel/core @babel/preset-env -D 简单介绍一下这是三个包的：babel-loader 和 @babel/core 是核心插件。@babel/preset-env 是babel的 预设 ，它的主要功能是将 ES6 语法转成 ES5 语法。 依赖包安装完成之后，要到 webpack.config.js 文件中进行配置，配置的步骤和前面博客中讲述的配置 .css 文件的步骤类似，这里直接给出配置代码（重点关注有注释的部分） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263let path = require(\"path\");let HtmlWebpackPlugin = require(\"html-webpack-plugin\")let MiniCssExtract = require('mini-css-extract-plugin')module.exports = &#123; devServer: &#123; port: 3000, progress: true, contentBase: \"./build\", compress: true &#125;, mode: \"development\", entry: \"./src/index.js\", output: &#123; filename: \"index.js\", path: path.resolve(__dirname, \"build\") &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'index.html', minify: &#123; removeAttributeQuotes: true, collapseWhitespace: true &#125;, hash: true &#125;), new MiniCssExtract(&#123; filename: 'main.css' &#125;) ], module: &#123; rules: [&#123; test: /\\.css$/, use: [ MiniCssExtract.loader, 'css-loader', 'postcss-loader' ] &#125;, &#123; test: /\\.less$/, use: [ MiniCssExtract.loader, 'css-loader', 'less-loader', 'postcss-loader' ] &#125;, &#123; test: /\\.js$/, // 匹配js文件，然后用下面所配置的工具对这些文件进行编译处理 use: &#123; loader: 'babel-loader', // babel的核心模块 options: &#123; presets: [ // 配置babel的预设，将ES语法转成ES5语法 '@babel/preset-env' ] &#125; &#125; &#125; ] &#125;&#125; 配置完成之后，我们就可以在项目中使用 ES6 语法来编写项目了。注意我这里说的是 ES6 语法，如果在项目中你使用了更新的 ES7 语法，仅靠上面的配置是不行的，在你进行打包编译的时候会报错，比如在项目中使用了以下的 ES7 语法： 12345class A &#123; className = 'A' &#125;let a = new A(); 这个时候再进行打包编译的时候，会报错以下错误：根据提示，是因为我们没有安装所需要的依赖包。 道理很简单，仅靠上面书写的 babel 配置，只能转换 ES6 语法，如果要转换更高版本的语法，就要进行其他配置，比如这里转换 ES7 语法。 根据提示，我们需要安装所需的包：@babel/plugin-proposal-class-properties ，安装代码如下： 1yarn add @babel/plugin-proposal-class-properties -D 安装完成之后，修改 webpack.config.js 文件中的 babel 配置，修改后的代码如下: 1234567891011121314&#123; test: /\\.js$/, use: &#123; loader: 'babel-loader', options: &#123; presets: [ '@babel/preset-env' ], plugins: [ // 配置babel插件，转换更更高版本语法 '@babel/plugin-proposal-class-properties' ] &#125; &#125;&#125; 同理，如果你在项目中使用了其他的高级语法，比如 装饰器 ，那么也是需要额外配置的，这里就不一一阐述，到时候你可根据webpack的报错信息，进行查找配置即可。 到这里webpack打包编译 .js 文件的相关知识已经讲完，下面结合自己的认识，介绍一些 babel 的知识。 3. babel是个什么东西首先列出babel的中文官网，更多知识可查阅该官网：https://www.babeljs.cn/ 。 根据官网的定义：Babel 是一个 工具链 ，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。 在具体的实践中，babel可以帮我们做一下事情： 语法转换 通过 Polyfill 方式在目标环境中添加缺失的特性 (通过 @babel/polyfill 模块) 源码转换 (codemods) 更多 … 对于前端小白来说，上面的文字还不足以帮助他们了解babel，下面我用大白话来说一下：我们将babel类比成手机上使用的 中英词典APP。 我们知道，手机上安装的 中英词典APP 可以帮助我们将不认识的英文翻译成我们熟知的汉语，这样我们就可以理解单词和句子表达的意义了。类似，babel 可以将我们写的 ES6 语法翻译成浏览器熟悉的 ES5 语法，这样，浏览器就可以知道这些 JS 代码要做什么事情了。比如下面的例子： 中英词典APP 在我们安装之初，就可以将英文成中文，是因为开发程序员在这个APP中预先设置了中英翻译功能。同理，babel 在配置之初就可以将 ES6 语法翻译成 ES5 语法，是因为我们在配置之初，给 babel 指定了 预设（presets） ，才使得 babel 可以做到这一点。 默认状态下，中英词典APP 可以将英语翻译成汉语，但是不能将俄语翻译成汉语，因为程序员在开发之前，没有预先设置这个功能，如果我们想要这款APP也可以翻译俄语，那么就需要下载额外的 俄语翻译扩展包 ，下载完成之后，就可以实现这个功能。 同理，在默认配置下， babel 可以将 ES6 翻译成 ES5 ，但是不能将 ES7 翻译成 ES5。这是因为在 babel 中有将 ES6 翻译成 ES5 的 预设（presets） ，没有将 ES7 翻译成 ES5 的 预设（presets） 。如果要实现这个功能，我们就需要下载配置额外的 插件，比如第一节提到的 @babel/plugin-proposal-class-properties 。插件 配置下载配置完成之后，就可以将 ES7 等更高级语法翻译成 ES5 语法。 通过babel的中文官网，我们可以看到对于不同版本的语法，有不同的插件。相当于在 中英词典APP 中，对于不同的语言，有不同的扩展包，需要什么扩展包，我们下载即可。 根据个人的经验，在使用这些插件的时候，项目开发之初不用配置。在打包编译的时候，如果报错了，再根据报错信息，查看缺少什么插件，然后再进行配置即可。当然，如果你经验很丰富，一开始就知道要使用那些插件，那么肯定要提前配置， 4. 写在最后好了，以上就是本篇博客的所有内容了，只是个人学习过程中的一些心得体会，如果有不当的地方，还希望各位大神给出指点。 如果你想深入学习 babel ，可以看他们官网的文档，个人觉得还是非常详细的：https://www.babeljs.cn/docs/","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}]},{"title":"webpack入门学习笔记05 —— 使用webpack打包编译css文件","slug":"webpack入门学习笔记05 —— 使用webpack打包编译css文件","date":"2019-06-22T16:00:00.000Z","updated":"2019-12-15T05:25:44.805Z","comments":true,"path":"2019/06/23/webpack入门学习笔记05 —— 使用webpack打包编译css文件/","link":"","permalink":"http://yoursite.com/2019/06/23/webpack入门学习笔记05 —— 使用webpack打包编译css文件/","excerpt":"","text":"1. 写在前面在前面的博客中，对webpack打包项目进行了简单介绍，而且都是关于打包编译 .js 文件的介绍。我们知道在一个基于webpack的项目中，肯定不止是 .js 文件，还有 .html 、.css、.png 等文件，在后面的博客中会给大家一一讲述，在这篇博客中，我们就介绍如何使用webpack打包编译 .css 文件。 主要内容包括： 如何在项目中引入 .css 文件 打包编译 .css 文件 打包编译 .less 文件 将css代码抽离为单个文件 给打包编译后的css3属性添加相关前缀 压缩编译后的 .css 文件 2. 如何在项目中引入 .css 文件之前我们提到过，webpack会对项目中的项目文件进行打包编译，然后将生成的文件挂载到一个 .html 模板文件中。这个时候如果要引入css样式，你可能会想：我将css样式直接写到 .html 模板文件中，或者将 .css 文件挂载到模板文件中，不就行了吗。例如下面的代码： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; background-color: red; color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是一个模板文件&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 首先从功能上分析，这种方式是可行的，无论你是使用 yarn dev 来启动开发服务器，还是使用 yarn build 来打包编译项目，最终你写的样式都是会存在，会起作用的。但是这种方法非常不好，也不规范，所以非常不推荐使用这种方式。那么该怎么来引入css代码呢？ 如果你是使用 Vue脚手架 或者 React脚手架 来构造项目的话，那么直接参考他们的官方教程来写css样式即可，如果你是从零手动搭建的项目，那么可以在 .js 文件中引入 .css 文件，例如下面的实例： 123456// index.js 文件console.log('我是 index.js 文件');require('./index.css') // 引入 .css 样式文件require('./b.less') // 引入 .less 样式文件 12345/* index.css 文件 */body &#123; background-color: red; color: yellow;&#125; 12345678/* b.less 文件 */body &#123; border: 5px solid #45454; div &#123; font-size: 20px; font-weight: bolder; &#125;&#125; 现在我们已经将 .css 文件和 .less 文件引入到项目中，但是这个时候，如果我们启动本地开发服务器或者打包编译项目，肯定会报错。 这是因为我们还没有进行相关的配置，webpack还不知道如何处理这些引入的文件。所及接下来要说的就是如何进行配置，使得webpack可以进行打包编译样式文件。 3. 打包编译 .css 文件webpack之所以能够打包编译项目中各式各样的文件，是因为它借助了很多功能强大的插件或者模块。所以如果我们想打包编译 .css 文件，首先安装两个loader模块： css-loader 和 style-loader 。安装命令如下： 1yarn add css-loader style-loader -D 安装完成之后，我们要在 webpack.config.js 文件中进行配置，这里我们先给出标准的配置代码，然后再详细讲解（重点关注有注释的部分）： 123456789101112131415161718192021222324252627282930313233let path = require(\"path\");let HtmlWebpackPlugin = require(\"html-webpack-plugin\")module.exports = &#123; mode: \"development\", entry: \"./src/index.js\", output: &#123; filename: \"index.js\", // path: path.resolve(__dirname, \"build\") &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'index.html', minify: &#123; removeAttributeQuotes: true, collapseWhitespace: true &#125;, hash: true &#125;), ], module: &#123; // 配置 webpack 使用到的模块 rules: [ &#123; test: /\\.css$/, // 针对 .css 结尾的文件，使用下面的loader进行处理 use: [ 'style-loader', 'css-loader' ] &#125; ], &#125;&#125; 在上面代码中，我们增添了 module 属性，该属性是一个对象，它里面又有一个 rules 属性，该属性是一个数组。在这个数组中，我们可以配置很多规则，分别指定对各种文件处理的程序（比如使用哪种loader进行处理等）。这里我们首先配置对 .css 的处理规则。 在 rules 数组中配置规则很简单，直接添加一个对象即可。如上面代码所示，我们要配置处理 .css 文件的规则，可以添加以下对象： 1234567&#123; test: /\\.css$/, // 针对 .css 结尾的文件，使用下面的loader进行处理 use: [ 'style-loader', 'css-loader' ]&#125; 该对象有两个属性：test 和 use test 属性是用来匹配文件的，一般我们使用正则表达式来匹配文件，上面代码中 /\\.css$/ 就是匹配以 .css 结尾的文件。 use 属性指定使用哪些程序，来对匹配到的文件进行处理。该属性是一个数组，这是因为对一个文件进行处理的时候，可能会用到多种程序。比如上面的代码中，我们制定使用 style-loader 和 css-loader 两种程序来处理 .css 文件，就需要将这两个程序写到数组中。 需要注意的是，这个数组中程序的顺序不能随便写，因为对文件进行处理的时候，webpack会按照从后向前的顺序，依次使用指定的程序来处理文件。 比如在处理index.css文件的时候，要先使用 css-loader 处理css语法，然后在使用 style-loader 将处理后的css挂载到 index.html 模板文件中。在写 use 属性的时候，就要将 style-loader 写在前面，将 css-loader 写在后面。 最后还想说的一点是，该属性中不仅可以写字符串，还可以写对象，用来更深次地配置处理文件的loader程序。比如：如果你想将处理好的 css 挂载到模板文件的顶部，可以这样配置： 123456789101112&#123; test: /\\.css$/, use: [ &#123; loader: 'style-loader', options: &#123; insertAt: 'top' // 将编译后的css挂载到模板文件的顶部 &#125; &#125;, 'css-loader' ]&#125;, 如果在指定属性的时候不知道如何书写，可以这些loader程序的官方文档，比如 style-loaderde 官方文档 。 配置完这些规则之后，使用 yarn dev 启动本地开发服务器或者使用 yarn build 对项目进行打包编译，webpack就可以顺利地使用我们配置的规则处理 .css 文件了。 4. 打包编译 .less 文件 如果项目中使用到了 less语法（一门 CSS 预处理语言 ） ，我们就要进行相关配置 .less 文件的处理规则。和处理 .css 文件类似，应该安装两个模块：less 和 less-loader。安装命令如下： 1yarn add less less-loader -D 配置的方法和上面讲到的方法如出一辙，所以这里直接给出配置的代码（重点关注有注释的部分）： 1234567891011121314151617181920212223242526272829303132333435363738394041let path = require(\"path\");let HtmlWebpackPlugin = require(\"html-webpack-plugin\")module.exports = &#123; mode: \"development\", entry: \"./src/index.js\", output: &#123; filename: \"index.js\", path: path.resolve(__dirname, \"build\") &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'index.html', minify: &#123; removeAttributeQuotes: true, collapseWhitespace: true &#125;, hash: true &#125;), ], module: &#123; // 配置 webpack 使用到的模块 rules: [ &#123; test: /\\.css$/, // 针对 .css 结尾的文件，使用下面的loader进行处理 use: [ 'style-loader', 'css-loader' ] &#125;, &#123; test: /\\.less/, use: [ 'style-loader', 'css-loader', 'less-loader' // less-loader将less语法转成常规的css语法 ] &#125; ], &#125;&#125; 配置完成之后，重启开发服务器或者重新打包编译，.less 文件就可以顺利地被编译。 5. 将css代码抽离为单个文件如前面所提到的那样，webpack会打包编译 .css 文件或者 .less 文件，将处理后的css代码挂载到模板文件中，但是有的时候我们不希望这样。我们希望将处理后的css代码输出到一个指定的文件中，然后在模板文件中 自动引入 该文件。如果要达到这个目的，可以进行如下配置： 首先安装一个插件 mini-css-extract-plugin， 安装命令如下： 1yarn add mini-css-extract-plugin -D 安装完成之后，直接进行如下配置即可（重点关注有注释的部分）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546let path = require(\"path\");let HtmlWebpackPlugin = require(\"html-webpack-plugin\")let MiniCssExtract = require('mini-css-extract-plugin') // 引入插件module.exports = &#123; mode: \"production\", entry: \"./src/index.js\", output: &#123; filename: \"index.js\", path: path.resolve(__dirname, \"build\") &#125;, plugins: [ // 配置插件 new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'index.html', minify: &#123; removeAttributeQuotes: true, collapseWhitespace: true &#125;, hash: true &#125;), new MiniCssExtract(&#123; // 创建该插件的实例 filename: 'main.css' // 指定输出的css文件的文件名 &#125;) ], module: &#123; rules: [&#123; test: /\\.css$/, use: [ MiniCssExtract.loader, // 配置规则，将处理后的css代码直接输出到指定文件中 'css-loader', 'postcss-loader' ] &#125;, &#123; test: /\\.less$/, use: [ MiniCssExtract.loader, // 配置规则，将处理后的css代码直接输出到指定文件中 'css-loader', 'less-loader', 'postcss-loader' ] &#125; ] &#125;&#125; 配置完成之后，直接 yarn build 进行打包编译项目，就会得到一个 main.css 文件，该文件中就是编译后的css代码，实例如下。 123456789101112131415/* main.css 文件 */body &#123; color: yellow;&#125;body &#123; background-color: gray; transform: rotate(45deg) /* 注意这一行css3代码，没有添加前缀，后面会提到 */&#125;body &#123; border: 5px solid #4545 4;&#125;body div &#123; font-size: 20px; font-weight: bolder;&#125; 关于这一块的更多配置，可以参考 mini-css-extract-plugin 官方文档 6. 给打包编译后的css属性添加相关前缀如上面展示的 main.css 代码所示，打包编译后的代码中，对一些 CSS3 属性没有添加相应的前缀，这在一些情况下可能不能满足项目的需求。如果我们想要达到自动给编译后的 CSS3 属性添加前缀，可以进行如下配置： 首先安装两个loader程序： postcss-loader 和 autoprefixer 。安装命令如下： 1yarn add postcss-loader autoprefixer -D 安装完成时候，首先配置 webpack.config.js 文件，实例如下（重点关注有注释的部分）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546let path = require(\"path\");let HtmlWebpackPlugin = require(\"html-webpack-plugin\")let MiniCssExtract = require('mini-css-extract-plugin')module.exports = &#123; mode: \"production\", entry: \"./src/index.js\", output: &#123; filename: \"index.js\", path: path.resolve(__dirname, \"build\") &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'index.html', minify: &#123; removeAttributeQuotes: true, collapseWhitespace: true &#125;, hash: true &#125;), new MiniCssExtract(&#123; filename: 'main.css' &#125;) ], module: &#123; rules: [&#123; test: /\\.css$/, use: [ MiniCssExtract.loader, 'css-loader', 'postcss-loader' // 给CSS3属性添加前缀 ] &#125;, &#123; test: /\\.less$/, use: [ MiniCssExtract.loader, 'css-loader', 'less-loader', 'postcss-loader' // 给CSS3属性添加前缀 ] &#125; ] &#125;&#125; 在上面代码中，我们指定了使用 postcss-loader 来处理 .css 和 .less 文件，但是现在webpack还不能自动给CSS3属性添加前缀，我们还需要进行配置postcss-loader。在项目根目录下创建 postcss.config.js 文件，在里面书写以下配置代码即可： 12345module.exports = &#123; plugins: [ require('autoprefixer') ]&#125; 这个时候打包编译，webpack就可以自动给CSS3属性添加前缀了，实例如下： 12345678910111213141516/* main.css 文件 */body &#123; color: yellow;&#125;body &#123; background-color: gray; -webkit-transform: rotate(45deg); transform: rotate(45deg)&#125;body &#123; border: 5px solid #4545 4;&#125;body div &#123; font-size: 20px; font-weight: bolder;&#125; 7. 压缩编译后的 .css 文件在上一节中，我们可以看到，抽离出来的 main.css 文件没有进行压缩，但是很多项目在打包的时候，都需要对 .css 文件进行压缩以节省体积。要达到这个目的，可以进行如下配置： 首先安装一个插件：optimize-css-assets-webpack-plugin 。安装命令如下： 1yarn add optimize-css-assets-webpack-plugin -D 安装完成之后，直接在 webpack.config.js 进行如下配置即可（重点关注有注释的部分）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152let path = require(\"path\");let HtmlWebpackPlugin = require(\"html-webpack-plugin\")let MiniCssExtract = require('mini-css-extract-plugin')let OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin'); // 引入插件module.exports = &#123; optimization: &#123; // 配置webpack的优化项 minimizer: [ // 配置最小值优化项 new OptimizeCSSAssetsPlugin() // 声明css优化插件的实例 ] &#125;, mode: \"production\", entry: \"./src/index.js\", output: &#123; filename: \"index.js\", path: path.resolve(__dirname, \"build\") &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'index.html', minify: &#123; removeAttributeQuotes: true, collapseWhitespace: true &#125;, hash: true &#125;), new MiniCssExtract(&#123; filename: 'main.css' &#125;) ], module: &#123; rules: [&#123; test: /\\.css$/, use: [ MiniCssExtract.loader, 'css-loader', 'postcss-loader' ] &#125;, &#123; test: /\\.less$/, use: [ MiniCssExtract.loader, 'css-loader', 'less-loader', 'postcss-loader' ] &#125; ] &#125;&#125; 配置完成之后，再次进行打包编译项目，就会得到被压缩的 main.css 文件。 要提醒的是，在上述配置中，虽然我们指定webpack的模式为 生产模式（production）,该模式下，打包后的 .js 文件本应该被压缩，但是实际的情况却不是这样，得到的 .js 文件没有被压缩。 这是因为我们在配置 webpack优化项（optimization） 的时候，一些优化配置会覆盖webpack的默认配置。我们这里没有指定压缩 .js 文件，所以即使是在生产模式下进行打包编译，最后得到的 .js 文件依然是没有被压缩的。 如果要对 .js 文件进行压缩，也是非常简单，和配置 .css 文件压缩的如出一辙。具体配置如下： 首先安装一个插件：terser-webpack-plugin ，安装命令如下： 1yarn add terser-webpack-plugin -D 然后进行和上面类似的配置（重点关注有注释的部分）： 12345678910111213141516171819202122let path = require(\"path\");let HtmlWebpackPlugin = require(\"html-webpack-plugin\")let MiniCssExtract = require('mini-css-extract-plugin')let OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin'); let TerserJSPlugin = require('terser-webpack-plugin'); // 引入插件module.exports = &#123; optimization: &#123; // 配置webpack的优化项 minimizer: [ // 配置最小值优化项 new OptimizeCSSAssetsPlugin(), new TerserJSPlugin() // 声明js压缩插件的实例 ] &#125;, mode: \"production\", entry: \"./src/index.js\", output: &#123; filename: \"index.js\", path: path.resolve(__dirname, \"build\") &#125;, // 节省篇幅，后面的一些配置我就不写了，和上面的一样&#125; 现在再次进行打包，得到的 .js 文件就是被压缩的。 8. 写在最后这篇博客的内容可能会多一点，主要讲解如何在webpack中配置对 .css 文件进行处理的规则。希望会对大家有所帮助。","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}]},{"title":"webpack入门学习笔记04 —— 安装和配置webpack开发服务器","slug":"webpack入门学习笔记04 —— 安装和配置webpack开发服务器","date":"2019-06-20T16:00:00.000Z","updated":"2019-12-15T05:25:44.805Z","comments":true,"path":"2019/06/21/webpack入门学习笔记04 —— 安装和配置webpack开发服务器/","link":"","permalink":"http://yoursite.com/2019/06/21/webpack入门学习笔记04 —— 安装和配置webpack开发服务器/","excerpt":"","text":"1. 写在前面在之前的博客中，每次使用webpack打包编译完成之后，我们都需要手动打开编译后的index.html文件，这样对于前端开发的调试很不方便。为了解决这一问题，webpack给出了 开发服务器 这一方案。在进行开发的过程中，我们可以使用webpack启动一个开发服务器，来实时查看自己的项目，很方便进行调试。 相信很多前端开发者都用过webpack的开发服务器，但是有些开发者不是很了解它。那么在这篇文章中，我就给大家介绍webpack的开发服务器，主要内容包括： 安装webpack的开发服务器 初步配置webpack的开发服务器 深入配置webpack的开发服务器 2. 安装webpack的开发服务器首先执行一下命令来安装webpack的开发服务器： 1yarn add webpack-dev-server -D 安装完成之后，我们就可以通过 npx webpack-dev-server 命令启动开发服务器，或者在 package.json 文件中新建一条脚本，后续就可以很方便地使用 npm run 或 yarn 来启动开发服务器。脚本配置如下： 123456789101112131415&#123; \"name\": \"webpack-learning\", \"version\": \"1.0.0\", \"main\": \"index.js\", \"license\": \"MIT\", \"scripts\": &#123; \"build\": \"webpack --config webpack.config.js\", \"dev\": \"webpack-dev-server\" &#125;, \"devDependencies\": &#123; \"webpack\": \"^4.32.2\", \"webpack-cli\": \"^3.3.2\", \"webpack-dev-server\": \"^3.5.1\" &#125;&#125; 启动本地服务器之后，我们便可以在浏览器中通过 http://localhost:8080 来访问项目了。截图如下： 3. 初步配置webpack的开发服务器现在开发服务器已经启动了，但是显而易见的是，当前的开发服务器使用的是默认配置，很大程度上不能满足我们开发的需求，比如： 开发服务器不要使用8080端口号，使用其他的端口号 开发服务器打开之后，不是在根目录下，而是在 build 目录下 开发服务器启动之后，我希望自动打开浏览器 …… 下面我们就讲解一下，如果初步配置开发服务器，完成上述需求。之所以说是初步配置，是因为开发服务器配置内容较多，后面准备单独写一篇博客，讲述开发服务器的详细配置。 其实初步配置开发服务器很简单，在 webpack.config.json 文件中新增 devServer 属性，该属性是一个对象，我们将一些配置信息写到该对象下即可，配置代码如下： 12345678910111213141516let path = require(\"path\");module.exports = &#123; devServer: &#123; port: 3000, // 指定开发服务器的端口号 progress: true, // 显示开启本地服务器的进度 contentBase: \"./build\", // 指定本地服务器默认打开的目录 compress: true // 是否对代码进行压缩 &#125;, mode: \"development\", entry: \"./src/index.js\", output: &#123; filename: \"index.js\", path: path.resolve(__dirname, \"build\") &#125;&#125; 现在再次开启开发服务器，就可以通过 http://localhost:3000 访问到项目的 build 目录了，默认寻找该目录下的 index.html 文件进行渲染，如果没有则展示该目录下的所有文件。 4. 深入配置webpack的开发服务器以上就是对webpack开发服务器的安装和初步配置，但是上述的初步配置存在一些问题：我们希望开发服务器启动之后，就会显示我们项目的页面，但是上述配置中，如果要看到项目的页面，一个前提是build目录下必须存在index.html文件。但是这个文件是打包编译后才生成的，所以在开发服务器环境下可能不会存在，而且也不会实时刷新，所以很明显初步配置不能满足我们的开发需求。 正常情况下，我们希望看到的场景是：使用 npm run 或 yarn 来启动开发服务器之后，就可以实时看到项目的页面，如果项目有代码的更新，页面也要实时更新。要做到这一点，我们需要完成以下步骤： 1) 安装 html-webpack-plugin 插件执行 yarn add html-webpack-plugin -D 进行安装该插件 2） 配置 html-webpack-plugin 插件安装完成之后，我们就需要到 webpack.config.js 文件中配置该插件，其实webpack之所以有这么强大的功能，就是依靠各种各样的插件。所以在webpack配置文件中，肯定会有各种插件的相关配置。这里介绍 html-webpack-plugin 插件的配置，其他插件的配置如出一辙。 首先在 webpack.config.js 文件中引入安装的 html-webpack-plugin 插件，然后新建一个 plugins 属性，该属性是一个数组，webpack使用到的插件，都要在这个数组中进行配置。我们先来看一下具体的配置代码： 12345678910111213141516171819202122232425262728let path = require(\"path\");let HtmlWebpackPlugin = require(\"html-webpack-plugin\") // 引入安装的插件module.exports = &#123; devServer: &#123; port: 3000, // 指定开发服务器的端口号 progress: true, // 显示开启本地服务器的进度 contentBase: \"./build\", // 指定本地服务器默认打开的目录 compress: true // 是否对代码进行压缩 &#125;, mode: \"development\", entry: \"./src/index.js\", output: &#123; filename: \"index.js\", path: path.resolve(__dirname, \"build\") &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', // 模板文件 filename: 'index.html', // 开发服务器中生成的临时文件 minify: &#123; removeAttributeQuotes: true, // 是否去除文件中的双引号 collapseWhitespace: true // 是否去除文件中的空行 &#125;, hash: true // 引入文件的时候添加哈希值，防止缓存的问题 &#125;), ]&#125; 下面讲述一下以上文件中的一些配置选项： template： 模板文件。webpack开发服务器启动的时候，会将项目的代码打包编译成一个或多个 .js 文件，但是这些文件不能直接在浏览器中打开，需要在一个 .html 文件中引入，才能正常被浏览器渲染。模板文件就是这个 .html 。webpack打包编译后的 .js 脚本文件会自动地被引入到该模板文件中。 filename： 开发服务器中打包编译后生成的 临时文件 的文件名，默认是 index.html 。生成的这个文件是一个临时文件，存放在内存中，在项目中是看不到的。但是这个文件非常重要，当我们在浏览器中访问 http://localhost:3000 ，看到的页面，就是这个文件渲染出来的。同时这个文件也是模板文件和webpack打包后的 .js 文件结合生成的。 minify： 表示是否对打包编译生成的代码进行处理，比如去除空行、去除双引号等。 hash：哈希值。如果在模板文件中，直接引入打包编译后的 .js 文件，那么有的时候会受到缓存的影响，但是加上哈希值，就不会存在这个问题。如果不加hash值，在临时文件中引入 .js 文件可能是这个情况：&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; ；如果加上了hash值，在临时文件中引入 .js 文件可能是这个情况：&lt;script src=&quot;index.js?fb39b867e8a90e7cc9ec&quot;&gt;&lt;/script&gt; 。有效解决了缓存带来的影响。 这里需要说明的是， html-webpack-plugin 插件的配置不仅适用于开发服务器，再进行打包编译的时候，该插件的相关配置也会发挥作用，比如指定的模板、是否删除双引号、是否删除空行等。 3） 创建模板文件在上述叙述中，我们知道在启动开发服务器的时候，要有一个模板文件，所以我们要在项目中创建一个模板文件。根据上面的配置要求，该文件是位于 src 文件夹下的 index.html 文件。参考代码如下： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是一个模板文件&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 5. 后记以上就我在学习webpack过程中对开发服务器的一些总结。总的来说，开发服务器就是对当前项目进行打包编译，将生成的文件存放在内存中，然后起一个本地服务。我们在浏览器中访问这个本地服务（如 http://localhost:3000 ）来访问内存的 index.html 文件，进而看到我们的项目。 而且，这个过程是实时热更新的，一旦项目代码有变化，开发服务器会自动进行打包编译，这样我们看到的项目就是最新的。","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}]},{"title":"webpack入门学习笔记03 —— 自定义脚本，帮助项目管理","slug":"webpack入门学习笔记03 —— 自定义脚本，帮助项目管理","date":"2019-06-18T16:00:00.000Z","updated":"2019-12-15T05:25:44.804Z","comments":true,"path":"2019/06/19/webpack入门学习笔记03 —— 自定义脚本，帮助项目管理/","link":"","permalink":"http://yoursite.com/2019/06/19/webpack入门学习笔记03 —— 自定义脚本，帮助项目管理/","excerpt":"","text":"1. 写在前面经过前两章博客的基础讲解，我们知道如果想要打包编译项目，可以执行 npx webpack 命令，然后webpack就会根据配置文件 webpack.config.js 来对项目进行打包编译。但是现在我们可能遇到以下需求： webpack的配置文件不要叫做webpack.config.js,而是叫做 webpack.config.allen.js 每次打包编译的时候，都要使用 npx webpack 命令。我不喜欢这个命令，给我改成 yarn build 命令 …… 看似都是一些很无理的要求，但是确实是我们在架构项目的时候需要考虑到的问题。既然如此，本篇博客就来介绍如何满足以上两个需求。 2. 指定webpack配置文件首先我们来讲一下，如果指定webpack的配置文件。 前面提到，在打包编译项目的时候，我们需要运行 npx webpack 命令，然后webpack就会根据webpack.config.js文件来进行打包编译。这里要说的是， npx webpack 命令是可以指定一些参数的，比如如果我们想要指定webpack的配置文件为 webpack.config.allen.js ，那么可以执行以下命令： 1npx webpack --config webpack.config.allen.js 通过上面的指令，我们便可以使用 webpack.config.allen.js 作为webpack的配置文件，对项目进行打包编译。 3. 自定义脚本命令现在来解决第二个需求：如何使用 yarn build 命令来进行项目的打包编译。 在之前的博客中，我提到过 package.json 文件的作用，其中一个就是自定义一些脚本，然后使用 npm run 或者 yarn 来运行这些脚本，执行所定义的命令。这里我们就可以使用这种方式，自定义脚本来进行打包编译。 新建脚本的步骤非常简单，在 package.json 文件中新建 scripts 属性，该属性为一个对象，给这个对象添加属性键值对即可新建脚本。如果要满足上述第二个需求，可以这样配置： 123456789101112&#123; &quot;name&quot;: &quot;webpack-learning&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack --config webpack.config.allen.js&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.32.2&quot;, &quot;webpack-cli&quot;: &quot;^3.3.2&quot; &#125; 现在自定义脚本已经创建完成，我们便可以通过 npm run build 或者 yarn build 来执行webpack的打包编译命令了。 4. 后记这篇博客我们主要讲解了如何自定义脚本来帮助我们管理项目，这里只介绍了如何创建webpack打包编译的脚本，其他脚本也是非常类似的，在后面的博客中会陆续提到。 大家加油！","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}]},{"title":"webpack入门学习笔记02 —— 初始化一个webpack项目","slug":"webpack入门学习笔记02 —— 初始化一个webpack项目","date":"2019-06-14T16:00:00.000Z","updated":"2019-12-15T05:25:44.804Z","comments":true,"path":"2019/06/15/webpack入门学习笔记02 —— 初始化一个webpack项目/","link":"","permalink":"http://yoursite.com/2019/06/15/webpack入门学习笔记02 —— 初始化一个webpack项目/","excerpt":"","text":"1. 写在前面现在我们就开始正式学习 webpack 了，webpack是帮助我们打包编译项目的，所以在正式开始之前，我们需要初始化一个基于webpack的项目。 在本篇博客中，将会涉及到以下的知识点： 初始化一个基于webpack的项目 体会webpack的默认打包设置 自定义webpack的打包配置文件 2. 初始化一个基于webpack的项目这一步简单，我们可以使用 npm 或者 yarn 包管理工具来帮助我们快速初始化一个项目，相信很多前端从事者对这两个工具都不会陌生。所以这里就进行深入讲解这两款工具。 我习惯于使用 yarn ，所以可以直接创建一个新的文件夹，然后在终端下运行命令 yarn init 即可初始化一个项目。在这一步可能会让你输入一些项目的基本信息，如下所示： 12345678question name (test):question version (1.0.0):question description:question entry point (index.js):question repository url:question author:question license (MIT):question private: 你根据自己的实际情况输入即可，当然也可以一路回车，这样会使用默认的选项初始化一个项目。 初始化完成之后，在该文件夹下，会生成一个 package.json 文件，这个文件记录项目的基本信息，同时会记录之后我们安装的第三方包。在后面的项目中，我们还可以在里面定义一些脚本，帮助我们管理项目，这在后面的博客中会提到。 项目初始化完成之后，我们需要安装两个包，即 webpack 和 webpack-cli ，这两个包就是用来打包编译项目的。安装的步骤很简单，直接在终端下执行以下yarn命令即可： 1yarn add webpack webpack-cli -D 说明一下：以上命令中的 -D 选项，表明这两个包是开发依赖，项目上线的时候不需要这两个包。 这两个包安装完成之后，这个基于webpack的项目也就创建好了，可以继续后续工作了。 3.体会webpack的默认打包设置项目创建好之后，我们可以不对webpack进行配置即可进行使用，因为webpack有自己默认的配置。下面来体会一下它的默认配置。 在项目目录中创建一个 src 目录，用来存放项目代码。在该目录下创建一个 index.js 文件，注意一定是这个名字，这是webpack默认配置的要求。在该文件中，我们使用node语法引入另外一个文件 name.js ，代码如下： 12let myName = require(\"./name.js\")console.log(myName); 其中 name.js 文件中的代码如下： 1module.exports = \"Allen Feng\" 上面使用的是Node.js语法，如果使用浏览器来直接渲染的话，是不能成功渲染的。这个时候我们可以使用webpack进行打包编译，直接在终端中运行命令 npx webpack ，稍微等待一会即可打包成功。 打包完成之后，观察项目目录，可以看到这个时候多出一个文件夹 dist ，点进去之后可以看到打包后的文件 main.js 。如果这个时候在 dist 文件夹下创建一个 html 文件，通过 script标签 引入main.js文件便可以在浏览器的控制台中看到打印出的 Allen Feng。 这就是使用 webpack 的默认配置打包出来的效果，总结一下，在webpack的默认配置中： src目录下一定要有index.js文件，这是默认配置中指定的入口文件 webpack打包编译之后，会将最终的代码放在 dist 文件夹下。如果没有，就会创建该文件夹 webpack默认打包模式是生产模式，即打包编译后的代码会被压缩。 4.自定义webpack的打包配置文件以上我们已经使用webpack的默认配置对项目进行打包编译，但是我们可能会遇到这样的需求： 我不想让webpack从 index.js 文件开始打包，而是从 App.js 文件开始打包 打包编译后的代码不放在 dist 目录下，而是其他目录 打包编译后的代码不要进行压缩 …… 这个时候，我们就可以自定义webpack的配置，来达到想要的效果。步骤很简单，在项目的主目录下（即和package.json同级）新建一个 webpack.config.js 文件，这是webpack的配置文件。在该文件中，可以书写以下代码对webpack进行配置： 12345678910let path = require(\"path\");module.exports = &#123; mode: \"development\", entry: \"./src/index.js\", output: &#123; filename: \"index.js\", path: path.resolve(__dirname, \"dist\") &#125;&#125; 如代码所示，我们可以在配置文件中，指定webpack的打包模式、打包的入口文件、打包的出口文件等。下面对这三个配置选项做详细的说明： 1) mode: webpack的配置模式webpack有两种配置模式：production（生产模式） 和 development（开发模式）。默认采用的是 生产模式，在该模式下，打包编译后的代码会被压缩，节省体积。 如果选择 开发模式 , 那么最终的将不会被压缩，文件的体积会稍大。 2) entry： webpack的入口文件webpack进行打包编译，肯定要有一个指定的入口文件，这个文件便可以通过该属性指定。默认的入口文件是 index.js 文件。如果要把它更改为其他的文件，修改该属性即可。注意这个属性可以使用 相对路径 指定。 3) output： webpack的出口文件webpack打包编译后的代码放在哪里，是通过该属性指定的。在配置该属性的时候，要指定出口文件的 文件名 和 路径 。默认的路径是 dist 文件夹下的 index.js 文件。如果要修改为其他的路径和文件名，修改该属性即可。要注意，出口文件的路径配置要使用 绝对路径 ，可以参考我上面的写法。 5. 后记现在讲完了webpack三个基本选项的配置，我们就可以根据自己的需求来进行配置。后续会介绍其他的一些选项配置。大家加油！","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}]},{"title":"webpack入门学习笔记01 —— webpack基本简介","slug":"webpack入门学习笔记01 —— webpack基本简介","date":"2019-06-12T16:00:00.000Z","updated":"2019-12-15T05:25:44.803Z","comments":true,"path":"2019/06/13/webpack入门学习笔记01 —— webpack基本简介/","link":"","permalink":"http://yoursite.com/2019/06/13/webpack入门学习笔记01 —— webpack基本简介/","excerpt":"","text":"1. 写在前面很多从事前端开发的程序员，都会接触到 webpack 非常熟悉的概念，但是我想很多人对webpack只是一知半解，知道这是一个打包器，可以将我们编写的Vue代码、React代码打包编译成原生的JS代码，方便浏览器识别。 但是对于webpack更底层的知识，比如：如何配置webpack，webpack为什么可以对我们的代码进行打包编译等，了解甚少。 所以借着这次学习webpack的机会，写一些文章，从一个前端小白的角度出发，一步步了解webpack的相关知识。希望这些文章可以对那些前端小白有多帮助。写得不好的地方，也请大家多多批评。 2. webpack基本简介什么是webpack呢，下面我们引出 官方定义 ： webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 说的直白一点，就是讲我们的代码进行编译打包，变成能够被浏览器识别的前端脚本。就拿一个Vue项目为例： 一开始我们是用 Vue-cli脚手架 快速搭建一个项目，随后在项目中都是采用Vue语法来编写我们的项目，不仅如此，我们还会使用 ES6 语法，还会使用SCSS等CSS预处理器等等。 这些语法我们是熟悉的，但是浏览器不认识呀，浏览器能够识别的是原生JS语法，而且就目前情况来说，只能识别ES5语法，不能识别我们使用的ES6语法。这就意味着，我们的Vue项目是跑不起来的。这该怎么办呢？ 这个时候webpack就开始发挥它的作用了，webpack通过分析Vue语法、理清代码模块之前的依赖关系、分析SCSS预处理器、分析项目中引用的图片等静态资源等，将这些浏览器不识别的语法进行打包编写编译，最终打包输出 .js、.css、.jpg、.png 等能够被浏览器识别的语法和文件。如此一来，我们的项目就可以顺利地在浏览器上面跑起来了。 3. webpack的作用总结结合上面的简单介绍，我们来总结一下webpack的作用： 代码转换webpack可以将ES6语法转换为ES5语法，可以将LESS、SASS语法转换成CSS语法 文件优化在webpack打包的过程中，可以合并文件，压缩文件体积 代码分割、模块合并在开发的过程中，将一些公共的模块进行抽离，形成单独的模块，方便其他模块进行调用 自动刷新即我们熟悉的热更新，在开发过程中，webpack会帮我们启动一个本地服务，每当产生新代码的时候，该服务会自动刷新，然我们看到最新的页面 代码校验在开发过程中，webpack可以帮助我们检查代码语法规范，减少bug的数量 自动发布项目开发完成之后，我们可以借助webpack帮助我们自动发布代码，部署到服务器上 4.后记以上就是webpack学习笔记的开篇语，希望接下来的一系列笔记，对你理解webpack会有所帮助。大家加油！","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}]}]}