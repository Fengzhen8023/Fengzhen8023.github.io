<!DOCTYPE HTML>
<html lang="en">

<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Fengzhen8023">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->

<meta name="keywords" content="前端,React,React Router">


<meta name="description" content="
转载说明原翻译作者：https://www.jianshu.com/u/5d660a479013原官网文档：https://reacttraining.com/react-router/web...">


<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->

<title>
    
    React Router V5 翻译文档10：API |
    
    Fengzhen8023
</title>

<link rel="alternate" href="/atom.xml" title="Fengzhen8023" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    

<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">
<link rel="stylesheet" href="/fonts/iconfont.css">
    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

</head></html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='John Doe'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">
                        Fengzhen8023</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                Home</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/React/"><i class="fa "></i>
                                React</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/Webpack/"><i class="fa "></i>
                                Webpack</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/Python/"><i class="fa "></i>
                                Python</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/userfulTools/"><i class="fa "></i>
                                实用工具</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="React Router V5 翻译文档10：API">
            
            React Router V5 翻译文档10：API
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="iconfont icon-wulumuqishigongandashujuguanlipingtai-ico-"></i>
        <a class="category-link" href="/categories/React/">React</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="iconfont icon-biaoqian"></i>
        <span class="tags-meta">
            
            <a class="tag-link" href="/tags/React/">React</a> <a class="tag-link" href="/tags/React-Router/">React Router</a> <a class="tag-link" href="/tags/前端/">前端</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="iconfont icon-date"></i>
        <span class="date-meta">
            2019/12/15</span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <blockquote>
<h5 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h5><p>原翻译作者：<a href="https://www.jianshu.com/u/5d660a479013" target="_blank" rel="noopener">https://www.jianshu.com/u/5d660a479013</a><br>原官网文档：<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">https://reacttraining.com/react-router/web/guides/quick-start</a></p>
</blockquote>
<p>这部分API文档翻译参考了项目<a href="https://github.com/react-translate-team/react-router-CN" target="_blank" rel="noopener">react-router-CN</a></p>
<h2 id="lt-BrowserRouter-gt"><a href="#lt-BrowserRouter-gt" class="headerlink" title="&lt; BrowserRouter &gt;"></a>&lt; BrowserRouter &gt;</h2><p><router> 使用HTML5提供的history API(pushState, replaceState和popstate事件)来同步UI和URL。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line">&lt;BrowserRouter</span><br><span class="line">  basename=&#123;optionalString&#125;</span><br><span class="line">  forceRefresh=&#123;optionalBool&#125;</span><br><span class="line">  getUserConfirmation=&#123;optionalFunc&#125;</span><br><span class="line">  keyLength=&#123;optionalNumber&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/BrowserRouter&gt;</span></span><br></pre></td></tr></table></figure></router></p>
<h3 id="basename-String"><a href="#basename-String" class="headerlink" title="basename: String"></a>basename: String</h3><p>当前位置的基准URL。如果你的页面部署在服务器的二级子目录，你需要将basename设置到此子目录。 正确的URL格式是前面有一个前导斜杠，但不能有尾部斜杠。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter basename=<span class="string">"/calendar"</span>/&gt;</span><br><span class="line">&lt;Link to=<span class="string">"/today"</span>/&gt; <span class="comment">// 渲染为 &lt;a href="/calendar/today"&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="getUserConfirmation-func"><a href="#getUserConfirmation-func" class="headerlink" title="getUserConfirmation: func"></a>getUserConfirmation: func</h3><p>当导航需要确认时执行的函数。默认使用window.confirm。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认的确认函数</span></span><br><span class="line"><span class="keyword">const</span> getConfirmation = <span class="function">(<span class="params">message, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> allowTransition = <span class="built_in">window</span>.confirm(message)</span><br><span class="line">  callback(allowTransition)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;BrowserRouter getUserConfirmation=&#123;getConfirmation&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="forceRefresh-bool"><a href="#forceRefresh-bool" class="headerlink" title="forceRefresh: bool"></a>forceRefresh: bool</h3><p>当设置为true时，在导航的过程中整个页面将会刷新。只有当浏览器不支持HTML5的 history API 时，才设置为true。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> supportsHistory = <span class="string">'pushState'</span> <span class="keyword">in</span> <span class="built_in">window</span>.history</span><br><span class="line">&lt;BrowserRouter forceRefresh=&#123;!supportsHistory&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="keyLength-number"><a href="#keyLength-number" class="headerlink" title="keyLength: number"></a>keyLength: number</h3><p>location.key的长度。默认是6。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter keyLength=&#123;<span class="number">12</span>&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="children-node"><a href="#children-node" class="headerlink" title="children: node"></a>children: node</h3><p>渲染单一子组件（元素）。</p>
<h2 id="lt-HashRouter-gt"><a href="#lt-HashRouter-gt" class="headerlink" title="&lt; HashRouter &gt;"></a>&lt; HashRouter &gt;</h2><p>HashRouter 是一种特定的 <router>， HashRouter 使用 URL 的 hash (例如：window.location.hash) 来同步UI和URL。  </router></p>
<p>注意：使用 hash 的方式记录导航历史不支持 location.key 和 location.state。在以前的版本中，我们为这种行为提供了 shim，但是仍有一些问题我们无法解决。任何依赖此行为的代码或插件都将无法正常使用。 由于该技术仅用于支持传统的浏览器，因此在用于浏览器时可以使用 <browserhistory> 代替。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; HashRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line">&lt;HashRouter&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/HashRouter&gt;</span></span><br></pre></td></tr></table></figure></browserhistory></p>
<h3 id="basename-string"><a href="#basename-string" class="headerlink" title="basename: string"></a>basename: string</h3><p>当前位置的基准 URL。正确的 URL 格式是前面有一个前导斜杠，但不能有尾部斜杠。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;HashRouter basename=<span class="string">"/calendar"</span>/&gt;</span><br><span class="line">&lt;Link to=<span class="string">"/today"</span>/&gt; <span class="comment">// renders &lt;a href="#/calendar/today"&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="getUserConfirmation-func-1"><a href="#getUserConfirmation-func-1" class="headerlink" title="getUserConfirmation: func"></a>getUserConfirmation: func</h3><p>当导航需要确认时执行的函数。默认使用 window.confirm。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认的确认函数</span></span><br><span class="line"><span class="keyword">const</span> getConfirmation = <span class="function">(<span class="params">message, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> allowTransition = <span class="built_in">window</span>.confirm(message)</span><br><span class="line">  callback(allowTransition)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;HashRouter getUserConfirmation=&#123;getConfirmation&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="hashType-string"><a href="#hashType-string" class="headerlink" title="hashType: string"></a>hashType: string</h3><p>window.location.hash 使用的 hash 类型。有如下几种：</p>
<ul>
<li>“slash” - 后面跟一个斜杠，例如 #/ 和 #/sunshine/lollipops</li>
<li>“noslash” - 后面没有斜杠，例如 # 和 #sunshine/lollipops</li>
<li>“hashbang” - Google 风格的 “ajax crawlable”，例如 #!/ 和 #!/sunshine/lollipops  </li>
</ul>
<p>默认为 “slash”。</p>
<h3 id="children-node-1"><a href="#children-node-1" class="headerlink" title="children: node"></a>children: node</h3><p>渲染单一子组件（元素）。</p>
<h2 id="lt-Link-gt"><a href="#lt-Link-gt" class="headerlink" title="&lt; Link &gt;"></a>&lt; Link &gt;</h2><p>为您的应用提供声明式的、无障碍导航。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line">&lt;Link to=<span class="string">"/about"</span>&gt;关于&lt;<span class="regexp">/Link&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="to-string"><a href="#to-string" class="headerlink" title="to: string"></a>to: string</h3><p>需要跳转到的路径(pathname)或地址（location）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">"/courses"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="to-object"><a href="#to-object" class="headerlink" title="to: object"></a>to: object</h3><p>需要跳转到的地址（location）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123;</span><br><span class="line">  pathname: <span class="string">'/courses'</span>,</span><br><span class="line">  search: <span class="string">'?sort=name'</span>,</span><br><span class="line">  hash: <span class="string">'#the-hash'</span>,</span><br><span class="line">  state: &#123; <span class="attr">fromDashboard</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="replace-bool"><a href="#replace-bool" class="headerlink" title="replace: bool"></a>replace: bool</h3><p>当设置为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址。<br>当设置为 false 时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。<br>默认为 false。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">"/courses"</span> replace /&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="lt-NavLink-gt"><a href="#lt-NavLink-gt" class="headerlink" title="&lt; NavLink &gt;"></a>&lt; NavLink &gt;</h2><p>&lt; NavLink &gt;是 &lt; Link &gt; 的一个特定版本, 会在匹配上当前 URL 的时候会给已经渲染的元素添加样式参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line">&lt;NavLink to=<span class="string">"/about"</span>&gt;About&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="activeClassName-string"><a href="#activeClassName-string" class="headerlink" title="activeClassName: string"></a>activeClassName: string</h3><p>当元素匹配上当前 URL 的时候, 这个类会被赋予给这个元素. 其默认值为 active, 这个值会被添加到 className 属性的后面(追加)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/faq"</span></span><br><span class="line">  activeClassName=<span class="string">"selected"</span></span><br><span class="line">&gt;FAQs&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="activeStyle-object"><a href="#activeStyle-object" class="headerlink" title="activeStyle: object"></a>activeStyle: object</h3><p>当元素被选中时, 为此元素添加样式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/faq"</span></span><br><span class="line">  activeStyle=&#123;&#123;</span><br><span class="line">    fontWeight: <span class="string">'bold'</span>,</span><br><span class="line">    color: <span class="string">'red'</span></span><br><span class="line">   &#125;&#125;</span><br><span class="line">&gt;FAQs&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="exact-bool"><a href="#exact-bool" class="headerlink" title="exact: bool"></a>exact: bool</h3><p>当值为 true 时, 只有当地址完全匹配 class 和 style 才会应用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  exact</span><br><span class="line">  to=<span class="string">"/profile"</span></span><br><span class="line">&gt;Profile&lt;<span class="regexp">/NavLink</span></span><br></pre></td></tr></table></figure></p>
<h3 id="strict-bool"><a href="#strict-bool" class="headerlink" title="strict: bool"></a>strict: bool</h3><p>当值为 true 时，在确定位置是否与当前 URL 匹配时，将考虑位置 pathname 后的斜线 有关详细信息，请参阅<a href="https://reacttraining.com/react-router/core/api/Route/strict-bool" target="_blank" rel="noopener">&lt; Route strict &gt;</a>文档。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  strict</span><br><span class="line">  to=<span class="string">"/events/"</span></span><br><span class="line">&gt;Events&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="isActive-func"><a href="#isActive-func" class="headerlink" title="isActive: func"></a>isActive: func</h3><p>添加用于确定链接是否活动的额外逻辑的功能。 如果您想要做的更多，请验证链接的路径名是否与当前URL的 pathname 匹配。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// only consider an event active if its event id is an odd number</span></span><br><span class="line"><span class="keyword">const</span> oddEvent = <span class="function">(<span class="params">match, location</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> eventID = <span class="built_in">parseInt</span>(match.params.eventID)</span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">isNaN</span>(eventID) &amp;&amp; eventID % <span class="number">2</span> === <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/events/123"</span></span><br><span class="line">  isActive=&#123;oddEvent&#125;</span><br><span class="line">&gt;Event <span class="number">123</span>&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="lt-Prompt-gt"><a href="#lt-Prompt-gt" class="headerlink" title="&lt; Prompt &gt;"></a>&lt; Prompt &gt;</h2><p>当用户离开当前页的时候做出提示. 当你的应用处在特定状态, 此状态不希望用户离开时(例如填写表格到一半), 你应该使用<prompt>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Prompt &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line">&lt;Prompt</span><br><span class="line">  when=&#123;formIsHalfFilledOut&#125;</span><br><span class="line">  message=<span class="string">"Are you sure you want to leave?"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></prompt></p>
<h3 id="message-string"><a href="#message-string" class="headerlink" title="message: string"></a>message: string</h3><p>当用户尝试导航离开时，提示用户的消息。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Prompt message=<span class="string">"Are you sure you want to leave?"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="message-func"><a href="#message-func" class="headerlink" title="message: func"></a>message: func</h3><p>会与用户试图前往下一个地址（location） 和 action 一起被调用。<br>函返回一个字符串用作向用户提示，或者返回true用作允许过渡。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Prompt</span><br><span class="line">  message=&#123;location =&gt;</span><br><span class="line">    location.pathname.startsWith(<span class="string">"/app"</span>)</span><br><span class="line">      ? <span class="literal">true</span></span><br><span class="line">      : <span class="string">`Are you sure you want to go to <span class="subst">$&#123;location.pathname&#125;</span>?`</span></span><br><span class="line">  &#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="when-bool"><a href="#when-bool" class="headerlink" title="when: bool"></a>when: bool</h3><p>你可以随时渲染<prompt>，而不是有条件地在警戒后面渲染它。</prompt></p>
<ul>
<li>当when={true} 时，禁止导航</li>
<li>当when={false} 时，允许导航<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Prompt when=&#123;formIsHalfFilledOut&#125; message=<span class="string">"Are you sure?"</span> /&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="lt-MemoryRouter-gt"><a href="#lt-MemoryRouter-gt" class="headerlink" title="&lt; MemoryRouter &gt;"></a>&lt; MemoryRouter &gt;</h3><p>&lt; Router &gt; 能在内存保存你 “URL” 的历史纪录(并没有对地址栏读写). 在非浏览器或者测试环境比如React Native下很有用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; MemoryRouter &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line">&lt;MemoryRouter&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/MemoryRouter&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="initialEntries-array"><a href="#initialEntries-array" class="headerlink" title="initialEntries: array"></a>initialEntries: array</h3><p>在历史栈中的一个 location 数组. 这些可能会成为含有 { pathname, search, hash, state } 或一些简单的 URL 字符串的完整的地址对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;MemoryRouter</span><br><span class="line">  initialEntries=&#123;[ <span class="string">'/one'</span>, <span class="string">'/two'</span>, &#123; <span class="attr">pathname</span>: <span class="string">'/three'</span> &#125; ]&#125;</span><br><span class="line">  initialIndex=&#123;<span class="number">1</span>&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/MemoryRouter&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="initialIndex-number"><a href="#initialIndex-number" class="headerlink" title="initialIndex: number"></a>initialIndex: number</h3><p>initialEntries 数组中的初始化地址索引</p>
<h3 id="getUserConfirmation-func-2"><a href="#getUserConfirmation-func-2" class="headerlink" title="getUserConfirmation: func"></a>getUserConfirmation: func</h3><p>用于确认导航的函数. 当使用<memoryrouter>直接使用<prompt>时，你必须使用这个选项</prompt></memoryrouter></p>
<h3 id="keyLength-number-1"><a href="#keyLength-number-1" class="headerlink" title="keyLength: number"></a>keyLength: number</h3><p>location.key 的长度, 默认为 6<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MemoryRouter keyLength=&#123;<span class="number">12</span>&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="children-node-2"><a href="#children-node-2" class="headerlink" title="children: node"></a>children: node</h3><p>要呈现的 单个子元素。</p>
<h2 id="lt-Redirect-gt"><a href="#lt-Redirect-gt" class="headerlink" title="&lt; Redirect &gt;"></a>&lt; Redirect &gt;</h2><p>渲染<redirect> 的时候将会导航到一个新的地址（location）。这个新的地址（location）将会覆盖在访问历史记录里面的原地址，就像服务端的重定向（HTTP 3XX）一样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Route, Redirect &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line">&lt;Route exact path=<span class="string">"/"</span> render=&#123;() =&gt; (</span><br><span class="line">  loggedIn ? (</span><br><span class="line">    &lt;Redirect to=<span class="string">"/dashboard"</span>/&gt;</span><br><span class="line">  ) : (</span><br><span class="line">    &lt;PublicHomePage/&gt;</span><br><span class="line">  )</span><br><span class="line">)&#125;/&gt;</span><br></pre></td></tr></table></figure></redirect></p>
<h3 id="to-string-1"><a href="#to-string-1" class="headerlink" title="to: string"></a>to: string</h3><p>重定向目标URL。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=<span class="string">"/somewhere/else"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="to-object-1"><a href="#to-object-1" class="headerlink" title="to: object"></a>to: object</h3><p>重定向目标地址(location)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=&#123;&#123;</span><br><span class="line">  pathname: <span class="string">'/login'</span>,</span><br><span class="line">  search: <span class="string">'?utm=your+face'</span>,</span><br><span class="line">  state: &#123; <span class="attr">referrer</span>: currentLocation &#125;</span><br><span class="line">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="push-bool"><a href="#push-bool" class="headerlink" title="push: bool"></a>push: bool</h3><p>当设置为 true 时，重定向（redirecting）将会把新地址加入访问历史记录里面，而不是替换掉目前的地址<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect push to=<span class="string">"/somewhere/else"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="from-string"><a href="#from-string" class="headerlink" title="from: string"></a>from: string</h3><p>需要被重定向的路径（pathname）。当渲染一个包含在<switch>里面的<redirect>的时候，这可以用作匹配一个地址（location）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Redirect <span class="keyword">from</span>=<span class="string">'/old-path'</span> to=<span class="string">'/new-path'</span>/&gt;</span><br><span class="line">  &lt;Route path=<span class="string">'/new-path'</span> component=&#123;Place&#125;/&gt;</span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br></pre></td></tr></table></figure></redirect></switch></p>
<h2 id="lt-Route-gt"><a href="#lt-Route-gt" class="headerlink" title="&lt; Route &gt;"></a>&lt; Route &gt;</h2><p>想要理解并使用好React Router，最重要的可能就是Route组件了。Route组件主要的作用就是当一个location匹配路由的path时，渲染某些UI。<br>考虑这样的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/news"</span> component=&#123;NewsFeed&#125;/&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Router&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果应用的地址是/,那么相应的UI会类似这个样子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Home/&gt;</span><br><span class="line">  &lt;!-- react-empty: <span class="number">2</span> --&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果应用的地址是/news,那么相应的UI就会成为这个样子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;!-- react-empty: <span class="number">1</span> --&gt;</span><br><span class="line">  &lt;NewsFeed/&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里的react-empty注释只是演示了React渲染null的细节，但对我们具有启发性。其实Route就算是null也会被渲染，只要地址与路由的路径匹配，组件就会渲染。</p>
<h3 id="Route渲染方法"><a href="#Route渲染方法" class="headerlink" title="Route渲染方法"></a>Route渲染方法</h3><p>这三种渲染方法都会获得相同的三个的属性：</p>
<ul>
<li>match</li>
<li>location</li>
<li>history</li>
</ul>
<h3 id="component"><a href="#component" class="headerlink" title="component"></a>component</h3><p>只有在地址匹配的时候React的组件才会被渲染，route props也会随着一起被渲染。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"/user/:username"</span> component=&#123;User&#125;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = <span class="function">(<span class="params">&#123; match &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;match.params.username&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你使用component(而不是像下面这样使用render),路由会根据指定的组件使用React.createElement来创建一个新的React element。这就意味着如果你提供的是一个内联的函数的话会带来很多意料之外的重新挂载。所以，对于内联渲染，要使用render属性(如下所示)。</p>
<h3 id="render-func"><a href="#render-func" class="headerlink" title="render: func"></a>render: func</h3><p>这种方式对于内联渲染和包装组件却不引起意料之外的重新挂载特别方便。<br>使用render属性，你可以选择传一个在地址匹配时被调用的函数，而不是像使用component属性那样得到一个新创建的React element。使用render属性会获得跟使用component属性一样的route props。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 便捷的行内渲染</span></span><br><span class="line">&lt;Route path=<span class="string">"/home"</span> render=&#123;() =&gt; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装/合成</span></span><br><span class="line"><span class="keyword">const</span> FadingRoute = <span class="function">(<span class="params">&#123; component: Component, ...rest &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;Route &#123;...rest&#125; render=&#123;props =&gt; (</span><br><span class="line">    &lt;FadeIn&gt;</span><br><span class="line">      &lt;Component &#123;...props&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/FadeIn&gt;</span></span><br><span class="line"><span class="regexp">  )&#125;/</span>&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&lt;FadingRoute path=<span class="string">"/cool"</span> component=&#123;Something&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>警告: &lt; Route component &gt;的优先级要比&lt; Route render &gt;高，所以不要在同一个 <route>中同时使用这两个属性。</route></p>
<h3 id="children-func"><a href="#children-func" class="headerlink" title="children: func"></a>children: func</h3><p>有时候你可能想不管地址是否匹配都渲染一些内容，这种情况你可以使用children属性。它与render属性的工作方式基本一样，除了它是不管地址匹配与否都会被调用。<br>除了在路径不匹配URL时match的值为null之外，children渲染属性会获得与component和render一样的route props。这就允许你根据是否匹配路由来动态地调整UI了，来看这个例子，如果理由匹配的话就添加一个active类：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;ListItemLink to=<span class="string">"/somewhere"</span>/&gt;</span><br><span class="line">  &lt;ListItemLink to=<span class="string">"/somewhere-else"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const ListItemLink = (&#123; to, ...rest &#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;Route path=&#123;to&#125; children=&#123;(&#123; match &#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">    &lt;li className=&#123;match ? 'active' : ''&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Link to=&#123;to&#125; &#123;...rest&#125;/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  )&#125;/</span>&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>这种属性对于动画也特别有用:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route children=&#123;(&#123; match, ...rest &#125;) =&gt; (</span><br><span class="line">  &#123;<span class="comment">/* Animate总会被渲染, 所以你可以使用生命周期来使它的子组件出现</span></span><br><span class="line"><span class="comment">    或者隐藏</span></span><br><span class="line"><span class="comment">  */</span>&#125;</span><br><span class="line">  &lt;Animate&gt;</span><br><span class="line">    &#123;match &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Something</span> &#123;<span class="attr">...rest</span>&#125;/&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Animate</span>&gt;</span></span></span><br><span class="line">)&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>警告: &lt; Route component &gt;和&lt; Route render &gt; 的优先级都比&lt; Route children &gt; 高，所以在同一个<route>中不要同时使用一个以上的属性.</route></p>
<h3 id="path-string"><a href="#path-string" class="headerlink" title="path: string"></a>path: string</h3><p>可以是任何path-to-regexp能理解的有效URL。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"/users/:id"</span> component=&#123;User&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>没有path属性的Route 总是会 匹配。</p>
<h3 id="exact-bool-1"><a href="#exact-bool-1" class="headerlink" title="exact: bool"></a>exact: bool</h3><p>当值为true时，则要求路径与location.pathname必须 完全 匹配。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route exact path=<span class="string">"/one"</span> component=&#123;About&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">路径</th>
<th style="text-align:center">location.pathname</th>
<th style="text-align:center">exact</th>
<th style="text-align:center">是否匹配?</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/one</td>
<td style="text-align:center">/one/two</td>
<td style="text-align:center">true</td>
<td style="text-align:center">否</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">/one</td>
<td style="text-align:center">/one/two</td>
<td style="text-align:center">false</td>
<td style="text-align:center">是</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="strict-bool-1"><a href="#strict-bool-1" class="headerlink" title="strict: bool"></a>strict: bool</h3><p>当设为true的时候，有结尾斜线的路径只能匹配有斜线的location.pathname，这个值并不会对location.pathname中有其他的片段有影响。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route strict path=<span class="string">"/one/"</span> component=&#123;About&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">路径</th>
<th style="text-align:center">location.pathname</th>
<th style="text-align:center">是否匹配?</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/one/</td>
<td style="text-align:center">/one</td>
<td style="text-align:center">否</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">/one/</td>
<td style="text-align:center">/one/</td>
<td style="text-align:center">是</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">/one/</td>
<td style="text-align:center">/one/two</td>
<td style="text-align:center">是</td>
<td></td>
</tr>
</tbody>
</table>
<p>警告: stict可以强制location.pathname不包含结尾的斜线，但是要做到这点必须把strict和exect都设置为true。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route exact strict path=<span class="string">"/one"</span> component=&#123;About&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">路径</th>
<th style="text-align:center">location.pathname</th>
<th style="text-align:center">是否匹配?</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/one</td>
<td style="text-align:center">/one</td>
<td style="text-align:center">是</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">/one</td>
<td style="text-align:center">/one/</td>
<td style="text-align:center">否</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">/one</td>
<td style="text-align:center">/one/two</td>
<td style="text-align:center">否</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="location-object"><a href="#location-object" class="headerlink" title="location: object"></a>location: object</h3><p>&lt; Route &gt;元素尝试将路径path当前history location（通常是当前浏览器URL）进行匹配。 除此之外，具有不同pathname的location也可以被传统用来匹配。  </p>
<p>当你需要将&lt; Route &gt;匹配到当前history location以外的location时，这非常有用，如动画过渡示例中所示。  </p>
<p>如果&lt; Route &gt;包含在&lt; Switch &gt;中并匹配了传递给<switch>的location（或当前history location），那么传递给&lt; Route &gt;的location属性将会被&lt; Switch &gt;使用的所覆盖。</switch></p>
<h3 id="sensitive-bool"><a href="#sensitive-bool" class="headerlink" title="sensitive: bool"></a>sensitive: bool</h3><p>如果该属性为true,则在匹配时区分大小写<br>path|    location.pathname|    sensitive|    是否匹配?|<br>:-:|:-:|:-:|:-:|<br>/one|/one|    true|    yes|<br>/One|    /one|    true|    no|<br>/One|    /one| false| yes|</p>
<h2 id="lt-Router-gt"><a href="#lt-Router-gt" class="headerlink" title="&lt; Router &gt;"></a>&lt; Router &gt;</h2><p>Router是所有路由组件共用的底层接口，一般我们的应用并不会使用这个接口，而是使用高级的路由：</p>
<ul>
<li>&lt; BrowserRouter &gt;</li>
<li>&lt; HashRouter &gt;</li>
<li>&lt; MemoryRouter &gt;</li>
<li>&lt; NativeRouter &gt;</li>
<li>&lt; StaticRouter &gt;</li>
</ul>
<p>最常见的使用底层的&lt; Router &gt;的情形就是用来与Redux或者Mobx之类的状态管理库的定制的history保持同步。注意不是说使用状态管理库就必须使用&lt; Router &gt;，它仅用作于深度集成。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"><span class="keyword">import</span> createBrowserHistory <span class="keyword">from</span> <span class="string">'history/createBrowserHistory'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> history = createBrowserHistory()</span><br><span class="line"></span><br><span class="line">&lt;Router history=&#123;history&#125;&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/Router&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="history-object"><a href="#history-object" class="headerlink" title="history: object"></a>history: object</h3><p>用来导航的history对象.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> createBrowserHistory <span class="keyword">from</span> <span class="string">'history/createBrowserHistory'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> customHistory = createBrowserHistory()</span><br><span class="line">&lt;Router history=&#123;customHistory&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="children-node-3"><a href="#children-node-3" class="headerlink" title="children: node"></a>children: node</h3><p>需要渲染的单一组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/Router&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="lt-StaticRouter-gt"><a href="#lt-StaticRouter-gt" class="headerlink" title="&lt; StaticRouter &gt;"></a>&lt; StaticRouter &gt;</h2><p>&lt; Router &gt; 从不会改变地址<br>当用户实际上没有点击时, 这在服务端的渲染场景中可能会非常有用, 所以这个地址从来没有改变. 因此, 称为: static (静态). 当您只需要插入一个位置并在渲染输出上作出断言时，它也可用于简单的测试 这里有一个简单 nodejs 服务 : 为&lt; Redirect &gt;和其他请求的常规HTML发送302状态代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">'react-dom/server'</span></span><br><span class="line"><span class="keyword">import</span> &#123; StaticRouter &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line">createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This context object contains the results of the render</span></span><br><span class="line">  <span class="keyword">const</span> context = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString(</span><br><span class="line">    &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt;</span><br><span class="line">      &lt;App/&gt;</span><br><span class="line">    &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ context.url will contain the URL to redirect to if a &lt;Redirect&gt; was used</span></span><br><span class="line"><span class="regexp">  if (context.url) &#123;</span></span><br><span class="line"><span class="regexp">    res.writeHead(302, &#123;</span></span><br><span class="line"><span class="regexp">      Location: context.url</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">    res.end()</span></span><br><span class="line"><span class="regexp">  &#125; else &#123;</span></span><br><span class="line"><span class="regexp">    res.write(html)</span></span><br><span class="line"><span class="regexp">    res.end()</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;).listen(3000)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="basename-string-1"><a href="#basename-string-1" class="headerlink" title="basename: string"></a>basename: string</h3><p>所有地址的基本 URL . 正确格式化的基本名称应该有一个主要的斜杠，但没有尾部斜杠<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;StaticRouter basename=<span class="string">"/calendar"</span>&gt;</span><br><span class="line">  &lt;Link to=<span class="string">"/today"</span>/&gt; <span class="comment">// renders &lt;a href="/calendar/today"&gt;</span></span><br><span class="line">&lt;<span class="regexp">/StaticRouter&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="location-string"><a href="#location-string" class="headerlink" title="location: string"></a>location: string</h3><p>服务器收到的 URL, 在 node 服务上可能是 req.url<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;StaticRouter location=&#123;req.url&#125;&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/StaticRouter&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="location-object-1"><a href="#location-object-1" class="headerlink" title="location: object"></a>location: object</h3><p>一个格式像 { pathname, search, hash, state } 的地址对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;StaticRouter location=&#123;&#123; <span class="attr">pathname</span>: <span class="string">'/bubblegum'</span> &#125;&#125;&gt;</span><br><span class="line">  &lt;App/&gt;</span><br><span class="line">&lt;<span class="regexp">/StaticRouter&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="context-object"><a href="#context-object" class="headerlink" title="context: object"></a>context: object</h3><p>记录渲染结果的纯JavaScript对象。 见上面的例子</p>
<h3 id="children-node-4"><a href="#children-node-4" class="headerlink" title="children: node"></a>children: node</h3><p>要呈现的单个子元素。</p>
<h2 id="lt-Switch-gt"><a href="#lt-Switch-gt" class="headerlink" title="&lt; Switch &gt;"></a>&lt; Switch &gt;</h2><p>渲染匹配地址(location)的第一个 &lt; Route &gt; 或者 &lt; Redirect &gt;<br>这与只使用一堆&lt; Route &gt;有什么不同？<br>&lt; Switch &gt;的独特之处是独它仅仅渲染一个路由。相反地，每一个包含匹配地址(location)的&lt; Route &gt;都会被渲染。思考下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;Route path=<span class="string">"/:user"</span> component=&#123;User&#125;/&gt;</span><br><span class="line">&lt;Route component=&#123;NoMatch&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果现在的URL是 /about ，那么 &lt; About &gt;, &lt; User &gt;, 还有 &lt; NoMatch &gt; 都会被渲染，因为它们都与路径(path)匹配。这种设计，允许我们以多种方式将多个 &lt; Route &gt; 组合到我们的应用程序中，例如侧栏(sidebars)，面包屑(breadcrumbs)，bootstrap tabs等等。 然而，偶尔我们只想选择一个&lt; Route &gt; 来渲染。如果我们现在处于 /about ，我们也不希望匹配 /:user （或者显示我们的 “404” 页面 ）。以下是使用 Switch 的方法来实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125;/&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/:user"</span> component=&#123;User&#125;/&gt;</span><br><span class="line">  &lt;Route component=&#123;NoMatch&#125;/&gt;</span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>现在，如果我们处于 /about, <switch> 将开始寻找匹配的 <route>。 <route path="/about"> 将被匹配， <switch> 将停止寻找匹配并渲染<about>。 同样，如果我们处于 /michael ， <user> 将被渲染。  </user></about></switch></route></route></switch></p>
<p>这对于过渡动画也是起作用的，因为匹配的 <route> 在与前一个相同的位置被渲染。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;Fade&gt;</span><br><span class="line">  &lt;Switch&gt;</span><br><span class="line">    &#123;<span class="comment">/* there will only ever be one child here */</span>&#125;</span><br><span class="line">    &#123;<span class="comment">/* 这里只会有一个子节点 */</span>&#125;</span><br><span class="line">    &lt;Route/&gt;</span><br><span class="line">    &lt;Route/&gt;</span><br><span class="line">  &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Fade&gt;</span><br><span class="line"></span><br><span class="line">&lt;Fade&gt;</span><br><span class="line">  &lt;Route/&gt;</span><br><span class="line">  &lt;Route/&gt;</span><br><span class="line">  &#123;<span class="comment">/* there will always be two children here,</span></span><br><span class="line"><span class="comment">      one might render null though, making transitions</span></span><br><span class="line"><span class="comment">      a bit more cumbersome to work out */</span>&#125;</span><br><span class="line">   &#123;<span class="comment">/* 这里总是有两个子节点,</span></span><br><span class="line"><span class="comment">      一个可能会渲染为null, 使计算过渡增加了一点麻烦 */</span>&#125;    </span><br><span class="line">&lt;<span class="regexp">/Fade&gt;</span></span><br></pre></td></tr></table></figure></route></p>
<h3 id="children-node-5"><a href="#children-node-5" class="headerlink" title="children: node"></a>children: node</h3><p>&lt; Switch &gt; 的所有子节点应为 &lt; Route &gt; 或 &lt; Redirect &gt; 元素。只有匹配当前地址(location)的第一个子节点才会被渲染。&lt; Route &gt; 元素使用它们的 path 属性匹配，&lt; Redirect &gt; 元素使用它们的 from 属性匹配。没有 path 属性的&lt; Route &gt; 或者 没有 from 属性的 &lt; Redirect &gt; 将总是可以匹配当前的地址(location)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Route path=<span class="string">"/users"</span> component=&#123;Users&#125;/&gt;</span><br><span class="line">  &lt;Redirect <span class="keyword">from</span>=<span class="string">"/accounts"</span> to=<span class="string">"/users"</span>/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Route component=&#123;NoMatch&#125;/&gt;</span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>本文档中的「history」以及「history对象」请参照 history 包中的内容。 History 是 React Router 的两大重要依赖之一（除去 React 本身），在不同的 Javascript 环境中，history 以多种形式实现了对于 session 历史的管理。<br>我们会经常使用以下术语：</p>
<ul>
<li>「browser history」 - history 在 DOM 上的实现，经常使用于支持 HTML5 history API 的浏览器端。</li>
<li>「hash history」 - history 在 DOM 上的实现，经常使用于旧版本浏览器端。</li>
<li><p>「memory history」 - 一种存储于内存的 history 实现，经常用于测试或是非 DOM 环境（例如 React Native）。</p>
<p>history 对象通常会具有以下属性和方法：</p>
</li>
<li>length -（ number 类型）指的是 history 堆栈的数量。</li>
<li>action -（ string 类型）指的是当前的动作（action），例如 PUSH，REPLACE 以及 POP 。</li>
<li>location -（ object类型）是指当前的位置（location），location 会具有如下属性：<ul>
<li>pathname -（ string 类型）URL路径。</li>
<li>search -（ string 类型）URL中的查询字符串（query string）。</li>
<li>hash -（ string 类型）URL的 hash 分段。</li>
<li>state -（ string 类型）是指 location 中的状态，例如在 push(path, state) 时，state会描述什么时候 location 被放置到堆栈中等信息。这个 state 只会出现在 browser history 和 memory history 的环境里。</li>
</ul>
</li>
<li>push(path, [state]) -（ function 类型）在 hisotry 堆栈顶加入一个新的条目。</li>
<li>replace(path, [state]) -（ function 类型）替换在 history 堆栈中的当前条目。</li>
<li>go(n) -（ function 类型）将 history 对战中的指针向前移动 n 。</li>
<li>goBack() -（ function 类型）等同于 go(-1) 。</li>
<li>goForward() -（ function 类型）等同于 go(1) 。</li>
<li>block(prompt) -（ function 类型）阻止跳转，（请参照 history 文档）。<h3 id="history-是可变的（mutable）"><a href="#history-是可变的（mutable）" class="headerlink" title="history 是可变的（mutable）"></a>history 是可变的（mutable）</h3>history 对象是可变的，因此我们建议从 <route> 的 prop里来获取 location ，而不是从 history.location 直接获取。这样做可以保证 React 在生命周期中的钩子函数正常执行，例如以下代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="comment">// locationChanged 变量为 true</span></span><br><span class="line">    <span class="keyword">const</span> locationChanged = nextProps.location !== <span class="keyword">this</span>.props.location</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不正确，locationChanged 变量会 *永远* 为 false ，因为 history 是可变的（mutable）。</span></span><br><span class="line">    <span class="keyword">const</span> locationChanged = nextProps.history.location !== <span class="keyword">this</span>.props.history.location</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Route component=&#123;Comp&#125;/&gt;</span><br></pre></td></tr></table></figure>
</route></li>
</ul>
<p>不同的实现也许会提供给你额外的属性，更多详情请参照 <a href="https://github.com/ReactTraining/history#properties" target="_blank" rel="noopener">history 文档</a>。</p>
<h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>Location 是指你当前的位置，下一步打算去的位置，或是你之前所在的位置，形式大概就像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  key: <span class="string">'ac3df4'</span>, <span class="comment">// 在使用 hashHistory 时，没有 key</span></span><br><span class="line">  pathname: <span class="string">'/somewhere'</span></span><br><span class="line">  search: <span class="string">'?some=search-string'</span>,</span><br><span class="line">  hash: <span class="string">'#howdy'</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    [userDefined]: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你使用以下几种方式来获取 location 对象：</p>
<ul>
<li>在 Route component 中，以 this.props.location 的方式获取，</li>
<li>在 Route render 中，以 ({ location }) =&gt; () 的方式获取，</li>
<li>在 Route children 中，以 ({ location }) =&gt; () 的方式获取，</li>
<li>在 withRouter 中，以 this.props.location 的方式获取。</li>
</ul>
<p>你也可以在 history.location 中获取 location 对象，但是别那么写，因为 history 是可变的。更多信息请参见 <a href="https://github.com/ReactTraining/history#properties" target="_blank" rel="noopener">history 文档</a>。  </p>
<p>location 对象不会发生改变，因此你可以在生命周期的钩子函数中使用 location 对象来查看当前页面的位置是否发生改变，这种技巧在获取远程数据以及使用动画时非常有用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象来查看当前页面的位置是否发生改变，这种技巧在获取远程数据以及使用动画时非常有用。componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.location !== <span class="keyword">this</span>.props.location) &#123;</span><br><span class="line">    <span class="comment">// 已经跳转了！</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以在不同环境中使用 location ：</p>
<ul>
<li>Web Link to</li>
<li>Native Link to</li>
<li>Redirect to</li>
<li>history.push</li>
<li>history.replace<br>通常情况下，你只需要给一个字符串当做 location ，但是，当你需要添加一些 location 的状态时，你可以对象的形式使用 location 。并且当你需要多个 UI ，而这些 UI 取决于历史时，例如弹出框（modal），使用location 对象会有很大帮助。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/ 通常你只需要这样使用 location</span><br><span class="line">&lt;Link to=<span class="string">"/somewhere"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是你同样可以这么用js</span></span><br><span class="line"><span class="keyword">const</span> location = &#123;</span><br><span class="line">  pathname: <span class="string">'/somewhere'</span></span><br><span class="line">  state: &#123; <span class="attr">fromDashboard</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Link to=&#123;location&#125;/&gt;</span><br><span class="line">&lt;Redirect to=&#123;location&#125;/&gt;</span><br><span class="line">history.push(location)</span><br><span class="line">history.replace(location)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最后，你可以把 location 传入一下组件：</p>
<ul>
<li>Route</li>
<li>Switch<br>这样做可以让组件不使用路由状态（router state）中的真实 location，因为我们有时候需要组件去渲染一个其他的 location 而不是本身所处的真实 location，比如使用动画或是等待跳转时。<h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2>match 对象包含了 <route path> 如何与URL匹配的信息。match 对象包含以下属性：</route></li>
<li>params -（ object 类型）即路径参数，通过解析URL中动态的部分获得的键值对。</li>
<li>isExact - 当为 true 时，整个URL都需要匹配。</li>
<li>path -（ string 类型）用来做匹配的路径格式。在需要嵌套 <route> 的时候用到。</route></li>
<li>url -（ string 类型）URL匹配的部分，在需要嵌套 <link> 的时候会用到。<br>你可以在以下地方获取 match 对象：</li>
<li>在 Route component 中，以 this.props.match 方式。</li>
<li>在 Route render 中，以 ({ match }) =&gt; () 方式。</li>
<li>在 Route children 中，以 ({ match }) =&gt; () 方式</li>
<li>在 withRouter 中，以 this.props.match 方式</li>
<li>matchPath 的返回值<br>当一个 Route 没有 path 时，它会匹配一切路径，你会匹配到最近的父级。在 withRouter 里也是一样的。</li>
</ul>
<h3 id="null-matches"><a href="#null-matches" class="headerlink" title="null matches"></a>null matches</h3><p>即使路径的路径与当前位置不匹配，&lt; Route &gt;也可以使用子属性来调用其子功能。 但在这种情况下，匹配将为null。 能够在匹配时渲染&lt; Route &gt;的内容可能是有用的，但是这种情况会产生一些挑战。</p>
<p>“解析”URL的默认方法是将match.url字符串拼接到“相对”路径。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`<span class="subst">$&#123;match.url&#125;</span>/relative-path`</span></span><br></pre></td></tr></table></figure></p>
<p>如果在匹配为空时尝试执行此操作，最终会出现TypeError。 这意味着在使用子属性尝试连接&lt; Route &gt;内的“relative”路径是不安全的。</p>
<p>当你在生成空匹配对象的&lt; Route &gt;中使用没有path的&lt; Route &gt;时，会出现类似但更微妙的情况。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// location.pathname = '/matches'</span></span><br><span class="line">&lt;Route path=<span class="string">'/does-not-match'</span> children=&#123;(&#123; match &#125;) =&gt; (</span><br><span class="line">  <span class="comment">// match === null</span></span><br><span class="line">  &lt;Route render=&#123;(&#123; <span class="attr">match</span>:pathlessMatch &#125;) =&gt; (</span><br><span class="line">    <span class="comment">// pathlessMatch === ???</span></span><br><span class="line">  )&#125;/&gt;</span><br><span class="line">)&#125;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>没有path属性的&lt; Route &gt;从其父级继承匹配对象。 如果她们的父匹配为null，那么她们的匹配也将为null。 这意味着<br>a）任何子路由/链接必须是绝对路径，因为没有要解析的父级<br>b）父级匹配可以为null的无路径路由将需要使用子属性来渲染。</p>
<h2 id="matchPath"><a href="#matchPath" class="headerlink" title="matchPath"></a>matchPath</h2><p>这允许您使用与一样使用的相同的代码，除了在正常渲染循环之外，例如在服务器上渲染之前收集数据依赖关系<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; matchPath &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> match = matchPath(<span class="string">'/users/123'</span>, &#123;</span><br><span class="line">  path: <span class="string">'/users/:id'</span></span><br><span class="line">  exact: <span class="literal">true</span>,</span><br><span class="line">  strict: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="pathname"><a href="#pathname" class="headerlink" title="pathname"></a>pathname</h3><p>第一参数是你想要匹配的 pathname, 如果你正在服务端的 nodos.js 下使用, 将会是 req.url</p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>第二个参数是不予匹配的属性, 他们于匹配 Route 接收的参数属性是相同的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path, <span class="comment">// like /users/:id</span></span><br><span class="line">  strict, <span class="comment">// 可选, 默认 false</span></span><br><span class="line">  exact <span class="comment">// 可选, 默认 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h2><p>你可以通过withRouter的高阶组件访问history对象的属性和最相似的&lt; Route &gt;的匹配。 每次路由更改时，无论如何是如何渲染的，withRouter将会给封装的组件传递更新的match,location 和 history属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mport React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">"react-router"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A simple component that shows the pathname of the current location</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowTheLocation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    match: PropTypes.object.isRequired,</span><br><span class="line">    location: PropTypes.object.isRequired,</span><br><span class="line">    history: PropTypes.object.isRequired</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; match, location, history &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>You are now at &#123;location.pathname&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new component that is "connected" (to borrow redux</span></span><br><span class="line"><span class="comment">// terminology) to the router.</span></span><br><span class="line"><span class="keyword">const</span> ShowTheLocationWithRouter = withRouter(ShowTheLocation);</span><br></pre></td></tr></table></figure></p>
<h3 id="重要提醒"><a href="#重要提醒" class="headerlink" title="重要提醒"></a>重要提醒</h3><p>withRouter不追踪location的更改，而是在从&lt; Router &gt;组件传播出去的location改变后重新渲染，这意味着withRouter不会在路由改变时重新渲染，除非她的父组件重新渲染。  </p>
<p>静态方法和属性。</p>
<p>封装的组件的所有非React的静态方法和属性都会被自动的复制到已连接的组件。</p>
<h3 id="Component-WrappedComponent"><a href="#Component-WrappedComponent" class="headerlink" title="Component.WrappedComponent"></a>Component.WrappedComponent</h3><p>封装的组件作为返回组件上的静态属性WrappedComponent暴露，这个组件可以用于测试。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyComponent.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(MyComponent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyComponent.test.js</span></span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./MyComponent'</span></span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent.WrappedComponent</span> <span class="attr">location</span>=<span class="string">&#123;&#123;...&#125;&#125;</span> <span class="attr">...</span> /&gt;</span>)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="wrappedComponentRef-func"><a href="#wrappedComponentRef-func" class="headerlink" title="wrappedComponentRef: func"></a>wrappedComponentRef: func</h3><p>作为引用的属性被传递给封装的组件的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Container extends React.Component &#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.component.doSomething();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;MyComponent wrappedComponentRef=&#123;c =&gt; (this.component = c)&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="https://www.jianshu.com/u/231315b8e406" target="_blank">Fengzhen8023</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/2019/12/15/React Router V5 翻译文档9：静态路由/" class="pre-post btn btn-default" title='React Router V5 翻译文档9：静态路由'>
        <span class="remove-hidden-lg">上一篇</span>
        <span class="hidden-xs">
            React Router V5 翻译文档9：静态路由</span>
    </a>
    
    
    <a href="/2019/08/11/webpack入门学习笔记15 —— Webpack中的三个小插件/" class="next-post btn btn-default" title='webpack入门学习笔记15 —— Webpack中的三个小插件'>
        <span class="remove-hidden-lg">下一篇</span>
        <span class="hidden-xs">
            webpack入门学习笔记15 —— Webpack中的三个小插件</span></i>
    </a>
    
</div>

<div id="comments">
    

<div id="vcomments" class="valine"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>
<script>
new Valine({
    av: AV,
    el: '#vcomments',
    appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
    appKey: 'erIpQac4azoCmgfBB7Dl9maa',
    placeholder: '说点什么吧',
    notify: false,
    verify: true,
    avatar: 'mm',
    meta: 'nick,mail'.split(','),
    pageSize: '10',
    path: window.location.pathname,
    lang: 'en'.toLowerCase()
})
</script>


</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            Table of Contents
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#转载说明"><span class="toc-text">转载说明</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lt-BrowserRouter-gt"><span class="toc-text">&lt; BrowserRouter &gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#basename-String"><span class="toc-text">basename: String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getUserConfirmation-func"><span class="toc-text">getUserConfirmation: func</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forceRefresh-bool"><span class="toc-text">forceRefresh: bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keyLength-number"><span class="toc-text">keyLength: number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#children-node"><span class="toc-text">children: node</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lt-HashRouter-gt"><span class="toc-text">&lt; HashRouter &gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#basename-string"><span class="toc-text">basename: string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getUserConfirmation-func-1"><span class="toc-text">getUserConfirmation: func</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashType-string"><span class="toc-text">hashType: string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#children-node-1"><span class="toc-text">children: node</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lt-Link-gt"><span class="toc-text">&lt; Link &gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#to-string"><span class="toc-text">to: string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#to-object"><span class="toc-text">to: object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replace-bool"><span class="toc-text">replace: bool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lt-NavLink-gt"><span class="toc-text">&lt; NavLink &gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#activeClassName-string"><span class="toc-text">activeClassName: string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#activeStyle-object"><span class="toc-text">activeStyle: object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exact-bool"><span class="toc-text">exact: bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strict-bool"><span class="toc-text">strict: bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isActive-func"><span class="toc-text">isActive: func</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lt-Prompt-gt"><span class="toc-text">&lt; Prompt &gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#message-string"><span class="toc-text">message: string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#message-func"><span class="toc-text">message: func</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#when-bool"><span class="toc-text">when: bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lt-MemoryRouter-gt"><span class="toc-text">&lt; MemoryRouter &gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initialEntries-array"><span class="toc-text">initialEntries: array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initialIndex-number"><span class="toc-text">initialIndex: number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getUserConfirmation-func-2"><span class="toc-text">getUserConfirmation: func</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keyLength-number-1"><span class="toc-text">keyLength: number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#children-node-2"><span class="toc-text">children: node</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lt-Redirect-gt"><span class="toc-text">&lt; Redirect &gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#to-string-1"><span class="toc-text">to: string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#to-object-1"><span class="toc-text">to: object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push-bool"><span class="toc-text">push: bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#from-string"><span class="toc-text">from: string</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lt-Route-gt"><span class="toc-text">&lt; Route &gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Route渲染方法"><span class="toc-text">Route渲染方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#component"><span class="toc-text">component</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#render-func"><span class="toc-text">render: func</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#children-func"><span class="toc-text">children: func</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#path-string"><span class="toc-text">path: string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exact-bool-1"><span class="toc-text">exact: bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strict-bool-1"><span class="toc-text">strict: bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#location-object"><span class="toc-text">location: object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sensitive-bool"><span class="toc-text">sensitive: bool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lt-Router-gt"><span class="toc-text">&lt; Router &gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#history-object"><span class="toc-text">history: object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#children-node-3"><span class="toc-text">children: node</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lt-StaticRouter-gt"><span class="toc-text">&lt; StaticRouter &gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#basename-string-1"><span class="toc-text">basename: string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#location-string"><span class="toc-text">location: string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#location-object-1"><span class="toc-text">location: object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#context-object"><span class="toc-text">context: object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#children-node-4"><span class="toc-text">children: node</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lt-Switch-gt"><span class="toc-text">&lt; Switch &gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#children-node-5"><span class="toc-text">children: node</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#history"><span class="toc-text">history</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#history-是可变的（mutable）"><span class="toc-text">history 是可变的（mutable）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#location"><span class="toc-text">location</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#match"><span class="toc-text">match</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#null-matches"><span class="toc-text">null matches</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#matchPath"><span class="toc-text">matchPath</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pathname"><span class="toc-text">pathname</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#props"><span class="toc-text">props</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#withRouter"><span class="toc-text">withRouter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#重要提醒"><span class="toc-text">重要提醒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Component-WrappedComponent"><span class="toc-text">Component.WrappedComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wrappedComponentRef-func"><span class="toc-text">wrappedComponentRef: func</span></a>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="iconfont icon-top"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2017
                    
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script src="/js/app.js?rev=@@hash"></script>
</body>
</html>